              
                                                            
             gflop   for the numerical factorization: %f
             gflop/s for the numerical factorization: %f
             number of columns for each panel: %d
             number of columns for each panel: %lli
             number of equations:           %d
             number of equations:           %lli
             number of independent subgraphs:  %d
             number of independent subgraphs:  %lli
             number of non-zeros in A (%%): %f
             number of non-zeros in A:      %d
             number of non-zeros in A:      %lli
             number of non-zeros in L+U:              %d
             number of non-zeros in L+U:              %lli
             number of non-zeros in L:                %d
             number of non-zeros in L:                %lli
             number of non-zeros in U:                %d
             number of non-zeros in U:                %lli
             number of right-hand sides:    %d
             number of right-hand sides:    %lli
             number of supernodes:                    %d
             number of supernodes:                    %lli
             size of largest supernode:               %d
             size of largest supernode:               %lli
             ||A||                                    %f
           #include "pmmintrin.h"
           #include "xmmintrin.h"
           _MM_SET_DENORMALS_ZERO_MODE(_MM_DENORMALS_ZERO_ON);
           _MM_SET_FLUSH_ZERO_MODE(_MM_FLUSH_ZERO_ON);
           in the MXCSR control and status register. This can have a severe 
           performance impact. Please enable these modes for each application 
           thread the following way:
          ia(neqns_in+1)-1: %d nb_in         : %d
          ia(neqns_in+1)-1: %lli nb_in         : %lli
          ia[neqns_in]-1  : %d nb_in         : %d
          ia[neqns_in]-1  : %lli nb_in         : %lli
          ido_in          : %d neqns_in      : %d
          ido_in          : %lli neqns_in      : %lli
          matrix_number_in: %d matrix_type_in: %d
          matrix_number_in: %i matrix_type_in: %d
          matrix_number_in: %lli matrix_type_in: %lli
      Factorization: Time for reading from files: %f
      Factorization: Time for writing to files  : %f
      Solution:      Time for reading from files: %f
      Time A to LU:
      Time cgs    :
      Time fulladj:
      Time malloc :
      Time numfct :
      Time parlist:
      Time reorder:
      Time solve  :
      Time symbfct:
      Time total  :
      factorization - write&read: %d %%
      factorization - write&read: %lli %%
      read from files: %10.3f Mb
      read from files: %d %%
      read from files: %lli %%
      solve - write&read: %d %%
      solve - write&read: %lli %%
      total - write&read: %d %%
      total - write&read: %lli %%
      write to files : %10.3f Mb
      write to files : %d %%
      write to files : %lli %%
      write&read     : %10.3f Mb
    Features: 
    ISA     : 
    Targets : 
    Tasking : 
    Threads : 
    histogram      : 
   ISA      : 
   MXCSR    : 
   Targets  : 
   Threads  : 
  Build     : 
  CPU       : 
  Compiler  : 
  Config
  Platform  : 
  WARNING: "Flush to Zero" or "Denormals are Zero" mode not enabled 
  accel              = 
  affinity           = 
  build threads      = 
  build user threads = 
  builder            = 
  cache_size         = 
  estimatedSize = 
  free blocks = 
  frequency_level    = 
  geomID = 
  getAABBNodes     : 
  getAABBNodesMB   : 
  getAABBNodesMB4D : 
  hugepages          = 
  instID =
  instPrimID =
  leaves           : 
  malloc: 
  max_leaf_size      = 
  max_spatial_split_replications = 
  min_leaf_size      = 
  primID = 
  primitives = 
  quantizedNodes   : 
  shared: 
  start_threads      = 
  total            : sah = 
  traverser          = 
  ungetAABBNodes   : 
  ungetAABBNodesMB : 
  used blocks = 
  verbosity          = 
 %.2fGHz
 %f s cgx iterations %d
 %f s cgx iterations %lli
 %f s total - sum: %f s
 %s build %s for %s %s
 (100.00%), 
 (compile time enabled)
 (supported)
 +2<vdR
 - contradiction (set ido>0) %d
 - contradiction (set ido>0) %lli
 -D AMD_MEDIA_OPS 
 -cl-mad-enable -cl-fast-relaxed-math -cl-std=CL1.2 -I . 
 289
 2=QO
 2R;m
 3:1a
 4,Bt
 4N:X
 4a<S
 7=t1
 8Ic
 92M
 9\dk9R
 9\te6
 9kF]
 9zmp;oH\t
 ;1qb
 ;IiH9
 ;zmv
 <8qC
 <EbQ
 <mLk
 =Hn8
 ?QJI?me
 BVH
 Build 
 CNR:%s
 CmQ,
 Dyn:%d
 Export functionality error: CODE PATH = %d not supported.
 Export functionality error: DATA_NAME = %d not supported.
 Export functionality error: INVALID DATA_NAME = %d.
 Export functionality error: INVALID OPERATION = %d.
 Export functionality error: INVALID handle.
 Export functionality error: NULL handle.
 Export functionality error: OPERATION = %d not supported.
 Export functionality error: distrubution overlap is not supported.
 Export functionality error: integer overflow, consider using ILP64 interface.
 Export functionality error: not all required pointers has been provided before calling main export routine.
 Export functionality error: some of the input pointers are NULL.
 Export functionality error: unidentified error.
 FastMM:%d
 GB/s
 H;Ry
 I;s8A
 IJ>7
 Ih9
 K9Hu^9
 MB (100.00%), 
 Mprim/s, 
 Mq<n
 PARDISO message: Interrupted by the mkl_progress function.
 Patch %d
 Q<OX
 RC=hb
 Update %d
 X;60
 Y;J0
 Z9;K
 applications
 character 
 contraction rate is greater than 0.9, interrupt
 dy=3
 e8EH
 exceeds maximum iteration number %d
 exceeds maximum iteration number %lli
 failed: cylinder = 
 for 
 for BVH4<GridMesh>
 for BVH4<Object>
 for BVH4<Quad4i>
 for BVH4<Quad4iMB>
 for BVH4<Quad4v>
 for BVH4<Triangle4>
 for BVH4<Triangle4i>
 for BVH4<Triangle4iMB>
 for BVH4<Triangle4v>
 for BVH4<Triangle4vMB>
 for BVH4MB<GridMesh>
 for BVH4OBB<VirtualCurve4i>
 for BVH4OBB<VirtualCurve4iMB>
 for BVH4OBB<VirtualCurve4v>
 for BVH4OBB<VirtualCurve8i>
 for BVH4OBB<VirtualCurve8iMB>
 for BVH8<Object>
 for BVH8<Quad4i>
 for BVH8<Quad4v>
 for BVH8<Triangle4>
 for BVH8<Triangle4i>
 for BVH8<Triangle4iMB>
 for BVH8<Triangle4v>
 for BVH8<Triangle4vMB>
 for BVH8MB<GridMesh>
 for QBVH8<Quad4i>
 iS;U,H
 iX8
 inflate 1.2.13 Copyright 1995-2022 Mark Adler 
 k=k6
 line 
 n2:Nu
 o6;1
 o:cPO
 parameter number %4i had an illegal value 
 q9\r3
 qe;4
 real (including 1 factor): %d
 uB;L
 vN9
 y<Pq
!095
!3C<u
!6;Gb
!87s
!94E
!9JT
!9e7
!9f5
!9qI:
!:6Ja
!:TSo7
!:Yfp
!:ooq:w
!;Rax
!;UCd
!;b0o
!<Dgi;d
!<HFI
!<rLc
!=0n4
!=igy;p
!>BtR
!A:HB
!B<Vo
!ET<p
!F;YR3
!F>o7
!IK9
!IQ<V
!J;gv
!KZ9
!M:G8
!P7%Cs
!P:glm9!
!Sh;v
!UL<o
!XC<u
!Yp8
!Z<l1
!\t@%s: HRTF data contains Ambisonic HRIRs of unsupported order: %d.
!\t@REF%08lX
!\tp;GJl
!au9
!avx::BVH4Quad4vIntersector8HybridMoellerNoFilter
!c:8S
!eL;6E
!jB9
!jn:q
!n48
!n:v6
!q;tk
!r;Aq
!ui:B
!v89u
!w19"
"59\N
"5;AA
"7GKE
"8jd
"8un
"943
"9Rg
"9x2
":0uQ
":ay57u
":x-[;`^':u
";0oe9
";Nz7
";Z30:Bq
";vdj
"<0Ws
"<Xpf
"=Hgf
"=VYh
"=oAh
">gw4
"Ac:9
"Anm
"BA;e
"C<EV
"CB:G
"Gl;h3
"H8|UT
"I=jm
"L<tsF
"M?FM
"O:uZ
"S7jh@
"SHARED TESSELLATION CACHE"
"T9i5Z:\tH
"TL;i
"U=9xk
"c;nNl
"fG9
"hP>h
"i;Zo5
"lQ<7
"lY;V
"memkind".dll
"n:b8
"n;2T
"n;Yw
"nh;xl
"p8E
"r2;S
"t1?"t1?"t1?"t1?
"t1?"t1?"t1?"t1?"t1?"t1?"t1?"t1?
"u8U
"x9;Fu
"z7U)
"z:jPj
# Generated by Steam Audio\n
# x<EHv
#3R<co
#4l;G{f
#79Ja
#8KR
#8ut
#9'CZ
#9BS
#9Lg
#9Qa
#9Z8\rx
#9qZs
#9xv
#:TRY
#;8wa
#;FVK
#;GAS
#;WRV
#<DsO
#<EBw
#=mNH
#B;fO
#C<ds
#D9b
#E;Sb
#E<MF3
#ED<U
#G=hL
#K18
#KO;M
#Loop | #Eig  |    Trace     | Error-Trace |  Max-Residual
#M=ky
#N:KJ
#Sp>g8d
#TT;B
#Z<2b1<
#bytes = 
#bytes/prim = 
#ha;gRa:r< 
#kg=l
#mY90W
#nY<*y1
#no9yaa
#nodes = 
#ur;9
#v\t<8Rj
#vj8jB49
#zS;p
$#:jW99
$0d;8
$73b
$7hz
$8}Ee
$91D
$96<Ns
$9I*M
$9ad
$9t:VW
$9v$7
$:F5Z
$;32Q
$;6gU9f
$;;Ydx9
$;CvG
$;R=u;}]B;$v":
$;XmQ
$;bRM
$<2B8
$<2L1
$<2Yu
$<KmV<3
$<RCe
$<XD3
$<zNZ
$=Un4
$>mUr
$A<GmO
$B :UsK
$E{:cAq
$G:zY
$L9i
$M=Yr
$U:7P
$U;L]@9XbE=
$UD=F
$V5=os`
$W<96
$WN;Z2<
$\HCMF}
$a89
$jA8
$kC9
$mo<F
$n;46
$o8c
$p2<C
$r<2wg
$rK<ldC
$s<MBs
$tF=A
$x81
$yF?w
$z\|Fzn
$|9tJ
% filled), 
%-6i %-6i %-3i     %-8.4f %-8.4f
%-6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e
%-6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e   FAIL
%-6i %-6i %-3i    %-10.3f %-8.4f %-10e %-10e   pass
%.0Lf
%.0fns
%.2fms
%.2fs
%.2fus
%0<q0
%7I9
%88HA
%9Om6
%9qD@
%:3uS
%:R9D:U
%:lJN
%;Jc,;_Yc;Gd6;
%;faK
%;kDa
%;owj9
%;}M%;3J}6i
%<Jos
%<Kh1
%<lA9
%=4gN
%=tWE
%C;XDb;S
%F;wK
%FI;d]N8Qo
%H : %M : %S
%H:<qkv
%H=Nt
%I : %M : %S %p
%I64d
%JZ;2
%P9b
%T:0X
%T;4J
%Uq:f
%Vs9
%Xh;W
%a?;RFe
%ai9
%b %d %H : %M : %S %Y
%d / %m / %y
%d,%d,%.15e,%.15e,%.15e
%d,%d,%.7e,%.7e,%.7e
%d,%d,%d,%d
%e9o
%ez<8w
%f;k2
%gi;7
%hu9
%iU;c
%k;eS
%lY8
%lZ=vI
%m / %d / %y
%s double precision computation is turned ON
%s single precision computation is turned ON
%s9&3
%s: Unsupported HRTF data format version: %d.
%s: invalid %s: %s = %s
%sy:S
%t$\t%d#\t%4"\t%
%t(\t%d'\t%4&\t%
%tH\t%dG\t%4F\t%
%t\f\t%d\v\t%4\n\t%
%u,%u,%u,%u
%uG;V
%w9H
%x7:x
%y;Xe
%yR;X
%yS;n
&5:zj
&9Z:J
&:FjB:C2
&;HCL;o
&;IhB
&;hwm
&;zOD
&<3gS
&<iY6
&<zZE
&>:4Y,96r
&A<Jg
&EJ<r
&FZ<Th9
&I7,QG9d
&J@>HBh
&K4:s
&K;2T
&L18
&M<okk
&O!9u\tr
&OR<nNE
&W=tY
&b:cN
&c>uo
&de<M
&gC<n
&h9;u
&ix<K
&no;o3
&oL9
&tp;bJ
'09s
'139
'32;U
'3h;D
'4z<4/Q
'5<Iv
'8GJT
'8cYs:
'97oH:
'9N\rC9
'9QP
'9\t5G;Y
':H1l
':gM3<Xs
';509;k
';9rZ
';S10
';U5i
';gGj
';zAw
'<5NA
'<VbH
'<kpE
'<lwS
'>XBO
'If;d
'J9D
'O95
'QB:g
'S9W
'S9x
'T7x
'V;j5X
'Y2<N
'Y;ND
'\v3x(\v*h)\v!tZ
'\v8x(\v/h)\v&
'b;qE
'b=oD
'e;ykv:
'g:V6s
'g:isr9U
'g;XP
'hs:XO$
'i3;5
'jS;w
'k9c
'kb8
'm8M
'p7M}f
'rE:1
'rp<G
'v:s9
'x<qio
'z;qbC
'zG:G
(&inputs->airAbsorptionModel)
(&inputs->airAbsorptionModel)->callback
(&inputs->airAbsorptionModel)->coefficients
(&inputs->airAbsorptionModel)->coefficients[iArray]
(&inputs->airAbsorptionModel)->dirty
(&inputs->airAbsorptionModel)->type
(&inputs->directivity)
(&inputs->directivity)->dipolePower
(&inputs->directivity)->dipoleWeight
(&inputs->distanceAttenuationModel)
(&inputs->distanceAttenuationModel)->callback
(&inputs->distanceAttenuationModel)->dirty
(&inputs->distanceAttenuationModel)->minDistance
(&inputs->distanceAttenuationModel)->type
(&inputs[i])
(&inputs[i])->energyField
(&outputs->direct)->airAbsorption[iBand]
(&outputs->direct)->directivity
(&outputs->direct)->distanceAttenuation
(&outputs->direct)->flags
(&outputs->direct)->occlusion
(&outputs->direct)->transmissionType
(&outputs->direct)->transmission[iBand]
(&outputs->pathing)
(&outputs->pathing)->binaural
(&outputs->pathing)->eqCoeffs[iBand]
(&outputs->pathing)->hrtf
(&outputs->pathing)->listener.ahead.x
(&outputs->pathing)->listener.ahead.y
(&outputs->pathing)->listener.ahead.z
(&outputs->pathing)->listener.origin.x
(&outputs->pathing)->listener.origin.y
(&outputs->pathing)->listener.origin.z
(&outputs->pathing)->listener.right.x
(&outputs->pathing)->listener.right.y
(&outputs->pathing)->listener.right.z
(&outputs->pathing)->listener.up.x
(&outputs->pathing)->listener.up.y
(&outputs->pathing)->listener.up.z
(&outputs->pathing)->order
(&outputs->pathing)->shCoeffs[iCoeff]
(&outputs->reflections)
(&outputs->reflections)->delay
(&outputs->reflections)->eq[iBand]
(&outputs->reflections)->ir
(&outputs->reflections)->irSize
(&outputs->reflections)->numChannels
(&outputs->reflections)->reverbTimes[iBand]
(&outputs->reflections)->tanDevice
(&outputs->reflections)->tanSlot
(&outputs->reflections)->type
(&outputs[i])
(&outputs[i])->impulseResponse
(*identifier).endpointInfluence.center.x
(*identifier).endpointInfluence.center.y
(*identifier).endpointInfluence.center.z
(*identifier).endpointInfluence.radius
(*identifier).type
(*identifier).variation
(-o:CD0
(1d=l
(57;M
(5F=4u
(6w;S
(76;6
(7gcA;
(96B
(9DBu9
(9O k
(:EIh
(;L4B
(;d0M
(;rH6;3
(<C$\t<C6v;~
(<iAP
(AA=H
(Af<Z
(D4<I
(Dp<W
(Hd9
(M9rU'
(RUU
(_9US
(aV:M
(b4>0D&F
(debug) 
(e3:gN
(e;oAV
(f;k2
(inputs->deviationModel)
(inputs->deviationModel)->callback
(inputs->deviationModel)->type
(l9X
(matrix size-1) if IPAR(7)>0, aborting otherwise.
(q;WkE
(qF;F
(s9A
(zQ;mv
)1;jt
)1Y9
)2Q;n
)4i;w9
)6<cNx:
)6=E0
)80pR<pIQ;#
)98eL
)9>LXN>
)9B5O<
)9K\nM
);bVY
)<lF6
)<qTi
)=9Lz5
)=Fft
)?u6x
)A<6fg
)B;Bk
)F<x$Y=zI
)Fn9
)Gl<A
)Hk;i
)ID=i
)Ku<X
)Oz:9
)R;rW
)SX<ZoG
)V36|
)WT94
)Xo>c
)Xw>YZ
)\SA33
)\t;GR4;KKY;
)b8w7F
)bW:0
)d9<kQ
)e:uw
)fLL#
)ff;5A
)h:Tz
)i;Mzu
)lP9[
)o:L4
)q0<m
)qo:x
)t;yr
)yy:h
)z9a
){;BN:;lY<:
)|=55M>vG
*** Error in PARDISO  (        reordering_phase) error_num= %d
*** Error in PARDISO  (        reordering_phase) error_num= %lli
*** Error in PARDISO  (        reordering_phase) internal error_num= %d
*** Error in PARDISO  (      open OOC tmp files) error_num= %d
*** Error in PARDISO  (      open OOC tmp files) error_num= %lli
*** Error in PARDISO  (      open OOC tmp files) internal error_num= %d
*** Error in PARDISO  (     insufficient_memory) error_num= %d
*** Error in PARDISO  (     insufficient_memory) error_num= %lli
*** Error in PARDISO  (     insufficient_memory) internal error_num= %d
*** Error in PARDISO  ( internal_error,unclass.) error_num= %d
*** Error in PARDISO  ( internal_error,unclass.) error_num= %lli
*** Error in PARDISO  ( internal_error,unclass.) internal error_num= %d
*** Error in PARDISO  ( not enough mem. for OOC) error_num= %d
*** Error in PARDISO  ( not enough mem. for OOC) error_num= %lli
*** Error in PARDISO  ( not enough mem. for OOC) internal error_num= %d
*** Error in PARDISO  ( numerical_factorization) error_num= %d
*** Error in PARDISO  ( numerical_factorization) error_num= %lli
*** Error in PARDISO  ( numerical_factorization) internal error_num= %d
*** Error in PARDISO  ( sequence_ido,parameters) error_num= %d
*** Error in PARDISO  ( sequence_ido,parameters) error_num= %lli
*** Error in PARDISO  ( sequence_ido,parameters) internal error_num= %d
*** Error in PARDISO  (32-bit overflow problem.) error_num= %d
*** Error in PARDISO  (32-bit overflow problem.) error_num= %lli
*** Error in PARDISO  (32-bit overflow problem.) internal error_num= %d
*** Error in PARDISO  (incorrect input matrix  ) error_num= %d
*** Error in PARDISO  (incorrect input matrix  ) error_num= %lli
*** Error in PARDISO  (incorrect input matrix  ) internal error_num= %d
*** Error in PARDISO  (prereordering_mtype11,13) error_num= %d
*** Error in PARDISO  (prereordering_mtype11,13) error_num= %lli
*** Error in PARDISO  (prereordering_mtype11,13) internal error_num= %d
*** Error in PARDISO  (read/write OOC data file) error_num= %d
*** Error in PARDISO  (read/write OOC data file) error_num= %lli
*** Error in PARDISO  (read/write OOC data file) internal error_num= %d
*** Error in PARDISO memory allocation: AFTER_REORDERING, allocation of %d bytes failed
*** Error in PARDISO memory allocation: AFTER_REORDERING, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: ALLOCATE_GLOBAL_STRUCTURE, allocation of %d bytes failed
*** Error in PARDISO memory allocation: ALLOCATE_GLOBAL_STRUCTURE, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: BASIC   , size to allocate: %d bytes
*** Error in PARDISO memory allocation: BEFORE_INIT_PARALLEL_DATA, allocation of %d bytes failed
*** Error in PARDISO memory allocation: BEFORE_INIT_PARALLEL_DATA, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: BEFORE_REORDERING, allocation of %d bytes failed
*** Error in PARDISO memory allocation: BEFORE_REORDERING, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: BEFORE_SYMBOLIC_FACTORIZATION, allocation of %d bytes failed
*** Error in PARDISO memory allocation: BEFORE_SYMBOLIC_FACTORIZATION, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: CGS_ARR , size to allocate: %d bytes
*** Error in PARDISO memory allocation: FACTORIZE_SOLVING_LU_DATA, allocation of %d bytes failed
*** Error in PARDISO memory allocation: FACTORIZE_SOLVING_LU_DATA, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: FACTORIZE_SOLVING_WORK_DATA, allocation of %d bytes failed
*** Error in PARDISO memory allocation: FACTORIZE_SOLVING_WORK_DATA, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: FACT_ADR, size to allocate: %d bytes
*** Error in PARDISO memory allocation: FACT_L&U, size to allocate: %d bytes
*** Error in PARDISO memory allocation: LOC_INT1, size to allocate: %d bytes
*** Error in PARDISO memory allocation: LOC_INT2, size to allocate: %d bytes
*** Error in PARDISO memory allocation: MATCHING_REORDERING_DATA, allocation of %d bytes failed
*** Error in PARDISO memory allocation: MATCHING_REORDERING_DATA, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: OOC_TREE_STRUCTURE, allocation of %d bytes failed
*** Error in PARDISO memory allocation: OOC_TREE_STRUCTURE, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: REALLOC_OOC_ARRAYS, allocation of %d bytes failed
*** Error in PARDISO memory allocation: REALLOC_OOC_ARRAYS, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: SOLVING_ITERREF_WORK_DATA, allocation of %d bytes failed
*** Error in PARDISO memory allocation: SOLVING_ITERREF_WORK_DATA, allocation of %lli bytes failed
*** Error in PARDISO memory allocation: STRUC_FI, size to allocate: %d bytes
*** Error in PARDISO memory allocation: STRUC_S0, size to allocate: %d bytes
*** Error in PARDISO memory allocation: STRUC_S1, size to allocate: %d bytes
*** Error in PARDISO memory allocation: STRUC_S2, size to allocate: %d bytes
*** Error in PARDISO memory allocation: UP_UPLEN, size to allocate: %d bytes
*** Error in PARDISO memory allocation: WORK_I0 , size to allocate: %d bytes
*** Error in PARDISO memory allocation: WORK_R0 , size to allocate: %d bytes
*** Error in PARDISO: cgs error iparam(20) %d
*** Error in PARDISO: cgs error iparam(20) %lli
*** Error in PARDISO: cgs error iparam[19] %d
*** Error in PARDISO: cgs error iparam[19] %lli
*** Error in PARDISO: clean impossible (ido?)
*** Error in PARDISO: ido<-1
*** Error in PARDISO: ido<1 and initialization
*** Error in PARDISO: internal error, insufficient memory factorization
*** Error in PARDISO: minimal memory required by OOC mode (%dMB) is less than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%dMB)
*** Error in PARDISO: minimal memory required by OOC mode (%lliMB) is greater than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%dMB)
*** Error in PARDISO: minimal memory required by OOC mode (%lliMB) is greater than variable MKL_PARDISO_OOC_MAX_CORE_SIZE (%lliMB)
*** Error in PARDISO: only symbolic factorization diagonal matrix case %d
*** Error in PARDISO: only symbolic factorization diagonal matrix case %lli
*** Error in PARDISO: preordering failed after %d neqns out of %d
*** Error in PARDISO: preordering failed after %lli neqns out of %lli
*** Error in PARDISO: unclassified error
*** Error in PARDISO: wrong matrix number, clean %d
*** Error in PARDISO: wrong matrix number, clean %lli
*** Error in PARDISO: zero or negative pivot, A is not SPD-matrix
*** Error in PARDISO: zero pivot
*** Input check: Sequential OOC mode of factorization is incompatible with sequential IC mode of reordering
*** Input check: Two-level factorization algorithm does not work in OOC mode.
*** Input check: empty input arrays ia and/or ja
*** Input check: i=%d, ia(i)=%d, ia(i+1)=%d are incompatible
*** Input check: i=%d, ia[i]=%d, ia[i+1]=%d are incompatible
*** Input check: i=%d, j=ia(i)=%d, ja(j)=%d are incompatible
*** Input check: i=%d, j=ia[i]=%d, ja[j]=%d are incompatible
*** Input check: i=%d, ja(i)=%d, neqns=%d are incompatible
*** Input check: i=%d, ja[i]=%d, neqns=%d are incompatible
*** Input check: i=%lli, ia(i)=%lli, ia(i+1)=%lli are incompatible
*** Input check: i=%lli, ia[i]=%lli, ia[i+1]=%lli are incompatible
*** Input check: i=%lli, j=ia(i)=%lli, ja(j)=%lli are incompatible
*** Input check: i=%lli, j=ia[i]=%lli, ja[j]=%lli are incompatible
*** Input check: i=%lli, ja(i)=%lli, neqns=%lli are incompatible
*** Input check: i=%lli, ja[i]=%lli, neqns=%lli are incompatible
*** Input check: ia(neqns+1)_new %d _old %d are incompatible
*** Input check: ia(neqns+1)_new %lli _old %lli are incompatible
*** Input check: ia[neqns]_new %d _old %d are incompatible
*** Input check: ia[neqns]_new %lli _old %lli are incompatible
*** Input check: ido_new %d (out of bounds)
*** Input check: ido_new %lli (out of bounds)
*** Input check: internal error, counted number of threads %d
*** Input check: internal error, counted number of threads %lli
*** Input check: iparam(6) %d (out of bounds)
*** Input check: iparam(6) %lli (out of bounds)
*** Input check: iparam[5] %d (out of bounds)
*** Input check: iparam[5] %lli (out of bounds)
*** Input check: j=%d, ja(j)=%d, ja(j+1)=%d are incompatible
*** Input check: j=%d, ja[j]=%d, ja[j+1]=%d are incompatible
*** Input check: j=%lli, ja(j)=%lli, ja(j+1)=%lli are incompatible
*** Input check: j=%lli, ja[j]=%lli, ja[j+1]=%lli are incompatible
*** Input check: matrix_number_new %d ido %d are incompatible
*** Input check: matrix_number_new %lli ido %lli are incompatible
*** Input check: matrix_type_new %d (out of bounds)
*** Input check: matrix_type_new %d _old %d are incompatible
*** Input check: matrix_type_new %lli (out of bounds)
*** Input check: matrix_type_new %lli _old %lli are incompatible
*** Input check: max_fac_store_in %d matrix_number_in %d
*** Input check: max_fac_store_in %lli matrix_number_in %lli
*** Input check: max_fac_store_new %d _old %d are incompatible
*** Input check: max_fac_store_new %lli _old %lli are incompatible
*** Input check: nb_new %d ido %d are incompatible
*** Input check: nb_new %lli ido %lli are incompatible
*** Input check: neqns %d or ia[neqns_in] %d are invalid
*** Input check: neqns %lli or ia[neqns_in] %lli are invalid
*** Input check: neqns_new %d 
*** Input check: neqns_new %d _old %d are incompatible
*** Input check: neqns_new %lli 
*** Input check: neqns_new %lli _old %lli are incompatible
*** Input check: nproc %d is not equal to counted number of threads %d
*** Input check: nproc %lli is not equal to counted number of threads %lli
*** Input check: preprocessing %d (out of bounds)
*** Input check: preprocessing %lli (out of bounds)
*** Input check: unexpected error with working arrays ia and/or ja
*** Input parameters: inconsistent error= %d max_fac_store_in: %d
*** Input parameters: inconsistent error= %lli max_fac_store_in: %lli
*** PARDISO PERFORMANCE WARNING: Insufficient memory to obtain solution with %d nrhs in single step.\n    RHS will be split in %d parts with %d columns maximum.\n    To optimize performance increase MKL_PARDISO_OOC_MAX_CORE_SIZE (now: %dMB, should be %dMB)
*** PARDISO PERFORMANCE WARNING: Insufficient memory to obtain solution with %lli nrhs in single step.\n    RHS will be split in %lli parts with %lli columns maximum.\n    To optimize performance increase MKL_PARDISO_OOC_MAX_CORE_SIZE (now: %lliMB, should be %lliMB)
*** PARDISO error: internal error
*** PARDISO error: unknown bit size of pint ***
*** error PARDISO: iterative refinement
*** error PARDISO: reordering, symbolic factorization
*** something wrong with diagonal matrix row %d
*** something wrong with diagonal matrix row %lli
*** wrong control step parameter ido %d
*** wrong control step parameter ido %lli
*0;I8
*6Z:G
*8;iJ
*9Gq0
*9HU*
*9IQ
*9ODp;l
*:eWC
*;APJ
*;IYQ
*;Pi8
*;qvI
*<4qt
*<a5h
*<dKR
*=b6F
*>IdP=s
*>jtb
*Es9
*Es<V
*Et9Z\v
*H=hSm
*IF;4
*JS9\fuq
*JZ:V
*K;5v
*N39
*R<0D
*S9U
*SN=F
*Ua=Wf
*Um<bn
*_9wPA:V
*b2:1
*h;]\v#:66?;0
*hE:o
*iu<K
*oD<0
*qD;d
*t%\v*d$\v*4#\v*
*t(\t*d'\t*4&\t*
*t)\v*d(\v*4'\v*
*t8s
*t9\v*d8\v*47\v*
*t=\v*d<\v*4;\v*
*tI\n*dH\n*4G\n*
*tM\n*dL\n*4K\n*
*tP\t*dO\t*4N\t*
*tQ\n*dP\n*4O\n*
*tY\n*dX\n*4W\n*
*t\r\v*d\f\v*4\v\v*
*t]\n*d\\n*4[\n*
*ta\n*d`\n*4_\n*
*th\v*dg\v*4f\v*
*ti\n*dh\n*4g\n*
*tm\n*dl\n*4k\n*
*tq\n*dp\n*4o\n*
*ty\n*dx\n*4w\n*
*t}\n*d|\n*4{\n*
*u;vS
*z8\fG
*z93~
+0;KY
+1\t:QG3
+4>gz
+4K;r
+5e9
+8;56
+8He
+8j<M
+9<90o
+9AE
+9S<O
+9q5D
+9sS
+9yc
+:fvA
+:tSU
+;6FQ=47
+;LoB
+;WsC7
+;sUN;y
+<rQY
+=iwK
+A;Jk
+C:oMt
+C>8e
+D;QX
+E9D
+Gq;a
+H:yP
+HG9
+J9H
+Ka=tCP
+L<I7
+LUUU
+M;qq
+NT9
+PT;S
+Q8w
+Sz9
+W9BHA9Y
+W;v6
+We9 =N
+Xc=+Xc=+Xc=+Xc=
+Xc=+Xc=+Xc=+Xc=+Xc=+Xc=+Xc=+Xc=
+a:Ue
+a=X5i
+b;8T
+c9f
+g0;TQj
+i9+P
+m:Ja
+o;xXq
+pR;m
+v$x+v$xv$+xv+$xv$+x+$vx+$vx$v+x+$vx$+vx+v $+v $v $+v +$v $++$ v+$ v$ v++$ v$+ v+xv$+ v$v$ +v+ $v$ ++x$v+ $v$v ++ $v$ +v
+vh:L=9
+wM;GI#
+xP9
, defaultBlockSize = 
, maxGrowSize = 
, slotMask = 
, use_single_mode = 
, vertices = 
,+6mz
,285
,4z=Fks
,8O t
,907
,97Z
,9br%<7
,9si
,;RlK
,;dut;tE
,;e0j
,;wEv
,<4WG
,<Lk6;S
,<ZjG
,<qgb
,<qo6
,<yLn
,=\feN>(s[>v
,=e,I=waK
,>3Q4
,>7ft
,A%;L){9(=1
,C9w
,C:oA
,D=J8
,Gl:B
,Io;mS
,N;wF
,Q9B
,Ra;-jf
,STRICT
,T8t
,T<OV
,W:9h
,XM9
,Y=v6L9
,[9844
,a;Uy
,d:hPG
,i;LbB
,i;l1C
,k92JX
,oQ:E
,rz9
,t9U
,zG:e
,zf;K
----------- Out of core Mb --------------
----------- Out of core time (in percent (%%)) --------------
-------------------------
------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-01;U
-1A=X
-3=2u
-49S
-5>Z4
-6;hVH
-8<aik
-91k
-96=8
-985
-9D8
-9O@i
-9X7
-9e8
-:DIM
-:c82
-;hVy
-;hmY
-;vps
-;wws
-<c5x
-<cvG
-<x9K
-?ZTW
-A;YR
-BN9
-BN9"X
-C;eY
-D WIN32 
-D;Pp
-H;H8
-HC<VX!
-J;Lk5;9
-K<gOo;k
-R9/o
-V3=F
-Vn<P
-W6<h
-W:7CW;
-Wh=S
-e6?7
-f:RC
-f<s42<
-h8o\vo
-rR9
-tG<zmZ<
-ti;x
.0Dy
.0Wy
.0ty
.2;Ue
.2Y<V
.3Bz
.3Mx
.6>BZ
.79z
.8:OBc:
.9;7Nz
.:I6c
.:KCb7
.:K{J9y
.;B0i9B
.;DLv
.;Tey
.<aIA
.<nrj
.<q9E
.<rtH
.=Izs
.>zRM
.?AU?$BVHNBuilderFastSpatialSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@avx@2@@avx@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$03UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@sse2@2@@sse2@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@sse2@2@@sse2@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$07UQuadMesh@embree@@U?$QuadMv@$03@2@UQuadSplitterFactory@avx@2@@avx@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree@@
.?AU?$BVHNBuilderFastSpatialSAH@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@UTriangleSplitterFactory@avx@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UQuadMesh@embree@@U?$QuadMi@$03@2@@sse2@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$03UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@sse2@embree@@
.?AU?$BVHNBuilderMBlurSAH@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$07UQuadMesh@embree@@U?$QuadMi@$03@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AU?$BVHNBuilderMBlurSAH@$07UTriangleMesh@embree@@U?$TriangleMvMB@$03@2@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03U?$QuadMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03U?$QuadMi@$03@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAH@$03U?$QuadMv@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03U?$QuadMv@$03@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAH@$03U?$TriangleM@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03U?$TriangleM@$03@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAH@$03U?$TriangleMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03U?$TriangleMi@$03@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAH@$03U?$TriangleMv@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03U?$TriangleMv@$03@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAH@$03UInstanceArrayPrimitive@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03UInstanceArrayPrimitive@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAH@$03UInstancePrimitive@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$03UInstancePrimitive@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAH@$07U?$QuadMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$07U?$QuadMv@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$07U?$TriangleM@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$07U?$TriangleMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$07U?$TriangleMv@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$07UInstanceArrayPrimitive@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAH@$07UInstancePrimitive@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAHQuantized@$03U?$QuadMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAHQuantized@$03U?$QuadMi@$03@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAHQuantized@$03U?$TriangleMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAHQuantized@$03U?$TriangleMi@$03@embree@@@sse2@embree@@
.?AU?$BVHNBuilderSAHQuantized@$07U?$QuadMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAHQuantized@$07U?$TriangleM@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderSAHQuantized@$07U?$TriangleMi@$03@embree@@@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$QuadMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleM@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03U?$TriangleMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstanceArrayPrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstanceArrayPrimitive@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstancePrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$03UInstancePrimitive@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$07U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$07UInstanceArrayPrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeaf@$07UInstancePrimitive@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$QuadMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafQuantized@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$QuadMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafQuantized@$07U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderQuantizedVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$QuadMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleM@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMi@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMi@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$03U?$TriangleMv@$03@embree@@@sse2@embree@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$07U?$QuadMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$07U?$TriangleM@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@U?$CreateLeafSpatial@$07U?$TriangleMv@$03@embree@@@avx@embree@@@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AU?$BVHNBuilderT@V<lambda_047818d7111865b148acce07eb0faa7d>@@@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AU?$BVHNBuilderT@V<lambda_9936c1e45856e773928c8ee0d014a38a>@@@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AU?$BVHNHairBuilderSAH@$03U?$CurveNi@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@avx@embree@@
.?AU?$BVHNHairBuilderSAH@$03U?$CurveNi@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@sse2@embree@@
.?AU?$BVHNHairBuilderSAH@$03U?$CurveNi@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree@@
.?AU?$BVHNHairBuilderSAH@$03U?$CurveNv@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@avx@embree@@
.?AU?$BVHNHairBuilderSAH@$03U?$CurveNv@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@sse2@embree@@
.?AU?$BVHNHairBuilderSAH@$07U?$CurveNv@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree@@
.?AU?$BVHNHairMBlurBuilderSAH@$03U?$CurveNiMB@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@avx@embree@@
.?AU?$BVHNHairMBlurBuilderSAH@$03U?$CurveNiMB@$03@embree@@U?$LineMi@$03@2@U?$PointMi@$03@2@@sse2@embree@@
.?AU?$BVHNHairMBlurBuilderSAH@$03U?$CurveNiMB@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree@@
.?AU?$BVHNHairMBlurBuilderSAH@$07U?$CurveNiMB@$07@embree@@U?$LineMi@$07@2@U?$PointMi@$07@2@@avx@embree@@
.?AU?$BVHNSubdivPatch1BuilderSAH@$03@avx@embree@@
.?AU?$BVHNSubdivPatch1BuilderSAH@$03@sse2@embree@@
.?AU?$BVHNSubdivPatch1MBlurBuilderSAH@$03@avx@embree@@
.?AU?$BVHNSubdivPatch1MBlurBuilderSAH@$03@sse2@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0024bcf8e81a2d3c58300fbfd9103d80>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0030f00a5e4b606d0e971bdec63ddb10>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_01e78add476ee64591d212d347611c34>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0213e868568a0590d5a6e7478aeffe59>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_026d2c143a4704203e26115b30033a7e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_02a4c2292fe29a65ea8c3fb3f26225e6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_02f3a38d2275fed79a8addf16cf8f528>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_033159cd3ebdc6ce506113048fcbdf6b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0371f14733f91309eab1e347a6ce43a2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_03c7424d9f028a9606915d0496c01f18>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_03cdbb8637085504ce2e3fcba2fdee88>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_042051442674d4548f3e7b91e4528948>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_044a18a42e7de31c10648de78d2671f6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_04837824f4f0bedd7a75ebaa90419e77>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_05114b3a8281feb229e8d9a03d7e7e47>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_05aafa8a196f7cbc547cf996a6ef4525>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_060d5712a58b0a8af87618627b3892da>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_07602f2a194208e4205be0291f13be53>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_07de0f251e965270305ec203c8b6e9d9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0814cdbadb8a5173c4cfeea2ae4f302b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_083e3bd4594ef7f00d2c94e74b29c74c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_08517f08d420646e992296e14801bb67>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0885a70d220feabdf9303e2939db32cd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_09088dddb6927132574b77b086f6b36a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_09407a3271040925f4fceb52e380d07b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_096ca84a1c60496f499fbf4b5eef8960>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_099499f898d1d7d80c0459cf68597da8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0a474d271fa60dff9f2a83b993ca6178>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0adf253de07a18f0c2e748d83564ab24>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0afe9913bbe2b4ee42844c2c3e840f2c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0b2be1a484962cd800262b330814f1de>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0b6c244aa5117ff6cb23fe95cf44c184>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0c0a5a6cbc8701b12fe2458b6d4e40e9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0cc63a2e8096dbcfa469e526f9ac67bc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0ce9ec1eea5672226870f0d95b0d8d55>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0d21f1cdb247fe597b86934275e0b708>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0daf2ca5388613cebccbb043ff03c16a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0e88312090160e82af251a4da72838a4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0eb0e2ebd58a530d55aabffd278b99ed>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0f559157fb5662d7891b63ad6e931f3b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0f6c92485fd120fd30ff2ea33fb74918>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0f740edcd945bd48bd033e5353c5ecc1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0fa3f2155c9458f67f16ebc9f312781a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_0feeb39ee693c756bfd486a7ffd0c92b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1035e5e5a21b569b1def157beb590cf4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_109b7626629525eafb4540a0946cba9f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_10d99383a1976f56b47124d2080fc88d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1112c1f2c76a1dbd2aeb49881d1607d6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_119fe46b6a3977013964303834047c0f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_11f24b3ee78b54f79f725c9ee9204620>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_124da7ba53a013040a48f6e9ed335801>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_12e745946c06d3d8b337883a9d7c5fc6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_133a08432e1aaa722e74ca66040875ff>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_13a972f04b06ecb0ebc4b9fc5c2d48a8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_13fcf6cc4585a6fe73bc5faaad9020f1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_14490ccb86cd39b0224b54da910caa1b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_14fac03f211fd6832936142e29a0777e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_15753f47449fe66b14ab8908ff161c25>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_15a461355c4c085ec0521d4d0b8174ce>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_15b8ec1b4d06d296b526a7c01f2647c2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_161792b59506b0e243b9421a11fb53c6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1623387536f7e828faf75a09fa0cc88b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_16507b9f5162c2d591c8f4dff7003a69>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_167578685c3c04eab5604af5daf83720>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_16e697cfb76eb1bd6b0790e9e3bc6adc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_16ec1e211f558c43769f7472f9e403d6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_17a90b2fed4fb5958544f01a080099c6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_18734b8af68c34370c50bc30a5c9c857>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1885fdba2acb15556d50774105afb275>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_193744cb1c915341b5bb6737caf797c0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_198bf666c2663bbb4a0feb13d55511d9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_19f30a0eb5df57dbedd0c84114bff5b4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1a3993dba263e5690ea9bf69b4ef7edc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1a944e10bba0f3e84997c380290491a8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1a947dc89c6b9ab9e3a4cfb6b6cc45c8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1ad45517c1e5c7227e24447239ff3349>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1b5e9ebed3caa5fa860097409e03bd26>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1bb728ab7b766b4e2c5e88cee13385c7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1bee079479d0dbb628b75b1da3c803ec>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1c5284e74fa23bb2d0b2b7ea36748084>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1cb05ca108c9c9112a5b03fcb46fb78d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1ddec102839920631de350f345b42060>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1f23186a3a8c1a7b6767112cd745c956>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1f86655c0a0e0f14ef564fa5eed6b449>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_1fd65ee1ddf25fb753f2e89b4fb5574b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2015edd9e7383ca08b9b8aa11ac680e3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_203f2cfea287abe84603fd650e7c1936>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2069df407464296b824ca33f4197ec8a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_217933724b3e1e5d7f053029c75bd240>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_21e16987f9d206f7fc5d860fed99bbc1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_21f2033cd4e1e1fcd41e0b00fc20cffa>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_220f611b778ea856d93bf0e211d27d71>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_22711db9e5ddf7a51cf447ed70ce779d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_229206f515929ad1ba9e168f0e6ee2df>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_229abbc98af76657ecc1cb6274373f95>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_22c68614e55cd8b62d6c0779500773c0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_23142700a9555ff72207d391d51ce6dd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_235c9eb9817cecea87f7512f1fecc41c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2448e154e60101894cd67305875e3b6b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_246348e99bf1cd7ed3d8ac88aa288179>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2472e4d841f7f03660d748c390f1c98f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2483c16ec48aa3c5c58efc47057a1853>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_24970f05f9b01e01366afabca885cd69>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_26017e49e8211245a572175b97c64817>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_26289c1d6266bcc542c4ca7f53a436f6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_26829afa5f772235d0977761886690b4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_26cee26626710417ae1cf4d059005ee8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_27623e1956a57b63dfdee190db4556f8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_28529c0ff0131ba92ad62cbff51a3cd2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_286bd1d6a0f07e8c63a90b26f807c0e6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_28c02f1c7eb8db37c8ae76ffb122fc29>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_29105f6038351f6621829cecd6cb8664>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_299af8be55152cdf9783cc0483c69833>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2a076dce94f4c4b6a6c58fd6d1f48e1b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2a3ad7c4e0ebc3501c1616cc9aa0cd06>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2a489e71024aec5fe813d46ad3a31570>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2a56ab4daa45c2f3005a672a7a15c149>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2a602e16c4f2059988628d1f11824a24>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2bac7050c3dc6359bac7976d366c71ce>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2c69a2c63e1e63973cc31a8cf626f9ee>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2c9fa0006e910f9b3daf238cb1fbec80>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2ce8273b9bbebbdda203a84ff150d13a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2d27d428d4171a9e0f280ef49b907ef2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2d3efedeb51b5c9276502289b48c792b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2d6b0be554fafb436403f0f923548fab>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2d7fcb48b69a84705b3e2d8dc569ff38>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2dde72380efe6bab1a8b149def276c51>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2df1f5b51de114e3bef21076ebb8f05d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2e4bc3d61274d2539571c3c0eb2de7ab>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2e8f55e295f14faa238ef7391caf1f4e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2f366eb6feec37ed90356f5fc15a6156>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_2fedd5b4bdf5a11138840b6ec1ce4843>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3005691052ba073da28d1a65dddd03e6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3010c61967799e829b97ab66b258f05d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3128dfe3161cba5a5ca732b6e955fc28>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_31abc9818e6657a5790caa0fe9e9bfdc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_31bca5a5764f6326df48e269af89a89c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_31e522b549c852d949774f5d54cf5913>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_321e0653b0901b39f81fbb82133a8756>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3263695fa4cc9a170b0a8054b3f999ae>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_33790d479592710aae7302a904ce5f79>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_33ca8656f54e2ad82c94a88dbf2be988>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3497d57cd08a9b7f78a3dd3f7d547803>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_359de6937990ac67c286ad8713812619>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_35a500d90860fd3871f353608489b26e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_35f265f65f08dc2cc4c40fb9bcdffd1e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_365a0bd2c068055f821754f68e443b9e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_36a116821d74362473183a7d40d7fa55>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_36bb0b59aec300714419584057f878ca>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_36c60084a6d73354f1cd48cc05a32560>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_36da6c31b7b60073023d94af080b51d8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_37224258c447acd5c6d247646c994b9a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_37386a6c02b7a67ed35c5567e5481328>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_378818ca25bfe2a2361aeb6b2999e355>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_378c1163259730c23a5a528d70de10a6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3796d84557900da352d32ddcd8b4dce0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_37acfaa8c6e6343835f9bda4ed3e364e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_37fdffb284dff321a481363426a427c0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_38044c841a7fa06e3d9de58a6ec98623>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_390784685fe47bde8503f81eb6d6a2ba>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_394868370a8daa23c01bd7f92b2f5740>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_39ababf5ed880c62e50b1a0db9f45af2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_39f94d2d8b7dd757a7400310f738f3be>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3a47ec42a72918bd5c8d386aa10beb98>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3a51fe6647c19bafa319c081bd1cb55c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3a5e5b6edffcb1ac25e777303d41d832>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3abfa7a00ddeca61cfbb7b7b3ef10605>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3af1a79f4b81807e541df4e58302761a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3c7b8943b47802e490352de9aed664e7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3cd047a95ffd41b9c532df9a463f6179>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3d018466e1411f557b6449e327ecfb97>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3d6f66a0bf56f20c25bb7fd7c432f5f2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3dd2614e74c2ad1e0fba3ecf269a3ef4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_3f2dd4aefc837e44368379a9b1d6c723>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_40d8d6c6e0cfde73f951339fb4102a1e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_41452cd6f43dbed322f93ff51b577859>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_41b6f16634da9272ddd1858235809b6b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_41d6c2671055d4dbddee3056329ce6b5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_431a79ffbb10332b2b5162509b8cb2b9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4356b8d5a707512399938863bfd9d382>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4381fc2d97d3969fee821fc71aa2a316>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4387768260f4b024b8e817fe8a6b8fee>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_444397cdb5c169fe1e4891cdc5d51774>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4454fd3ec8f5263414d2eb5c93d502ac>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_44be1663ccf7e78d7b1be1a89d14ca1b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_45239a73c6820cf96ab2702dbb009eba>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_45546463236c03f673f4b115b81e1608>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_45b3164beeb3810966b28faef1c81325>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_45d16dc16e8144f2a51eef2e95073c7f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4667454256e65fd53b20073f22204cb3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_46e5054ac5048a2a443acc0e1639f11a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4780a2a58680f986b6e37ff3e02a2982>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_48072216621c7087b2f04608c2342a4a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_49ab7ca2c9d85f3d01999a8e82f2836c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_49bc2397a1c426192cc7f20317a590bb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_49bf9a02359b64d4f0afa99c458891bb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_49cc0220240abb2aedf5fd506051b52b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4a5a410c0853f25642491011d68add24>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4b1382523c70c8ef1348da0d7711b4f9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4b7bc775bf679c669856f34596c88dac>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4bcd2bd801e7475eb68ae3895d5ea9a7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4c247ea948221e6acbe8efce8327e4cf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4c24e299999fc377afa4186737b9c42f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4ca5996dd98cebac7d8ee1236963ef35>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4cbf9b965a00f6253a395e7fd118fff3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4cdd26a2d3f1b3fe24a3211567d60170>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4d8404b02e5194f828c4424bdd4ff911>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4e2e92ed585301a5a43a1dada7fe9313>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4e351548b46f0d1fa6fdfe029b7cd294>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_4f37194615f9f1744f62b1f0022aa711>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5054633584ac972ffb22cd8d0d4203bb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5079c5c37fc9ad4848b845ed32f4e678>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_516293bb833f48f1e2cbe7aac54000ad>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_51dc10bddc1c5c3e8820e30c45c4abe4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_51dec9fdab6341900e2419ea45af0b34>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_526dd3239686290631445ec03d8d3021>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_535e5ca58567e12ea77a5368008fa98e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_53c30b1d8dcaea7ff298687d7da7b11a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_53fcac6429f03c4597e94071b0254a50>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_54a9ea568962a4fb29330904f65151be>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5524c1a9be4a940521d4c5bbb584ea38>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_562550e5d8cb2cf70f252647d9a5920f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_563152df29b86cdeb790347e7d1bac63>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_565a9b18701d850d39669fc656de7b65>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_577783d36a0c5bf05071cec41f550f78>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_57891ad27ccefb610dbf74b1364c461a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_58016dc23dd77668b5aa682bf036f8a8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_586f0a3885e5cfcf083c2c1c13c74519>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_58a5c0866a7b0b1091e77b8a910c6596>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_58e9c0ee7d1f13f82fe1306ebd3871eb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_58f8fe9599b923d0b4ee14168d2fa039>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_59e79ba20fbd512190e36c0067a5cb10>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5a0a5de012d970f12882092b4ffd1a39>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5a0d5be35d3e68045a558544c9546cd0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5b40b99f8f56676940f7b079692833cf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5bfd24340b8bfe4eff8106c8e46d3870>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5c5ec6423a9671276bbaac49f8e921a1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5cee3e073cbc9ae9b92a51f1290ab58c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5cf460ac937e1f0afe8a6ab198480de5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5d22228fe17b732922439fee1ce79dec>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5dddc2cc159a46e17398e0e8fcaafb34>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5de1cbb3b08f280eb83d6d11fcbd7368>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5de527b9879fc3f8cdb392d0199e1a88>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5e130f814614ecc84bcb89daea5764ae>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5edea0583b37da90ef70fa88e0541ffe>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5f337c2bc8562e18b4b4e4a07e7e74c1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_5f7483bf006a96d967bbf46091fb3fde>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_600a5f3da280e2146f70347cd4876dc8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_614af2630066497070eb0951f17946b3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6194bc74867d6dd16cd0e025d5beab31>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6199ffdf7c605c0962f8ee91aecfa222>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_61b537d16b2ce540d2f960e3629101da>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_621182ea2d11f76d1d1780deb835d4f0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_62d4297180986feffb3cfcc6c568bf01>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_633a1dbd0995496ba172f39a33227588>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_635089e5c135bb0785f0469e676d0d55>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_635bc4cf338d63581ffa71816e842d9b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_63d3d06a8b4bdf315b3dc4389d23f969>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_645ea0bf9267bc361051031346249148>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_64654bd0714d00476b8742f71a4d80e8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_64d7aacab79d78e1839598294f79875d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6508322f2548b185963781813571c4cd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_659b512ced93268a072be38668acc579>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_65a5a5236cccd5733608900f8c0f68cc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6682a6a5daf4aaa3bc5e43650ebc7a27>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_66997bf790596b4ebb6784b732723012>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_66aa4899cf2aeb19034592275aa55aaf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_66bf7bc1396202a758e3bdfca0f6cb16>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_66c890872cd6326baedd418eb5729e82>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_671231246a87fd7a13d2fcfbdddf27df>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_680480ce568449b4972d393da631f705>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_686005430ff528c2b108b70919850707>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_686bea96912e6b4b47a704c8b2dd519e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6870e76e71acc0f8b3eae5cac5789e9d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6901b1fc4e0cb81cb186943fa17a69c7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_691e0e78c708db8bfdb6800391fa9392>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6995898df38b358a5d10ff2c4c57e35c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_69c8a88f1a9a33e3c7ad5d8eefe444e1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_69edf7856f9b6802ee513b838e3bec62>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6acb9948264813306a762466a123315f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6b2dcd8b05c0800a63e166106b6ef9d6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6b37e2b27f8c5b3f9ca8d935d5ed57cd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6bb446e1068360230919261ce332d342>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6bc0b1ca028eaf3d7f5d41a49a4df4b4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6bd5dc4fab940007ef9cc8d7da12da96>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6c03367c8fad854e347513725e083444>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6e4133399869a06deff01f67e42fe122>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6e55edd3ffc08c55469454db08aa67b2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6edb511084291be638cfc9c67438c7fb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6edc17e9809f35847b5eaee0400da517>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6f35d9dfc0ba84dbf7d35fa74624f5c2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6f542470329bed6c4c66a36d06d14334>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6f597f0adb7bad19dc31d05e75508c56>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_6f6a1b007af587684cf180ac31743296>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_702761377da5c33ab10882ef0a9f9613>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_70cac3ca1e000a927b6180abdbe6e940>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_70d7221af433ebb85ffb36e5455edf5a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_70f0faf1caaa177deb944f52f1449154>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_71451476c37f97081611f5ea829f29f2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7154e1ebe472631ef1b05a9302dcfdcd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7200e1986d527611eb071d8ffabd23b7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7248274c3903408ff0817833dac35e88>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7273cce94103302f23587c6c0452c444>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7337cf1ea24ec60c4e6dcb0d22a3b6fb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_73441d37594cd410767342079a5a83ce>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_739a0d7b4c90947bbdb2c8bc20e9d572>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_73d30c51962feb4ef86c7347b074bdd4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_73dcb5f84263bc36f698d83c038d746c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_744bf7a2a480012d2fb14d16b4a28ec6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_746070a74440bd63945a38b44726c128>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_74f4229eee634cbe75e654589b334bbe>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7535c6db0d4f55ff53f7d2e193f65ab2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_75d63927bd8c93e5f39afa24ba394c7f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_75ddfd4864ee31b97d839677798dcc24>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_778e6c49a63b0698fccf8f4a3da3f26e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_78321a064c8b4eb1aec0511a72fd2793>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_788bf76417a85fb8fa45519060407e73>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_78dcbacac0ca25ca4e43dd11d31e4128>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_78e4b017df22f65d1b36e0496f9291d3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7afe4f071675355f5b1e830ef55e33d9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7b402df8b7d41bf08649d0e9f52354f3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7b6ebb61703070207d51ded066c0dadf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7b87ebee8bb3b6d1512c86b84fce8c6a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7bb2944cc757dcd2ef8f5c88f6e5b799>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7bdbdb19bf782076291c63745a719b0d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7beef361d11076ba7425f1840b9eedec>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7c0d825109794192d8d8263a752bbcae>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7c411916e1d0a6e87a685e4c1edbe31a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7caf708b7e23fd758ae9290652fa0ba6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7cef2cb558b52dcf4bd6c94a19ff8cce>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7d456c3788fe70edf1b2114c340c9b7e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7d92333caef7837b2bf4495ffb70380a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7dbcf3cf8c8438b960335b19117e3373>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7e8a3c0f497b0da0eddcab57fce05c56>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7e9cb177d7585e28d555112178425f3b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7efd00a1f76513d4c1d46dd35e9fd5a0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7f545fb40a06a06322d13d059804b31a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7f71ade2efa05174b994598a3f261500>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_7fc8ba9d7c551aef912924f6f12c2e7c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_803f6650a167b6f47a7b10cb8e7674fc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8062ca6b1deed1ad3e12492705f4f331>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_80c0d4336ef3fe0d7d9917d1da032763>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_80e263fdbdf421b894db1802513e2a09>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_80f1b0220db27cb2be01d2d3a6769b1b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_80f20d98566c55ad920451df7ca53b61>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8111aebf023d31fcac8250f0d2a12015>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_811fb9c34a8127f38a96d14cf6c03198>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_815ae63246bcbf4a1b5c0d6209c65560>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_81930aee378f640b1582e999dcab74fe>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_81b7904dd56cc10cecc495a62ff9c22e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_823fc14eabe432385eacefdc6cbd419d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8288334d84ccd5b79b33f9f297e4dac1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_82bc3d882b4f26dfac6792c8c167c55b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8374a87a5cca4de905a3f004470ac711>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_839d447d24cad75a6bcd81fb5b61c565>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_83a71fe449bc6f5002d85bd2738be885>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_83a76296660a4d55f3d1489bd0501f95>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_83cf4e5dda569c06e27f80c41529ff35>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_83f0edf1da5fd4de6a218aac5aadd0d6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_83fe557856fdb40a5e34f8835f41cd3b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_84bfb157e162affd3e4008b7f068b782>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_851c8b5768c9b150ef259bcdf13be37b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_853dbec48977496a0a1e6ac8909e5e31>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_855be20ea4ba174a443c5d5dc4ade2e2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_85695079964ef0e23c7287354d07a1d0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_85a9bc3b5bf6d176179a222ff19cba4f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_861b42b66bfbe2e796407a255aa8c3a0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8679ab18ac79668c8eed982489788fcc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_868ff1066f259cedf167ac42a4ecb3bd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_869e61bc3c0ecbf77c8b92b290922136>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_86ffb82e68280122c8ffe01f6f8008a9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8716c3f5a4d866d364991242b9233dba>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_87290051f4605df76699c4b474119dd2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_87303021dbbf095be0f28af5889d378b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_876a1f8e70794e01a1dec7021fa96099>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_876cfff3d255189ff87007d1dfc85e4b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_877121b9f3bad228247cf6e44eb44968>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8813cc6976f152ea08e9b049359a788c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8879d3a4c55d8218529c702f8b52ef23>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_88afaef865556decb587a9251a810ca4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_88e8ca69e9e5e86c96003685381e2d06>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_88fb7e44981b20c1f38b57c3bfc718d5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_890e406e033480635f5a75339cf483cd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8910feed0536114d7cf9db6a8d87c131>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_896d620115832d82de1e416eb8e53a72>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_89a3c6f1ab7ac7f23955e5a9ce674f97>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8a0746281ccff9faa58e37250200e224>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8a20f6c9d8cac76f6ba44ed5eaab493c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8ae6eb62fee5242249a948f1ebbaff2f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8b150a87f1113fcb12311b0d8b57510a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8b476c0f32c860ffd1638a90adb96b4b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8bf012444ce69c4ff8ae71c4abc7c196>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8c19f7aaeb30dc3978b87335ebe40834>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8c30a42f7e3938f634d4093dd4ef47b3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8c9dc09b3defb3bef77af1d41d6bb1b4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8d781b82c6d59a3eedd50ca90a198159>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8db1e9f51e7e4c95faffe328f0c0ed1c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8dd8be53b45b21dafb3314f58fe8b9d1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8de6d6541115e2c810c527b1ac9a16ec>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8df992af5ffb599088e1ae7caed40147>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8e28e317f08a8a0997af9e765e9e1a60>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8e6f4fb6ea6c801b6960a5746c69eefa>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8eddbf4ff55b0d91e19f7c65e24a64b3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8f28e23dc6f3c60943d9ab421aa9e473>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8f515e7dc3461352cf40a1ed1106d2d3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8f82710f6eb001ba6e5bf86b133d1e55>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_8fa9d00ed25facc0e28b218e3edd5992>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_902f0f121b4e009c34663596d7d556a5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9031c020359c8afa6b67c8047f99c45d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_90961f00b9dd5c2b7609ea09de0b5415>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_91d35e626329522d0b551d6f42329f4a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_91ea088e6a06225cdf64aa45d3b43187>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9239f2a5220c2cbfb17e6c494c181939>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_92640afd2fb1d7af683ac4bfa266b179>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_92ca463f302283856057910e34bc3acb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_93c2e4fb980e4a61fd4f5e03cb6b803c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9416fda5f68a232015cdebcb06be7981>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_941727d8d759c1212a51343214b6e742>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_946df7e4f3c60714904767dd569c8e50>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_94a62b72749b66823e9b5a9c4f05fbc1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_94b1137b67317c7f70b631af08e98d18>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_95570f1dc3ba862b524172560d6d333a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_955f2f5ef9fedb8bde9166d4450fc3d0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_95be1246cdb559379b9f866e93c0ff9e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9619ce5204db736bdfc6dce396fecfa6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_965d79945878ad2c8ad2ae117b6970bc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_965ed77bb303f4e87bdc259fb470abb7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9687822d38239fdf200ba388366db1e3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_969e7d53d79503e4109354f3251fe63f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_96d1f2ad41d2ed7e7fdc9089d00443e3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_97477056f9ecc004eff501b79e2669d0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_979d939e6212f7f46baf5608d7b86816>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9827d153b12a342a67a05cdb795851b3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_98ab25b2c01817f1651675856d465e58>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_99074ef999807c5a6d636d3a0512dd9a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_990bc7e98738cc35cca082ff38f4ef3b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_99d71ed3eb4b103d9491d8fa0a3d228c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9a01e634fa0a2227900db5052b12697d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9a112f5bf9f7bc11ef97af307f60464d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9a9ce54e3dbf12dbbed068a808ce4b8b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9cf575c2374d0d88f0ffda710a1a0f23>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9d3f74554c4b0cda880d2adf42bd7362>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9d6f132abf697cba2bfc6b0ff8ca24c0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9dc5c48dea1b3358dbd5bc98165f18e8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9e318d026b4e950dbacd0ac381b33ebd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9e56912550e5d9499ad157c2f1ce7ec3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9e5e454c1d23043f03e1e5abd47ff290>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9eb2af13d21fd6d2b3dc254f27ed56eb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9edf3f37c03ebb052600f734c1482456>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9f3310760927c5803e44e1492260c56e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9f70a1623b6a8bfbeae0f3e780c744d6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9f9dfca852c2c15eaf745b873505435f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_9f9e6ab7a83eb283874989fde14deead>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a0217c5f93caab01dc4294c8f63845a1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a170e58775316bbb54844832abb937bf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a1c1dd3e85eb20c8b83027ad291de2d7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a1c5009d4c36c9dadd5d0cbafe518f2f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a244a591b8cbcfc88ee2b071c96fe463>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a281f8220a198ca285d88fccfcf0c8d4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a28f43485fe1d7a28a02fcdc4f37f448>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a2e46bae1ade70cc0392e741606286d6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a38c856de3ce790f968c4b688bdbb9ba>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a45e010aaaa2c65e8e197900847e8de2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a4c8ade5fe04bc25c8529fee4fbf7531>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a4ca95a1b7349358e0d661b52ae3201e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a5369ce6cc74699da52b375c9fd1bea5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a58b75ef9f0f07de6fdb610db2f1c1c5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a5f5e92c0ac0201423327b326e38c7d7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a64f939f44ef7c73c6e9be1b61dbca8b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a792c2f7222c2ad1d8d1f2ee31b392c1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a8258d0b64a22c877befc8508f1f5c2a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a89a6402f83eadc104565dcc7c94c22a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a9053c29dbfb9b818b04a4ce1f365ec4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a9981998c4adee45e993ff40f84727e9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_a9dcbd0901dbe6a0526e3149916024fb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_aa4d7382fb00183a7b4b053586cb86a8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_aae78fcd381bd8f4ab21a33cedcbb12c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_aafaab80b06382548c9816e60217fb2a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ab01d573dba01507cbf76a4774774e8f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ab9c6b328185185470188d8627e6bc75>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_abdc40dacab9168755a153536b1a0df0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ac00258851e15327d14b55b2204b72a6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ac1fcb52fb269fee6f8e3b5eebae7104>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ac4abeae2d7be2e571ebcddf34adb4ef>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ac764b4ac022df116ad7798dcc46cb5d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_acc13046f42a183a1a6bb77c3462d857>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ad089268009b4c2ef9aeeab2404f870c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ad6fdd4f000ebf37143a0db2d8e3e1d1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ae508c7e8f6b0b34717c46973565ba0f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_aee57a9ec7f1864cfd19aa04abaa1763>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_af162eb4e3b7d8ba1ed3d60d884132ea>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_af1abd5eb9635d656b8c5f6048372f41>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_af35c386fc11d5ed82390cd7cbf57029>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_af8477c9fbb7a29b5eee142ffe0e89d9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_afe0cf013e809ac876b419d8874ee9db>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_affdfea5d21959006b44fd28cde0f3b4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b08c87a62f0e164a5736fd051e8df282>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b21fde0070eddd1cf447763bd268fd46>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b249b54b0056fbabda011f906b92d550>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b2575ee5400683423b9d807b02fc6585>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b28443ecafd57281e6be33badf3f47db>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b2e8c86ec91591da91a95207b442656f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b2f79a76641f894a0367a7459f3b5009>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b3c4ae6dbc014350e59fe903a04ceceb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b4485e36769ec1bb1ed67d4878bede6b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b44af5efbccddd75ba520a3f58a7284f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b4bfc57a369bb816757a83416da3c615>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b5c4771f6b90aff993be7b941e0abfda>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b616859263bcf3525618cd13ec4f64fd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b632145456bde4523c27e66167a66917>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b66dd42b9199e1ecb6e25bb68830e35f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b6ce85aaf5c3053977a5589987dec0f1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b7efb867a4b95aad1215cee37f5f2142>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b837374e4ba6a7ab2040ba2b3a734144>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b85b6d0f7df8509e2ad7026b7a5f6c88>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b88f573435203e70bf9e820a4e618d25>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b8d58bd793c19a67d8dca265a87fea90>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b916857f9f8ade0f1f4bcafc68a335c2>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_b995cbb9d022c465bf9b9edd30cca0a0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ba5acaffeb96ddaf2f2fa486e3ed6c50>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_bc45ae81a4dbae30960fccd210dba5d7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_bca8bb1ee08a261923a9a5c5407e534c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_bcd4a0a46b6f7b4201dd8b058388fc6d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_bf0c4ed8c022a08dcd12d0d6cbb86710>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_bf1cca3bc6d52c320fc05436dbfcdc65>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_bf424a489a6f557c136cadd331b0866b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_bf48d485bf02abcd5c601cbfca7bb2bf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c081681a52f86b07f9d0f192f63b899e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c083324be672c94e2890c2cb3c89331e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c0e8669fba56ef5f426f70cc77cfa061>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c0f8eeebedb703b426afc0b9ae9ff25c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c23911a372d39ae9a7062eb225e637b0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c2a68b60fac42d0d1bcdec19ffb00d9e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c3666ecae0d234b01feba663b499d263>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c38bda02cd657f62d0f4dc82c0ea7087>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c3b588eee0e82440118111bf549ab226>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c461869bb46105db74380596745643d7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c490c6ab2ac02721add773ebbeb99a5a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c579bbb53a4bad13c633f759c8ca8154>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c63808ed64f955a4063ede9ca8b8c6a0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c6493f5f359ed09541ecde014e185573>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c6c7f24a88c7cd3b12bfd8e21ed98a55>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c781000d1485cb2c960e7cfb563e36b7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c7d85ead6b60f33341cb01bbd933b0f8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c7e2c96d52e3ccaa7a15bddbcd459338>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c8556e4af94afc2ca1360a76bd2c78a5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c85d82a9c841eb595dddb2d2a00f4c5d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c958e5ac2e55dcd4f0073524c1ad5d89>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_c9f579788a18e27baeec9e1b9cb5b66b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ca0c7f7136424db903b645996de01b82>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ca612f9e3c54afa1f008fe58c5c66e47>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ca7c85bc616eafcb79501e98a6ef221f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ca842ad169340b0a4c2cc9c0d2906e92>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_cab5151eac1d1f1ebf96c129c72628e0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_cac0f0d6c8eb4863815c691d60c3d1ee>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_caf50a991bb498dfd7133d32e35eb360>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ccac3127f022a773a5074e9b5699a069>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_cd353a39892e67b26bca8ff71c6f55c5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ce3d6070b3486216c729ac165f168c16>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ce7b7ce43e7e4239949e276493a59a84>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ce93c2f06fd73d2b505d21df05dcc177>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ceef896624d62938180e0434ee72e1fb>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_cf04015a059de75b957d6b27aed72ff6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_cf7316951f548bf833b2f937b5171c80>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_cfc5d0496b00e235832687eb4324a570>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_cfdba0d8733391b4d2f4f5074a29f496>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d004d9bf5ad68546b90f794d5f915a18>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d15a90c44de0e52ed60cecb17e2931fd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d19831b225590e3b72feed772274e3fe>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d1f25f780760fcf68b60b9f52bd66ed5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d237763cd8703e7e4d3ab6ea4dec8a4e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d2a096ea3008a769f1d0a5d9fa9626a6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d2ab08f67f90557ea5a379379fd8f31a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d32214ab40f9bd376f0b8ccd41c0120c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d3a5d6e49e2a8fb062900790ddf2f456>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d3fd630bbb07b377c1311a814056ccf5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d53dbb7b00e3417f4c49193bf9e823e5>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d5a0b7a49d40fe88de6805f838040242>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d5b39d4b3629e2ca9f48ba6b116de02a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d5b93663d4fc1c8c235e1201babc2c99>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d6cbe29a10fb7e7ce5175a7aadae667f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d6e0874cd049b6a0c3d8c9f416e1ba82>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d6e4c2cdb47883faf381c60d0ba89e1e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d741e773bb4b5d34ae95c74e912a3f82>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d83cae0e9e449f82ade0590fa9651642>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d8555f8264ddc8c27c692522e7479bf6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d8cd0cc594f3b9a769e2b4a76f3d83a3>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d8d6eca292ff642ebd3701bbc6e721a9>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d8ea4ec5648c466c2dbc8a82ee558253>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d916cd841beb8339e6d2597cc1af6b1f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d95fb0a170d3f5b4df7a6f2bac21c866>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d99d96c98c7c4feb24d25ae17a8985cd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_d9c38379cc43d509550f59340b208533>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_dac94eccbb0379033bd4a8f7775d82f0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_db327d59d66e9b1beb44e69e6536ecbf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_db3faf5232c1c2b45b156560d2cac541>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_dcbabfaaff2d923fb9f2c3d1e19217d6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_dd4220754104e7575208b111b403f328>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_de1685b513ba6c31e4476d5737fd7d53>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_de3e5458c6eaa270b0bcdc4f15580d09>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_de75b1b44c17fdef9238049d120b83be>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e03e45e50e3862820dd3284a7b57be9a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e08894c8f999401c473c4ba01f59c4bf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e17805844c133e5b20fa14e53603e1d4>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e1f73f88667243e4dfa7145431e4a44b>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e214213d881d89d7adb52857c6d2aefd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e26e91dcb11f475af39ad56e91fbc607>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e2b2caf2f7858ed7858d76f8568ac4e7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e35f6062474ce6ca748236d731af0d41>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e3d9d041f0c9ac03b9e9b4c3ae3eee12>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e49a935b5f3f9e8a26e3e63193e59783>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e535c1f041f135e812ec5f1c9823fcca>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e6b63058b272e0472e88102d338a5131>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e7486cb21f645cd2b2445f3a90ec3bfc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e7500e7f1573afdd1fb08ef3f01bc7ca>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e812a25f8d5cad6e240b9c18c7575373>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e862096fc7a7438568f356fe7e413858>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_e896149c2946eddccc4ab9ef181e6692>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ea5b7edd9df89bd04b914340e5341fbd>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ea7c067843ae96f05229b0f2f22e8c2d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ea8c88b41df3346ebb090e86a08c71ad>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_eac8b2770af5340139d733fbb60f6f60>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_eaf482e3bdb031d54388a1e99418fa62>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_eb4094f6bcb50b2ef1848f3e7425698e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_eb6d56346b0cdacd5eebce566519d2a8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ebd4e378db90af50f6aba8f69e3e940c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ec10b2aec968e6524f478a8d08baa384>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ece1ea04a10ae492ebca08240941a8d8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ecfeba1e5f7dfd81ce429a7d4653fb65>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ed5e5038ae08979dfba0c9a9e0f51364>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ed63482bb9ca1543cf0b75373d0b6c05>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_edcffd2c15a35679915cad728bcfcd48>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f00224905c7c414e603a52589bb6bae6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f018a6b0f1abe094e8eb6668ba5fe5bc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f13dbb34a7f4c43a2cb3556cb1dd0fc1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f158009f4006d857c70245c816b7aa13>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f1a327ffba7e4d3100b6ce9fddc14c40>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f2207893870ffe8903bedfb216ccc08e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f2226345030ad60d78ca18c42d614451>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f2a457c5807d156b084c834ff2352f51>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f40bc526c99d8d8dee76e5fe54013d97>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f429706aa4ac2799776c103b918221cc>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f42b01f3d48d8587bb8faed06d1b579e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f486556a77674d99569bd35705d7acc0>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f4b84df0350e66df479f27e4f97f5b97>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f5122e1852d15845b738a95ad8ff8a2a>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f581254d4dffef07f79940652afc751c>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f58ffadb091f22e8aa802a4c2fa969a7>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f5c08a050b95ca0bfcad7d124c91f1f6>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f5dece463422488d30c2c89b3d2148ef>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f5ee90bb95be40c20b32fdcb68a22778>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f5fe3537bf016b3f5534fa7a6598c3bf>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f60c33299596573253845873a7bb8248>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f6e12d99244e1018d1be86c2e1506644>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f6fcf4f866d392b98993022e70fb4401>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f746d35ae7fcc2376134a266c1dc6e5e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f751a6ca7ae32f27644c6fc0986ca946>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f7b59d1f1a1d4fc4e4c2881d6658a7ca>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f7f718d365a535bb2a319a21b5941c1f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f8c993317ad74b90b6e741f961d76526>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f8f0e2119f9d40ba8ab7f69ddbe1f06e>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f9f1cc558235afe7edd56fde1290c9ca>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f9f4799b06ec2ea9b89e41484ce5ab29>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_f9f8cda5934eadbb148a99f98e678ad1>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fa093b9e35abac3b068a038cbca44e28>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fab2cf6f33b1d2be7e7d7b70a851c9ef>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fb0a3f474d47b7786c96863d67e73e11>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fb4fd7d45e628efb1fc1863228f6c06f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fb5138a54a25afc4d078cdeb479c7e7d>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fc607dc3de28109c4c3a1ac5e33b96b8>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fd5ca79ed74bac0af2a32b0efe206109>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fdd05f94bd7fc6c395db548c279d8cab>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fdee1d02b664fbe3665fa40ad8a9cf33>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fe67745a02a112e368e7ad898826f26f>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fe7d74574e9a622c8632ba794e2f2bef>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_fed48f89dd4ca93d5f116f87726dddba>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ff48972c831a564100a94d3cb3dc29ca>@@@TaskScheduler@embree@@
.?AU?$ClosureTaskFunction@V<lambda_ff65b411161532cbff105380da1514ee>@@@TaskScheduler@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx2@embree@@$$YBezierCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx2@embree@@UBSplineCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx2@embree@@UCatmullRomCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx@embree@@$$YBezierCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx@embree@@UBSplineCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@avx@embree@@UCatmullRomCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@sse2@embree@@$$YBezierCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@sse2@embree@@UBSplineCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$00UCurveGeometryInterface@sse2@embree@@UCatmullRomCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$00UHermiteCurveGeometryInterface@avx2@embree@@UHermiteCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$00UHermiteCurveGeometryInterface@avx@embree@@UHermiteCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$00UHermiteCurveGeometryInterface@sse2@embree@@UHermiteCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx2@embree@@$$YBezierCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx2@embree@@UBSplineCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx2@embree@@UCatmullRomCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx@embree@@$$YBezierCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx@embree@@UBSplineCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@avx@embree@@UCatmullRomCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@sse2@embree@@$$YBezierCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@sse2@embree@@UBSplineCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$01UCurveGeometryInterface@sse2@embree@@UCatmullRomCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$01UHermiteCurveGeometryInterface@avx2@embree@@UHermiteCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$01UHermiteCurveGeometryInterface@avx@embree@@UHermiteCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$01UHermiteCurveGeometryInterface@sse2@embree@@UHermiteCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx2@embree@@$$YBezierCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx2@embree@@UBSplineCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx2@embree@@UCatmullRomCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx@embree@@$$YBezierCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx@embree@@UBSplineCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@avx@embree@@UCatmullRomCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@sse2@embree@@$$YBezierCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@sse2@embree@@UBSplineCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$0A@UCurveGeometryInterface@sse2@embree@@UCatmullRomCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryISA@$0A@UHermiteCurveGeometryInterface@avx2@embree@@UHermiteCurveT@3@@avx2@embree@@
.?AU?$CurveGeometryISA@$0A@UHermiteCurveGeometryInterface@avx@embree@@UHermiteCurveT@3@@avx@embree@@
.?AU?$CurveGeometryISA@$0A@UHermiteCurveGeometryInterface@sse2@embree@@UHermiteCurveT@3@@sse2@embree@@
.?AU?$CurveGeometryInterface@$$YBezierCurveT@embree@@@avx2@embree@@
.?AU?$CurveGeometryInterface@$$YBezierCurveT@embree@@@avx@embree@@
.?AU?$CurveGeometryInterface@$$YBezierCurveT@embree@@@sse2@embree@@
.?AU?$CurveGeometryInterface@UBSplineCurveT@embree@@@avx2@embree@@
.?AU?$CurveGeometryInterface@UBSplineCurveT@embree@@@avx@embree@@
.?AU?$CurveGeometryInterface@UBSplineCurveT@embree@@@sse2@embree@@
.?AU?$CurveGeometryInterface@UCatmullRomCurveT@embree@@@avx2@embree@@
.?AU?$CurveGeometryInterface@UCatmullRomCurveT@embree@@@avx@embree@@
.?AU?$CurveGeometryInterface@UCatmullRomCurveT@embree@@@sse2@embree@@
.?AU?$HermiteCurveGeometryInterface@UHermiteCurveT@embree@@@avx2@embree@@
.?AU?$HermiteCurveGeometryInterface@UHermiteCurveT@embree@@@avx@embree@@
.?AU?$HermiteCurveGeometryInterface@UHermiteCurveT@embree@@@sse2@embree@@
.?AU?$ProgressMonitorClosure@V<lambda_d7487f8c9ea7cb96899891cb9a3ea4a8>@@@embree@@
.?AU?$ProgressMonitorClosure@V<lambda_f901d1c1d337b769ca822836207e498c>@@@embree@@
.?AU?$deleter@VIScene@ipl@@@ipl@@
.?AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@avx@embree@@
.?AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$03@sse2@embree@@
.?AUBVHNBuilderV@?$BVHNBuilderQuantizedVirtual@$07@avx@embree@@
.?AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@avx@embree@@
.?AUBVHNBuilderV@?$BVHNBuilderVirtual@$03@sse2@embree@@
.?AUBVHNBuilderV@?$BVHNBuilderVirtual@$07@avx@embree@@
.?AUBuildProgressMonitor@embree@@
.?AUBuildProgressMonitorInterface@Scene@embree@@
.?AUCalcBufferHolder@RadeonRays@@
.?AUCalcEventHolder@RadeonRays@@
.?AUCurveGeometry@embree@@
.?AUInstance@embree@@
.?AUInstanceArray@embree@@
.?AUInstanceArrayISA@avx2@embree@@
.?AUInstanceArrayISA@avx@embree@@
.?AUInstanceArrayISA@sse2@embree@@
.?AUInstanceISA@avx2@embree@@
.?AUInstanceISA@avx@embree@@
.?AUInstanceISA@sse2@embree@@
.?AULeafBoundsInterface@?$BVHNRefitter@$03@avx@embree@@
.?AULeafBoundsInterface@?$BVHNRefitter@$03@sse2@embree@@
.?AULeafBoundsInterface@?$BVHNRefitter@$07@avx@embree@@
.?AULineSegments@embree@@
.?AULineSegmentsISA@avx2@embree@@
.?AULineSegmentsISA@avx@embree@@
.?AULineSegmentsISA@sse2@embree@@
.?AUMemoryMonitorInterface@embree@@
.?AUPrimitiveType@embree@@
.?AUQuadMesh@embree@@
.?AUQuadMeshISA@avx2@embree@@
.?AUQuadMeshISA@avx@embree@@
.?AUQuadMeshISA@sse2@embree@@
.?AURegressionTest@embree@@
.?AUState@embree@@
.?AUSubdivMeshISA@avx@embree@@
.?AUSubdivMeshISA@sse2@embree@@
.?AUTaskFunction@TaskScheduler@embree@@
.?AUTaskScheduler@embree@@
.?AUTriangleMesh@embree@@
.?AUTriangleMeshISA@avx2@embree@@
.?AUTriangleMeshISA@avx@embree@@
.?AUTriangleMeshISA@sse2@embree@@
.?AUType@?$CurveNi@$03@embree@@
.?AUType@?$CurveNi@$07@embree@@
.?AUType@?$CurveNiMB@$03@embree@@
.?AUType@?$CurveNiMB@$07@embree@@
.?AUType@?$CurveNv@$03@embree@@
.?AUType@?$CurveNv@$07@embree@@
.?AUType@?$QuadMi@$03@embree@@
.?AUType@?$QuadMv@$03@embree@@
.?AUType@?$TriangleM@$03@embree@@
.?AUType@?$TriangleMi@$03@embree@@
.?AUType@?$TriangleMv@$03@embree@@
.?AUType@?$TriangleMvMB@$03@embree@@
.?AUType@InstanceArrayPrimitive@embree@@
.?AUType@InstancePrimitive@embree@@
.?AUType@Object@embree@@
.?AUType@SubGrid@embree@@
.?AUType@SubdivPatch1@embree@@
.?AUbarrier_sys_regression_test@embree@@
.?AUcache_regression_test@embree@@
.?AUcollision_regression_test@sse2@embree@@
.?AUfast_allocator_regression_test@embree@@
.?AUmessages_base@std@@
.?AUmoney_base@std@@
.?AUrtcore_error@embree@@
.?AUtime_base@std@@
.?AV<lambda_0a5eb190081202e0f28c290d3f31c81b>@@
.?AV<lambda_11109a99d7bbd452d4f1159b09c495b9>@@
.?AV<lambda_13a1aeb28e4e0bac28d36bed730a97d9>@@
.?AV<lambda_3e54074239d9181f190e21fe31b2ebd5>@@
.?AV<lambda_498b6f04f2beccab8c714618b3ad669c>@@
.?AV<lambda_4de24228018b536c3da2a1177966e9d3>@@
.?AV<lambda_62a9d32afc8d6b63df56e96e440ec261>@@
.?AV<lambda_816ac016707b2a67b11e96aff710a40f>@@
.?AV<lambda_845e6907f0dbd1951683b9def278af13>@@
.?AV<lambda_ab2e5214d93248d9c1a2f348abe6f0b1>@@
.?AV<lambda_cdbbba9119ddeae309deb8db07daea64>@@
.?AV<lambda_dff3c1b6999eee227e24249907461f6e>@@
.?AV<lambda_ee6a2105f198a1070623061950e8e630>@@
.?AV<lambda_f5a6bbee718852bc735793355e363d30>@@
.?AV?$BVHN@$03@embree@@
.?AV?$BVHN@$07@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree@@
.?AV?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AV?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AV?$BVHNCollider@$03@avx2@embree@@
.?AV?$BVHNCollider@$03@avx@embree@@
.?AV?$BVHNCollider@$03@sse2@embree@@
.?AV?$BVHNCollider@$07@avx@embree@@
.?AV?$BVHNColliderUserGeom@$03@avx2@embree@@
.?AV?$BVHNColliderUserGeom@$03@avx@embree@@
.?AV?$BVHNColliderUserGeom@$03@sse2@embree@@
.?AV?$BVHNColliderUserGeom@$07@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree@@
.?AV?$BVHNMeshBuilderMorton@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AV?$BVHNMeshBuilderMorton@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AV?$BVHNRefitT@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree@@
.?AV?$BVHNRefitT@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AV?$BVHNRefitT@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree@@
.?AV?$BVHNRefitT@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree@@
.?AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree@@
.?AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree@@
.?AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree@@
.?AV?$BVHNRefitT@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AV?$BVHNRefitT@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AV?$BVHNRefitT@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AV?$BVHNRefitT@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AV?$CLWBuffer@D@@
.?AV?$CLWBuffer@H@@
.?AV?$CLWBuffer@M@@
.?AV?$ReferenceCounter@PEAU_cl_command_queue@@$1?clRetainCommandQueue@@YAHPEAU1@@Z$1?clReleaseCommandQueue@@YAH0@Z@@
.?AV?$ReferenceCounter@PEAU_cl_context@@$1?clRetainContext@@YAHPEAU1@@Z$1?clReleaseContext@@YAH0@Z@@
.?AV?$ReferenceCounter@PEAU_cl_device_id@@$1?clRetainDevice@@YAHPEAU1@@Z$1?clReleaseDevice@@YAH0@Z@@
.?AV?$ReferenceCounter@PEAU_cl_event@@$1?clRetainEvent@@YAHPEAU1@@Z$1?clReleaseEvent@@YAH0@Z@@
.?AV?$ReferenceCounter@PEAU_cl_kernel@@$1?clRetainKernel@@YAHPEAU1@@Z$1?clReleaseKernel@@YAH0@Z@@
.?AV?$ReferenceCounter@PEAU_cl_mem@@$1?clRetainMemObject@@YAHPEAU1@@Z$1?clReleaseMemObject@@YAH0@Z@@
.?AV?$ReferenceCounter@PEAU_cl_platform_id@@$0A@$0A@@@
.?AV?$ReferenceCounter@PEAU_cl_program@@$1?clRetainProgram@@YAHPEAU1@@Z$1?clReleaseProgram@@YAH0@Z@@
.?AV?$Stream@H@embree@@
.?AV?$Stream@VToken@embree@@@embree@@
.?AV?$_Ebco_base@V?$allocator@UImpulseResponse2@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VBinauralEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VBufferedIndirectEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VCompressedEnergyFields@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VCompressedProbeBatch@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VContext@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VDirectEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VDirectSimulator@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VEmbreeDevice@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VEmbreeInstancedMesh@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VEmbreeStaticMesh@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VEnergyField@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VHRTFDatabase@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VHybridReverbEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VHybridReverbEstimator@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VImpulseResponse@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VIndirectEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VIndirectMixer@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VIndirectPartitioner@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VInstancedMesh@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VInterpolatableImpulseResponse@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VJobGraph@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VNonUniformProbeBatch@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VOpenCLDevice@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VOpenCLDeviceList@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VOverlapSaveFIR@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VOverlapSavePartitioner@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VPanningEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VPathEffect@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VPathSimulator@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VProbeArray@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VProbeBatch@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VProbeClusterMap@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VProbeNeighborhood@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VRadeonRaysDevice@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VReconstructor@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VReflectionSimulator@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VReverbEstimator@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VScene@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VSerializedObject@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VSimulationData@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VSimulationManager@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VStaticMesh@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VTANDevice@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VThreadPool@ipl@@@ipl@@$00@std@@
.?AV?$_Ebco_base@V?$allocator@VVirtualSurroundEffect@ipl@@@ipl@@$00@std@@
.?AV?$_ExceptionPtr_static@Vbad_alloc@std@@@?A0xad5a25bc@@
.?AV?$_ExceptionPtr_static@Vbad_exception@std@@@?A0xad5a25bc@@
.?AV?$_Func_base@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_base@XM@std@@
.?AV?$_Func_base@XPEAVBuffer@Calc@@@std@@
.?AV?$_Func_base@XPEAVDevice@Calc@@@std@@
.?AV?$_Func_base@XPEAVEvent@Calc@@@std@@
.?AV?$_Func_impl@V<lambda_498b6f04f2beccab8c714618b3ad669c>@@V?$allocator@H@std@@XPEAVBuffer@Calc@@@std@@
.?AV?$_Func_impl@V<lambda_62a9d32afc8d6b63df56e96e440ec261>@@V?$allocator@H@std@@XPEAVDevice@Calc@@@std@@
.?AV?$_Func_impl@V<lambda_dff3c1b6999eee227e24249907461f6e>@@V?$allocator@H@std@@XPEAVEvent@Calc@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_0a5eb190081202e0f28c290d3f31c81b>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_11109a99d7bbd452d4f1159b09c495b9>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_13a1aeb28e4e0bac28d36bed730a97d9>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_3e54074239d9181f190e21fe31b2ebd5>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_4de24228018b536c3da2a1177966e9d3>@@XM@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_816ac016707b2a67b11e96aff710a40f>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_845e6907f0dbd1951683b9def278af13>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_ab2e5214d93248d9c1a2f348abe6f0b1>@@XM@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_cdbbba9119ddeae309deb8db07daea64>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_ee6a2105f198a1070623061950e8e630>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Func_impl_no_alloc@V<lambda_f5a6bbee718852bc735793355e363d30>@@XHAEAU?$atomic@_N@std@@@std@@
.?AV?$_Mpunct@D@std@@
.?AV?$_Mpunct@G@std@@
.?AV?$_Mpunct@_W@std@@
.?AV?$_Ref_count_obj_alloc3@UImpulseResponse2@@V?$allocator@UImpulseResponse2@@@ipl@@@std@@
.?AV?$_Ref_count_obj_alloc3@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@V?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl@@@std@@
.?AV?$_Ref_count_obj_alloc3@VAmbisonicsBinauralEffect@ipl@@V?$allocator@VAmbisonicsBinauralEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VAmbisonicsDecodeEffect@ipl@@V?$allocator@VAmbisonicsDecodeEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VAmbisonicsEncodeEffect@ipl@@V?$allocator@VAmbisonicsEncodeEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VAmbisonicsPanningEffect@ipl@@V?$allocator@VAmbisonicsPanningEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VAmbisonicsRotateEffect@ipl@@V?$allocator@VAmbisonicsRotateEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VBinauralEffect@ipl@@V?$allocator@VBinauralEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VBufferedIndirectEffect@ipl@@V?$allocator@VBufferedIndirectEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VCompressedEnergyFields@ipl@@V?$allocator@VCompressedEnergyFields@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VCompressedProbeBatch@ipl@@V?$allocator@VCompressedProbeBatch@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VContext@ipl@@V?$allocator@VContext@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VDirectEffect@ipl@@V?$allocator@VDirectEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VDirectSimulator@ipl@@V?$allocator@VDirectSimulator@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VEmbreeDevice@ipl@@V?$allocator@VEmbreeDevice@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VEmbreeInstancedMesh@ipl@@V?$allocator@VEmbreeInstancedMesh@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VEmbreeStaticMesh@ipl@@V?$allocator@VEmbreeStaticMesh@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VEnergyField@ipl@@V?$allocator@VEnergyField@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VHRTFDatabase@ipl@@V?$allocator@VHRTFDatabase@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VHybridReverbEffect@ipl@@V?$allocator@VHybridReverbEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VHybridReverbEstimator@ipl@@V?$allocator@VHybridReverbEstimator@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VImpulseResponse@ipl@@V?$allocator@VImpulseResponse@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VIndirectEffect@ipl@@V?$allocator@VIndirectEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VIndirectMixer@ipl@@V?$allocator@VIndirectMixer@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VIndirectPartitioner@ipl@@V?$allocator@VIndirectPartitioner@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VInstancedMesh@ipl@@V?$allocator@VInstancedMesh@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VInterpolatableImpulseResponse@ipl@@V?$allocator@VInterpolatableImpulseResponse@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VJobGraph@ipl@@V?$allocator@VJobGraph@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VNonUniformProbeBatch@ipl@@V?$allocator@VNonUniformProbeBatch@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VOpenCLDevice@ipl@@V?$allocator@VOpenCLDevice@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VOpenCLDeviceList@ipl@@V?$allocator@VOpenCLDeviceList@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VOverlapSaveFIR@ipl@@V?$allocator@VOverlapSaveFIR@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VOverlapSavePartitioner@ipl@@V?$allocator@VOverlapSavePartitioner@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VPanningEffect@ipl@@V?$allocator@VPanningEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VPathEffect@ipl@@V?$allocator@VPathEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VPathSimulator@ipl@@V?$allocator@VPathSimulator@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VProbeArray@ipl@@V?$allocator@VProbeArray@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VProbeBatch@ipl@@V?$allocator@VProbeBatch@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VProbeClusterMap@ipl@@V?$allocator@VProbeClusterMap@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VProbeNeighborhood@ipl@@V?$allocator@VProbeNeighborhood@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VRadeonRaysDevice@ipl@@V?$allocator@VRadeonRaysDevice@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VRadeonRaysStaticMesh@ipl@@V?$allocator@VRadeonRaysStaticMesh@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VReconstructor@ipl@@V?$allocator@VReconstructor@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VReflectionSimulator@ipl@@V?$allocator@VReflectionSimulator@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VReverbEstimator@ipl@@V?$allocator@VReverbEstimator@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VScene@ipl@@V?$allocator@VScene@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VSerializedObject@ipl@@V?$allocator@VSerializedObject@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VSimulationData@ipl@@V?$allocator@VSimulationData@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VSimulationManager@ipl@@V?$allocator@VSimulationManager@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VStaticMesh@ipl@@V?$allocator@VStaticMesh@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VTANDevice@ipl@@V?$allocator@VTANDevice@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VThreadPool@ipl@@V?$allocator@VThreadPool@ipl@@@2@@std@@
.?AV?$_Ref_count_obj_alloc3@VVirtualSurroundEffect@ipl@@V?$allocator@VVirtualSurroundEffect@ipl@@@2@@std@@
.?AV?$_Ref_count_resource@PEAVIScene@ipl@@U?$deleter@VIScene@ipl@@@2@@std@@
.?AV?$allocator@UImpulseResponse2@@@ipl@@
.?AV?$allocator@V?$unordered_set@PEBVProbeBatch@ipl@@U?$hash@PEBVProbeBatch@ipl@@@std@@U?$equal_to@PEBVProbeBatch@ipl@@@4@V?$allocator@PEBVProbeBatch@ipl@@@2@@std@@@ipl@@
.?AV?$allocator@VAmbisonicsBinauralEffect@ipl@@@ipl@@
.?AV?$allocator@VAmbisonicsDecodeEffect@ipl@@@ipl@@
.?AV?$allocator@VAmbisonicsEncodeEffect@ipl@@@ipl@@
.?AV?$allocator@VAmbisonicsPanningEffect@ipl@@@ipl@@
.?AV?$allocator@VAmbisonicsRotateEffect@ipl@@@ipl@@
.?AV?$allocator@VBinauralEffect@ipl@@@ipl@@
.?AV?$allocator@VBufferedIndirectEffect@ipl@@@ipl@@
.?AV?$allocator@VCompressedEnergyFields@ipl@@@ipl@@
.?AV?$allocator@VCompressedProbeBatch@ipl@@@ipl@@
.?AV?$allocator@VContext@ipl@@@ipl@@
.?AV?$allocator@VDirectEffect@ipl@@@ipl@@
.?AV?$allocator@VDirectSimulator@ipl@@@ipl@@
.?AV?$allocator@VEmbreeDevice@ipl@@@ipl@@
.?AV?$allocator@VEmbreeInstancedMesh@ipl@@@ipl@@
.?AV?$allocator@VEmbreeStaticMesh@ipl@@@ipl@@
.?AV?$allocator@VEnergyField@ipl@@@ipl@@
.?AV?$allocator@VHRTFDatabase@ipl@@@ipl@@
.?AV?$allocator@VHybridReverbEffect@ipl@@@ipl@@
.?AV?$allocator@VHybridReverbEstimator@ipl@@@ipl@@
.?AV?$allocator@VImpulseResponse@ipl@@@ipl@@
.?AV?$allocator@VIndirectEffect@ipl@@@ipl@@
.?AV?$allocator@VIndirectMixer@ipl@@@ipl@@
.?AV?$allocator@VIndirectPartitioner@ipl@@@ipl@@
.?AV?$allocator@VInstancedMesh@ipl@@@ipl@@
.?AV?$allocator@VInterpolatableImpulseResponse@ipl@@@ipl@@
.?AV?$allocator@VJobGraph@ipl@@@ipl@@
.?AV?$allocator@VNonUniformProbeBatch@ipl@@@ipl@@
.?AV?$allocator@VOpenCLDevice@ipl@@@ipl@@
.?AV?$allocator@VOpenCLDeviceList@ipl@@@ipl@@
.?AV?$allocator@VOverlapSaveFIR@ipl@@@ipl@@
.?AV?$allocator@VOverlapSavePartitioner@ipl@@@ipl@@
.?AV?$allocator@VPanningEffect@ipl@@@ipl@@
.?AV?$allocator@VPathEffect@ipl@@@ipl@@
.?AV?$allocator@VPathSimulator@ipl@@@ipl@@
.?AV?$allocator@VProbeArray@ipl@@@ipl@@
.?AV?$allocator@VProbeBatch@ipl@@@ipl@@
.?AV?$allocator@VProbeClusterMap@ipl@@@ipl@@
.?AV?$allocator@VProbeNeighborhood@ipl@@@ipl@@
.?AV?$allocator@VRadeonRaysDevice@ipl@@@ipl@@
.?AV?$allocator@VRadeonRaysStaticMesh@ipl@@@ipl@@
.?AV?$allocator@VReconstructor@ipl@@@ipl@@
.?AV?$allocator@VReflectionSimulator@ipl@@@ipl@@
.?AV?$allocator@VReverbEstimator@ipl@@@ipl@@
.?AV?$allocator@VScene@ipl@@@ipl@@
.?AV?$allocator@VSerializedObject@ipl@@@ipl@@
.?AV?$allocator@VSimulationData@ipl@@@ipl@@
.?AV?$allocator@VSimulationManager@ipl@@@ipl@@
.?AV?$allocator@VStaticMesh@ipl@@@ipl@@
.?AV?$allocator@VTANDevice@ipl@@@ipl@@
.?AV?$allocator@VThreadPool@ipl@@@ipl@@
.?AV?$allocator@VVirtualSurroundEffect@ipl@@@ipl@@
.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@
.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@
.?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@
.?AV?$codecvt@DDU_Mbstatet@@@std@@
.?AV?$codecvt@GDU_Mbstatet@@@std@@
.?AV?$codecvt@_WDU_Mbstatet@@@std@@
.?AV?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std@@
.?AV?$collate@D@std@@
.?AV?$collate@G@std@@
.?AV?$collate@_W@std@@
.?AV?$ctype@G@std@@
.?AV?$ctype@_W@std@@
.?AV?$enable_shared_from_this@VIScene@ipl@@@std@@
.?AV?$messages@D@std@@
.?AV?$messages@G@std@@
.?AV?$messages@_W@std@@
.?AV?$money_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@
.?AV?$money_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@
.?AV?$money_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@
.?AV?$money_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@
.?AV?$money_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@
.?AV?$money_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@
.?AV?$moneypunct@D$00@std@@
.?AV?$moneypunct@D$0A@@std@@
.?AV?$moneypunct@G$00@std@@
.?AV?$moneypunct@G$0A@@std@@
.?AV?$moneypunct@_W$00@std@@
.?AV?$moneypunct@_W$0A@@std@@
.?AV?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@
.?AV?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@
.?AV?$num_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@
.?AV?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@
.?AV?$num_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@
.?AV?$numpunct@G@std@@
.?AV?$numpunct@_W@std@@
.?AV?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@
.?AV?$time_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@
.?AV?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@
.?AV?$time_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@
.?AV?$time_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@
.?AV?$time_put@_WV?$ostreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@
.?AV?$wstring_convert@V?$codecvt_utf8_utf16@_W$0BAPPPP@$0A@@std@@_WV?$allocator@_W@2@V?$allocator@D@2@@std@@
.?AVAccel@embree@@
.?AVAccelData@embree@@
.?AVAccelInstance@embree@@
.?AVAccelN@embree@@
.?AVAllocator@flatbuffers@@
.?AVBakedPathData@ipl@@
.?AVBakedReflectionsData@ipl@@
.?AVBatchedReflectionSimulator@ipl@@
.?AVBuffer@Calc@@
.?AVBuffer@RadeonRays@@
.?AVBuffer@embree@@
.?AVBufferClw@Calc@@
.?AVBuilder@embree@@
.?AVBvh2lStrategy@RadeonRays@@
.?AVBvh@RadeonRays@@
.?AVBvhStrategy@RadeonRays@@
.?AVCAmbisonicsBinauralEffect@api@@
.?AVCAmbisonicsDecodeEffect@api@@
.?AVCAmbisonicsEncodeEffect@api@@
.?AVCAmbisonicsPanningEffect@api@@
.?AVCAmbisonicsRotationEffect@api@@
.?AVCBinauralEffect@api@@
.?AVCCompressedProbeBatch@api@@
.?AVCContext@api@@
.?AVCDirectEffect@api@@
.?AVCEmbreeDevice@api@@
.?AVCEnergyField@api@@
.?AVCHRTF@api@@
.?AVCImpulseResponse@api@@
.?AVCInstancedMesh@api@@
.?AVCLWCommandQueue@@
.?AVCLWContext@@
.?AVCLWDevice@@
.?AVCLWEvent@@
.?AVCLWException@@
.?AVCLWKernel@@
.?AVCLWPlatform@@
.?AVCLWProgram@@
.?AVCNonUniformProbeBatch@api@@
.?AVCOpenCLDevice@api@@
.?AVCOpenCLDeviceList@api@@
.?AVCPanningEffect@api@@
.?AVCPathEffect@api@@
.?AVCProbeArray@api@@
.?AVCProbeBatch@api@@
.?AVCRadeonRaysDevice@api@@
.?AVCReconstructor@api@@
.?AVCReflectionEffect@api@@
.?AVCReflectionMixer@api@@
.?AVCScene@api@@
.?AVCSerializedObject@api@@
.?AVCSimulator@api@@
.?AVCSource@api@@
.?AVCStaticMesh@api@@
.?AVCTrueAudioNextDevice@api@@
.?AVCValidatedAmbisonicsBinauralEffect@api@@
.?AVCValidatedAmbisonicsDecodeEffect@api@@
.?AVCValidatedAmbisonicsEncodeEffect@api@@
.?AVCValidatedAmbisonicsPanningEffect@api@@
.?AVCValidatedAmbisonicsRotationEffect@api@@
.?AVCValidatedBinauralEffect@api@@
.?AVCValidatedContext@api@@
.?AVCValidatedDirectEffect@api@@
.?AVCValidatedEmbreeDevice@api@@
.?AVCValidatedEnergyField@api@@
.?AVCValidatedHRTF@api@@
.?AVCValidatedImpulseResponse@api@@
.?AVCValidatedInstancedMesh@api@@
.?AVCValidatedOpenCLDevice@api@@
.?AVCValidatedOpenCLDeviceList@api@@
.?AVCValidatedPanningEffect@api@@
.?AVCValidatedPathEffect@api@@
.?AVCValidatedProbeArray@api@@
.?AVCValidatedProbeBatch@api@@
.?AVCValidatedRadeonRaysDevice@api@@
.?AVCValidatedReconstructor@api@@
.?AVCValidatedReflectionEffect@api@@
.?AVCValidatedReflectionMixer@api@@
.?AVCValidatedScene@api@@
.?AVCValidatedSerializedObject@api@@
.?AVCValidatedSimulator@api@@
.?AVCValidatedSource@api@@
.?AVCValidatedStaticMesh@api@@
.?AVCValidatedTrueAudioNextDevice@api@@
.?AVCValidatedVirtualSurroundEffect@api@@
.?AVCVirtualSurroundEffect@api@@
.?AVCalc@0@
.?AVCalcClw@Calc@@
.?AVCalcIntersectionDevice@RadeonRays@@
.?AVCalcIntersectionDeviceCl@RadeonRays@@
.?AVCompressedBakedReflections@ipl@@
.?AVCompressedProbeBatch@ipl@@
.?AVCustomScene@ipl@@
.?AVDefaultAllocator@flatbuffers@@
.?AVDevice@Calc@@
.?AVDevice@embree@@
.?AVDeviceCl@Calc@@
.?AVDeviceClw@Calc@@
.?AVEmbreeInstancedMesh@ipl@@
.?AVEmbreeReflectionSimulator@ipl@@
.?AVEmbreeScene@ipl@@
.?AVEmbreeStaticMesh@ipl@@
.?AVEnergyField@ipl@@
.?AVEvent@Calc@@
.?AVEvent@RadeonRays@@
.?AVEventClw@Calc@@
.?AVException@Calc@@
.?AVException@RadeonRays@@
.?AVException@ipl@@
.?AVExceptionClw@Calc@@
.?AVExceptionImpl@RadeonRays@@
.?AVExecutable@Calc@@
.?AVExecutableClw@Calc@@
.?AVFatBvhStrategy@RadeonRays@@
.?AVFlatBuffersAllocator@ipl@@
.?AVFunction@Calc@@
.?AVFunctionClw@Calc@@
.?AVGeometry@embree@@
.?AVHRTFMap@ipl@@
.?AVHlbvh@RadeonRays@@
.?AVHlbvhStrategy@RadeonRays@@
.?AVIAmbisonicsBinauralEffect@api@@
.?AVIAmbisonicsDecodeEffect@api@@
.?AVIAmbisonicsEncodeEffect@api@@
.?AVIAmbisonicsPanningEffect@api@@
.?AVIAmbisonicsRotationEffect@api@@
.?AVIBakedData@ipl@@
.?AVIBakedReflectionsLookup@ipl@@
.?AVIBinauralEffect@api@@
.?AVIContext@api@@
.?AVIDirectEffect@api@@
.?AVIEmbreeDevice@api@@
.?AVIEnergyField@api@@
.?AVIHRTF@api@@
.?AVIHRTFMap@ipl@@
.?AVIImpulseResponse@api@@
.?AVIInstancedMesh@api@@
.?AVIInstancedMesh@ipl@@
.?AVIOpenCLDevice@api@@
.?AVIOpenCLDeviceList@api@@
.?AVIPanningEffect@api@@
.?AVIPathEffect@api@@
.?AVIProbeArray@api@@
.?AVIProbeBatch@api@@
.?AVIRadeonRaysDevice@api@@
.?AVIReconstructor@api@@
.?AVIReconstructor@ipl@@
.?AVIReflectionEffect@api@@
.?AVIReflectionMixer@api@@
.?AVIReflectionSimulator@ipl@@
.?AVIScene@api@@
.?AVIScene@ipl@@
.?AVISerializedObject@api@@
.?AVISimulator@api@@
.?AVISource@api@@
.?AVIStaticMesh@api@@
.?AVIStaticMesh@ipl@@
.?AVITrueAudioNextDevice@api@@
.?AVIVirtualSurroundEffect@api@@
.?AVImpulseResponse@ipl@@
.?AVInstance@RadeonRays@@
.?AVInstancedMesh@ipl@@
.?AVIntersectionApi@RadeonRays@@
.?AVIntersectionApiImpl@RadeonRays@@
.?AVIntersectionDevice@RadeonRays@@
.?AVMesh@RadeonRays@@
.?AVNonUniformProbeBatch@ipl@@
.?AVOpenCLEnergyField@ipl@@
.?AVOpenCLImpulseResponse@ipl@@
.?AVOpenCLReconstructor@ipl@@
.?AVPrimitives@Calc@@
.?AVPrimitivesClw@Calc@@
.?AVProbeBatch@ipl@@
.?AVRadeonRaysReflectionSimulator@ipl@@
.?AVRadeonRaysScene@ipl@@
.?AVRadeonRaysStaticMesh@ipl@@
.?AVReconstructor@ipl@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AVRefBuilderBase@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AVRefBuilderLarge@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstance@embree@@UInstancePrimitive@2@@sse2@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UInstanceArray@embree@@UInstanceArrayPrimitive@2@@sse2@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UQuadMesh@embree@@U?$QuadMv@$03@2@@sse2@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleM@$03@2@@sse2@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMi@$03@2@@sse2@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$03UTriangleMesh@embree@@U?$TriangleMv@$03@2@@sse2@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UInstance@embree@@UInstancePrimitive@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UInstanceArray@embree@@UInstanceArrayPrimitive@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UQuadMesh@embree@@U?$QuadMv@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleM@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMi@$03@2@@avx@embree@@
.?AVRefBuilderSmall@?$BVHNBuilderTwoLevel@$07UTriangleMesh@embree@@U?$TriangleMv@$03@2@@avx@embree@@
.?AVRefCount@embree@@
.?AVReflectionSimulator@ipl@@
.?AVSOFAHRTFMap@ipl@@
.?AVScene@embree@@
.?AVScene@ipl@@
.?AVShape@RadeonRays@@
.?AVShapeImpl@RadeonRays@@
.?AVSplitBvh@RadeonRays@@
.?AVStaticMesh@ipl@@
.?AVStrStream@embree@@
.?AVStrategy@RadeonRays@@
.?AVSubdivMesh@embree@@
.?AVTokenStream@embree@@
.?AVWorld@RadeonRays@@
.?AV_ExceptionPtr_normal@?A0xad5a25bc@@
.?AV_Iostream_error_category@std@@
.?AVbad_weak_ptr@std@@
.?AVcodecvt_base@std@@
.?AVrange_error@std@@
.?AVstl_condition_variable_interface@details@Concurrency@@
.?AVstl_condition_variable_vista@details@Concurrency@@
.?AVstl_condition_variable_win7@details@Concurrency@@
.?AVstl_critical_section_interface@details@Concurrency@@
.?AVstl_critical_section_vista@details@Concurrency@@
.?AVstl_critical_section_win7@details@Concurrency@@
.?G;M1s
.B0N2
.C3z
.C`N3
.C`N3A
.G6<3yp
.G9z
.If<l
.Jb<e
.K>yH
.M8r
.P$;5vc
.P9mC
.PKy
.PPy
.Pgy
.Pjy
.Ppy
.Pry
.Puy
.R0z
.S8z
.U17n
.V3z
.W9z
.Z2:Bm
.\N7CO:
.\f;c;(:WaT;f(
.a;WHj;
.c1z
.c8z
.didat$2
.didat$3
.didat$4
.didat$5
.didat$6
.didat$7
.g9z
.h9b
.hAz
.i#:xYJ
.jr:q
.lt;5
.m6z
.mtl
.nh<Spz
.pBz
.pLy
.pQy
.pVy
.pey
.phy
.psy
.pt;e
.pvy
.q6j_
.q7z
.r0z
.s8z
.v1z
.|8ks
/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n /************************************************************************* \n  INCLUDES \n  **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n /************************************************************************* \n   EXTENSIONS \n   **************************************************************************/ \n \n \n \n   /************************************************************************* \n    TYPE DEFINITIONS \n    **************************************************************************/ \n#define STARTIDX(x)     (((int)((x).left))) \n#define LEAFNODE(x)     (((x).left) == ((x).right)) \n#define STACK_SIZE 64 \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    int parent; \n    int left; \n    int right; \n    int next; \n} HlbvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global HlbvhNode const* nodes; \n    // Scene bounds \n    __global bbox const* bounds; \n    // Scene positional data \n    __global float3 const* vertices; \n    // Scene indices \n    __global Face const* faces; \n    // Shape IDs \n    __global ShapeData const* shapes; \n    // Extra data \n    __global int const* extra; \n} SceneData; \n \n/************************************************************************* \n HELPER FUNCTIONS \n **************************************************************************/ \n \n \n \n /************************************************************************* \n  BVH FUNCTIONS \n  **************************************************************************/ \n  //  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n            return true; \n        } \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n#define LDS_BUG \n \n#ifdef LDS_BUG \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n            righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    //return false; \n \n    const float3 invdir = native_recip(r->d.xyz); \n \n    //if (get_global_id(0) == 0) \n    //{ \n \n    //} \n \n    int stack[STACK_SIZE]; \n    int* ptr = stack; \n \n    *ptr++ = -1; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    bool hit = false; \n \n    int step = 0; \n    //if (get_global_id(0) == 1) \n        //printf("Starting %d\n", get_global_id(0) ); \n    while (idx > -1) \n    { \n        //printf("%d", get_global_id(0)); \n        step++; \n        //if (get_global_id(0) == 1) \n        //{ \n            //printf("Node %d %d\n", idx, step ); \n        //} \n \n        if (step > 10000) \n            return false; \n \n        node = scenedata->nodes[idx]; \n \n        if (LEAFNODE(node)) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n            { \n                hit = true; \n                break; \n            } \n        } \n        else \n        { \n            lbox = scenedata->bounds[node.left]; \n            rbox = scenedata->bounds[node.right]; \n \n            lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n            righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = node.right; \n                    deferred = node.left; \n                } \n                else \n                { \n                    idx = node.left; \n                    deferred = node.right; \n                } \n \n                *ptr++ = deferred; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = node.left; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = node.right; \n                continue; \n            } \n        } \n \n        idx = *--ptr; \n    } \n \n    //if (get_global_id(0) == 1) \n    //printf("Exiting %d\n", get_global_id(0) ); \n \n    return hit; \n} \n \n#else \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node), r, isect); \n            } \n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, isect->uvwt.w); \n                righthit = IntersectBoxF(r, invdir, rbox, isect->uvwt.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n \n    return isect->shapeid >= 0; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n \n    HlbvhNode node; \n    bbox lbox; \n    bbox rbox; \n \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node), r)) \n                    return true; \n            } \n            else \n            { \n                lbox = scenedata->bounds[node.left]; \n                rbox = scenedata->bounds[node.right]; \n \n                lefthit = IntersectBoxF(r, invdir, lbox, r->o.w); \n                righthit = IntersectBoxF(r, invdir, rbox, r->o.w); \n \n                if (lefthit > 0.f && righthit > 0.f) \n                { \n                    int deferred = -1; \n                    if (lefthit > righthit) \n                    { \n                        idx = node.right; \n                        deferred = node.left; \n                    } \n                    else \n                    { \n                        idx = node.left; \n                        deferred = node.right; \n                    } \n \n                    if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                    { \n                        for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                        { \n                            gsptr[i] = ldsstack[i * 64]; \n                        } \n \n                        gsptr += SHORT_STACK_SIZE; \n                        lsptr = ldsstack + 64; \n                    } \n \n                    *lsptr = deferred; \n                    lsptr += 64; \n \n                    continue; \n                } \n                else if (lefthit > 0) \n                { \n                    idx = node.left; \n                    continue; \n                } \n                else if (righthit > 0) \n                { \n                    idx = node.right; \n                    continue; \n                } \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef LDS_BUG \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global HlbvhNode const* nodes,   // BVH nodes \n    __global bbox const* bounds,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n#ifndef LDS_BUG \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n#endif \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        bounds, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef LDS_BUG \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable \n#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n \n \n// --------------------- HELPERS ------------------------ \n//#define INT_MAX 0x7FFFFFFF \n \n// -------------------- MACRO -------------------------- \n// Apple OCL compiler has this by default,  \n// so embrace with #ifdef in the future \n#define DEFINE_MAKE_4(type)\ \n    type##4 make_##type##4(type x, type y, type z, type w)\ \n{\ \n    type##4 res;\ \n    res.x = x;\ \n    res.y = y;\ \n    res.z = z;\ \n    res.w = w;\ \n    return res;\ \n} \n \n// Multitype macros to handle parallel primitives \n#define DEFINE_SAFE_LOAD_4(type)\ \n    type##4 safe_load_##type##4(__global type##4* source, uint idx, uint sizeInTypeUnits)\ \n{\ \n    type##4 res = make_##type##4(0, 0, 0, 0);\ \n    if (((idx + 1) << 2)  <= sizeInTypeUnits)\ \n    res = source[idx];\ \n    else\ \n    {\ \n    if ((idx << 2) < sizeInTypeUnits) res.x = source[idx].x;\ \n    if ((idx << 2) + 1 < sizeInTypeUnits) res.y = source[idx].y;\ \n    if ((idx << 2) + 2 < sizeInTypeUnits) res.z = source[idx].z;\ \n    }\ \n    return res;\ \n} \n \n#define DEFINE_SAFE_STORE_4(type)\ \n    void safe_store_##type##4(type##4 val, __global type##4* dest, uint idx, uint sizeInTypeUnits)\ \n{\ \n    if ((idx + 1) * 4  <= sizeInTypeUnits)\ \n    dest[idx] = val;\ \n    else\ \n    {\ \n    if (idx*4 < sizeInTypeUnits) dest[idx].x = val.x;\ \n    if (idx*4 + 1 < sizeInTypeUnits) dest[idx].y = val.y;\ \n    if (idx*4 + 2 < sizeInTypeUnits) dest[idx].z = val.z;\ \n    }\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE(type)\ \n    void group_scan_exclusive_##type(int localId, int groupSize, __local type* shmem)\ \n{\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\ \n    {\ \n    if (localId < groupSize/(2*stride))\ \n        {\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\ \n        }\ \n        barrier(CLK_LOCAL_MEM_FENCE);\ \n    }\ \n    if (localId == 0)\ \n    shmem[groupSize - 1] = 0;\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\ \n    {\ \n    if (localId < groupSize/(2*stride))\ \n        {\ \n        type temp = shmem[(2*localId + 1)*stride-1];\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\ \n        }\ \n        barrier(CLK_LOCAL_MEM_FENCE);\ \n    }\ \n} \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_SUM(type)\ \n    void group_scan_exclusive_sum_##type(int localId, int groupSize, __local type* shmem, type* sum)\ \n{\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\ \n    {\ \n    if (localId < groupSize/(2*stride))\ \n        {\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\ \n        }\ \n        barrier(CLK_LOCAL_MEM_FENCE);\ \n    }\ \n    *sum = shmem[groupSize - 1];\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    if (localId == 0){\ \n    shmem[groupSize - 1] = 0;}\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\ \n    {\ \n    if (localId < groupSize/(2*stride))\ \n        {\ \n        type temp = shmem[(2*localId + 1)*stride-1];\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\ \n        }\ \n        barrier(CLK_LOCAL_MEM_FENCE);\ \n    }\ \n} \n \n \n#define DEFINE_GROUP_SCAN_EXCLUSIVE_PART(type)\ \n    type group_scan_exclusive_part_##type( int localId, int groupSize, __local type* shmem)\ \n{\ \n    type sum = 0;\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\ \n    {\ \n    if (localId < groupSize/(2*stride))\ \n        {\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\ \n        }\ \n        barrier(CLK_LOCAL_MEM_FENCE);\ \n    }\ \n    if (localId == 0)\ \n    {\ \n    sum = shmem[groupSize - 1];\ \n    shmem[groupSize - 1] = 0;\ \n    }\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1)\ \n    {\ \n    if (localId < groupSize/(2*stride))\ \n        {\ \n        type temp = shmem[(2*localId + 1)*stride-1];\ \n        shmem[(2*localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1];\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + temp;\ \n        }\ \n        barrier(CLK_LOCAL_MEM_FENCE);\ \n    }\ \n    return sum;\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE(type)\ \n    __kernel void scan_exclusive_##type(__global type const* in_array, __global type* out_array, __local type* shmem)\ \n{\ \n    int globalId  = get_global_id(0);\ \n    int localId   = get_local_id(0);\ \n    int groupSize = get_local_size(0);\ \n    int groupId   = get_group_id(0);\ \n    shmem[localId] = in_array[2*globalId] + in_array[2*globalId + 1];\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\ \n    out_array[2 * globalId + 1] = shmem[localId] + in_array[2*globalId];\ \n    out_array[2 * globalId] = shmem[localId];\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4(type)\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\ \n    __kernel void scan_exclusive_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __local type* shmem)\ \n{\ \n    int globalId  = get_global_id(0);\ \n    int localId   = get_local_id(0);\ \n    int groupSize = get_local_size(0);\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\ \n    v2.w += v1.w;\ \n    shmem[localId] = v2.w;\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\ \n    v2.w = shmem[localId];\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_4_V1(type)\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\ \n    __kernel void scan_exclusive_##type##4##_v1(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __local type* shmem)\ \n{\ \n    int globalId  = get_global_id(0);\ \n    int localId   = get_local_id(0);\ \n    int groupSize = get_local_size(0);\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\ \n    shmem[localId] = v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w;\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    group_scan_exclusive_##type(localId, groupSize, shmem);\ \n    type offset = shmem[localId];\ \n    type t = v1.x; v1.x = offset; offset += t;\ \n    t = v1.y; v1.y = offset; offset += t;\ \n    t = v1.z; v1.z = offset; offset += t;\ \n    t = v1.w; v1.w = offset; offset += t;\ \n    t = v2.x; v2.x = offset; offset += t;\ \n    t = v2.y; v2.y = offset; offset += t;\ \n    t = v2.z; v2.z = offset; offset += t;\ \n    v2.w = offset;\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\ \n} \n \n#define DEFINE_SCAN_EXCLUSIVE_PART_4(type)\ \n    __attribute__((reqd_work_group_size(64, 1, 1)))\ \n    __kernel void scan_exclusive_part_##type##4(__global type##4 const* in_array, __global type##4* out_array, uint numElems, __global type* out_sums, __local type* shmem)\ \n{\ \n    int globalId  = get_global_id(0);\ \n    int localId   = get_local_id(0);\ \n    int groupId   = get_group_id(0);\ \n    int groupSize = get_local_size(0);\ \n    type##4 v1 = safe_load_##type##4(in_array, 2*globalId, numElems);\ \n    type##4 v2 = safe_load_##type##4(in_array, 2*globalId + 1, numElems);\ \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y;\ \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y;\ \n    v2.w += v1.w;\ \n    shmem[localId] = v2.w;\ \n    barrier(CLK_LOCAL_MEM_FENCE);\ \n    type sum = group_scan_exclusive_part_##type(localId, groupSize, shmem);\ \n    if (localId == 0) out_sums[groupId] = sum;\ \n    v2.w = shmem[localId];\ \n    type t = v1.w; v1.w = v2.w; v2.w += t;\ \n    t = v1.y; v1.y = v1.w; v1.w += t;\ \n    t = v2.y; v2.y = v2.w; v2.w += t;\ \n    t = v1.x; v1.x = v1.y; v1.y += t;\ \n    t = v2.x; v2.x = v2.y; v2.y += t;\ \n    t = v1.z; v1.z = v1.w; v1.w += t;\ \n    t = v2.z; v2.z = v2.w; v2.w += t;\ \n    safe_store_##type##4(v2, out_array, 2 * globalId + 1, numElems);\ \n    safe_store_##type##4(v1, out_array, 2 * globalId, numElems);\ \n} \n \n#define DEFINE_GROUP_REDUCE(type)\ \n    void group_reduce_##type(int localId, int groupSize, __local type* shmem)\ \n{\ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1)\ \n    {\ \n    if (localId < groupSize/(2*stride))\ \n        {\ \n        shmem[2*(localId + 1)*stride-1] = shmem[2*(localId + 1)*stride-1] + shmem[(2*localId + 1)*stride-1];\ \n        }\ \n        barrier(CLK_LOCAL_MEM_FENCE);\ \n    }\ \n} \n \n#define DEFINE_DISTRIBUTE_PART_SUM_4(type)\ \n    __kernel void distribute_part_sum_##type##4( __global type* in_sums, __global type##4* inout_array, uint numElems)\ \n{\ \n    int globalId  = get_global_id(0);\ \n    int groupId   = get_group_id(0);\ \n    type##4 v1 = safe_load_##type##4(inout_array, globalId, numElems);\ \n    type    sum = in_sums[groupId >> 1];\ \n    v1.xyzw += sum;\ \n    safe_store_##type##4(v1, inout_array, globalId, numElems);\ \n} \n \n \n// These are already defined in Apple OCL runtime \n#ifndef APPLE \nDEFINE_MAKE_4(int) \nDEFINE_MAKE_4(float) \n#endif \n \nDEFINE_SAFE_LOAD_4(int) \nDEFINE_SAFE_LOAD_4(float) \n \nDEFINE_SAFE_STORE_4(int) \nDEFINE_SAFE_STORE_4(float) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE(uint) \nDEFINE_GROUP_SCAN_EXCLUSIVE(float) \nDEFINE_GROUP_SCAN_EXCLUSIVE(short) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_SUM(uint) \n \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(int) \nDEFINE_GROUP_SCAN_EXCLUSIVE_PART(float) \n \nDEFINE_SCAN_EXCLUSIVE(int) \nDEFINE_SCAN_EXCLUSIVE(float) \n \nDEFINE_SCAN_EXCLUSIVE_4(int) \nDEFINE_SCAN_EXCLUSIVE_4(float) \n \nDEFINE_SCAN_EXCLUSIVE_PART_4(int) \nDEFINE_SCAN_EXCLUSIVE_PART_4(float) \n \nDEFINE_DISTRIBUTE_PART_SUM_4(int) \nDEFINE_DISTRIBUTE_PART_SUM_4(float) \n \n/// Specific function for radix-sort needs \n/// Group exclusive add multiscan on 4 arrays of shorts in parallel \n/// with 4x reduction in registers \nvoid group_scan_short_4way(int localId, int groupSize, \n    short4 mask0, \n    short4 mask1, \n    short4 mask2, \n    short4 mask3, \n    __local short* shmem0, \n    __local short* shmem1, \n    __local short* shmem2, \n    __local short* shmem3, \n    short4* offset0, \n    short4* offset1, \n    short4* offset2, \n    short4* offset3, \n    short4* histogram) \n{ \n    short4 v1 = mask0; \n    v1.y += v1.x; v1.w += v1.z; v1.w += v1.y; \n    shmem0[localId] = v1.w; \n \n    short4 v2 = mask1; \n    v2.y += v2.x; v2.w += v2.z; v2.w += v2.y; \n    shmem1[localId] = v2.w; \n \n    short4 v3 = mask2; \n    v3.y += v3.x; v3.w += v3.z; v3.w += v3.y; \n    shmem2[localId] = v3.w; \n \n    short4 v4 = mask3; \n    v4.y += v4.x; v4.w += v4.z; v4.w += v4.y; \n    shmem3[localId] = v4.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + shmem0[(2 * localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + shmem1[(2 * localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + shmem2[(2 * localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + shmem3[(2 * localId + 1)*stride - 1]; \n        } \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    short4 total; \n    total.s0 = shmem0[groupSize - 1]; \n    total.s1 = shmem1[groupSize - 1]; \n    total.s2 = shmem2[groupSize - 1]; \n    total.s3 = shmem3[groupSize - 1]; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    if (localId == 0) \n    { \n        shmem0[groupSize - 1] = 0; \n        shmem1[groupSize - 1] = 0; \n        shmem2[groupSize - 1] = 0; \n        shmem3[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem0[(2 * localId + 1)*stride - 1]; \n            shmem0[(2 * localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1]; \n            shmem0[2 * (localId + 1)*stride - 1] = shmem0[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem1[(2 * localId + 1)*stride - 1]; \n            shmem1[(2 * localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1]; \n            shmem1[2 * (localId + 1)*stride - 1] = shmem1[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem2[(2 * localId + 1)*stride - 1]; \n            shmem2[(2 * localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1]; \n            shmem2[2 * (localId + 1)*stride - 1] = shmem2[2 * (localId + 1)*stride - 1] + temp; \n \n            temp = shmem3[(2 * localId + 1)*stride - 1]; \n            shmem3[(2 * localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1]; \n            shmem3[2 * (localId + 1)*stride - 1] = shmem3[2 * (localId + 1)*stride - 1] + temp; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    v1.w = shmem0[localId]; \n \n    short t = v1.y; v1.y = v1.w; v1.w += t; \n    t = v1.x; v1.x = v1.y; v1.y += t; \n    t = v1.z; v1.z = v1.w; v1.w += t; \n    *offset0 = v1; \n \n    v2.w = shmem1[localId]; \n \n    t = v2.y; v2.y = v2.w; v2.w += t; \n    t = v2.x; v2.x = v2.y; v2.y += t; \n    t = v2.z; v2.z = v2.w; v2.w += t; \n    *offset1 = v2; \n \n    v3.w = shmem2[localId]; \n \n    t = v3.y; v3.y = v3.w; v3.w += t; \n    t = v3.x; v3.x = v3.y; v3.y += t; \n    t = v3.z; v3.z = v3.w; v3.w += t; \n    *offset2 = v3; \n \n    v4.w = shmem3[localId]; \n \n    t = v4.y; v4.y = v4.w; v4.w += t; \n    t = v4.x; v4.x = v4.y; v4.y += t; \n    t = v4.z; v4.z = v4.w; v4.w += t; \n    *offset3 = v4; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    *histogram = total; \n} \n \n// Calculate bool radix mask \nshort4 radix_mask(int offset, uchar digit, int4 val) \n{ \n    short4 res; \n    res.x = ((val.x >> offset) & 3) == digit ? 1 : 0; \n    res.y = ((val.y >> offset) & 3) == digit ? 1 : 0; \n    res.z = ((val.z >> offset) & 3) == digit ? 1 : 0; \n    res.w = ((val.w >> offset) & 3) == digit ? 1 : 0; \n    return res; \n} \n \n// Choose offset based on radix mask value  \nshort offset_4way(int val, int offset, short offset0, short offset1, short offset2, short offset3, short4 hist) \n{ \n    switch ((val >> offset) & 3) \n    { \n    case 0: \n        return offset0; \n    case 1: \n        return offset1 + hist.x; \n    case 2: \n        return offset2 + hist.x + hist.y; \n    case 3: \n        return offset3 + hist.x + hist.y + hist.z; \n    } \n \n    return 0; \n} \n \n \n \n// Perform group split using 2-bits pass \nvoid group_split_radix_2bits( \n    int localId, \n    int groupSize, \n    int offset, \n    int4 val, \n    __local short* shmem, \n    int4* localOffset, \n    short4* histogram) \n{ \n    /// Pointers to radix flag arrays \n    __local short* shmem0 = shmem; \n    __local short* shmem1 = shmem0 + groupSize; \n    __local short* shmem2 = shmem1 + groupSize; \n    __local short* shmem3 = shmem2 + groupSize; \n \n    /// Radix masks for each digit \n    short4 mask0 = radix_mask(offset, 0, val); \n    short4 mask1 = radix_mask(offset, 1, val); \n    short4 mask2 = radix_mask(offset, 2, val); \n    short4 mask3 = radix_mask(offset, 3, val); \n \n    /// Resulting offsets \n    short4 offset0; \n    short4 offset1; \n    short4 offset2; \n    short4 offset3; \n \n    group_scan_short_4way(localId, groupSize, \n        mask0, mask1, mask2, mask3, \n        shmem0, shmem1, shmem2, shmem3, \n        &offset0, &offset1, &offset2, &offset3, \n        histogram); \n \n    (*localOffset).x = offset_4way(val.x, offset, offset0.x, offset1.x, offset2.x, offset3.x, *histogram); \n    (*localOffset).y = offset_4way(val.y, offset, offset0.y, offset1.y, offset2.y, offset3.y, *histogram); \n    (*localOffset).z = offset_4way(val.z, offset, offset0.z, offset1.z, offset2.z, offset3.z, *histogram); \n    (*localOffset).w = offset_4way(val.w, offset, offset0.w, offset1.w, offset2.w, offset3.w, *histogram); \n} \n \nint4 safe_load_int4_intmax(__global int4* source, uint idx, uint sizeInInts) \n{ \n    int4 res = make_int4(INT_MAX, INT_MAX, INT_MAX, INT_MAX); \n    if (((idx + 1) << 2) <= sizeInInts) \n        res = source[idx]; \n    else \n    { \n        if ((idx << 2) < sizeInInts) res.x = source[idx].x; \n        if ((idx << 2) + 1 < sizeInInts) res.y = source[idx].y; \n        if ((idx << 2) + 2 < sizeInInts) res.z = source[idx].z; \n    } \n    return res; \n} \n \nvoid safe_store_int(int val, __global int* dest, uint idx, uint sizeInInts) \n{ \n    if (idx < sizeInInts) \n        dest[idx] = val; \n} \n \n// Split kernel launcher \n__kernel void split4way(int bitshift, __global int4* in_array, uint numElems, __global int* out_histograms, __global int4* out_array, \n    __global int* out_local_histograms, \n    __global int4* out_debug_offset, \n    __local short* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n    int numGroups = get_global_size(0) / groupSize; \n \n    /// Load single int4 value \n    int4 val = safe_load_int4_intmax(in_array, globalId, numElems); \n \n    int4 localOffset; \n    short4 localHistogram; \n    group_split_radix_2bits(localId, groupSize, bitshift, val, shmem, &localOffset, \n        &localHistogram); \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    __local int* sharedData = (__local int*)shmem; \n    __local int4* sharedData4 = (__local int4*)shmem; \n \n    sharedData[localOffset.x] = val.x; \n    sharedData[localOffset.y] = val.y; \n    sharedData[localOffset.z] = val.z; \n    sharedData[localOffset.w] = val.w; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    // Now store to memory \n    if (((globalId + 1) << 2) <= numElems) \n    { \n        out_array[globalId] = sharedData4[localId]; \n        out_debug_offset[globalId] = localOffset; \n    } \n    else \n    { \n        if ((globalId << 2) < numElems) out_array[globalId].x = sharedData4[localId].x; \n        if ((globalId << 2) + 1 < numElems) out_array[globalId].y = sharedData4[localId].y; \n        if ((globalId << 2) + 2 < numElems) out_array[globalId].z = sharedData4[localId].z; \n    } \n \n    if (localId == 0) \n    { \n        out_histograms[groupId] = localHistogram.x; \n        out_histograms[groupId + numGroups] = localHistogram.y; \n        out_histograms[groupId + 2 * numGroups] = localHistogram.z; \n        out_histograms[groupId + 3 * numGroups] = localHistogram.w; \n \n        out_local_histograms[groupId] = 0; \n        out_local_histograms[groupId + numGroups] = localHistogram.x; \n        out_local_histograms[groupId + 2 * numGroups] = localHistogram.x + localHistogram.y; \n        out_local_histograms[groupId + 3 * numGroups] = localHistogram.x + localHistogram.y + localHistogram.z; \n    } \n} \n \n#define GROUP_SIZE 64 \n#define NUMBER_OF_BLOCKS_PER_GROUP 8 \n#define NUM_BINS 16 \n \n// The kernel computes 16 bins histogram of the 256 input elements. \n// The bin is determined by (in_array[tid] >> bitshift) & 0xF \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid BitHistogram( \n    // Number of bits to shift \n    int bitshift, \n    // Input array \n    __global int const* restrict in_array, \n    // Number of elements in input array \n    uint numelems, \n    // Output histograms in column layout \n    // [bin0_group0, bin0_group1, ... bin0_groupN, bin1_group0, bin1_group1, ... bin1_groupN, ...] \n    __global int* restrict out_histogram \n    ) \n{ \n    // Histogram storage \n    __local int histogram[NUM_BINS * GROUP_SIZE]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    /// Clear local histogram \n    for (int i = 0; i < NUM_BINS; ++i) \n    { \n        histogram[i*GROUP_SIZE + localid] = 0; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    const int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    const int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        /// Load single int4 value \n        int4 value = safe_load_int4_intmax(in_array, loadidx, numelems); \n \n        /// Handle value adding histogram bins \n        /// for all 4 elements \n        int4 bin = ((value >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.x*GROUP_SIZE + localid]); \n        //bin = ((value.y >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.y*GROUP_SIZE + localid]); \n        //bin = ((value.z >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.z*GROUP_SIZE + localid]); \n        //bin = ((value.w >> bitshift) & 0xF); \n        //++histogram[localid*kNumBins + bin]; \n        atom_inc(&histogram[bin.w*GROUP_SIZE + localid]); \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int sum = 0; \n    if (localid < NUM_BINS) \n    { \n        for (int i = 0; i < GROUP_SIZE; ++i) \n        { \n            sum += histogram[localid * GROUP_SIZE + i]; \n        } \n \n        out_histogram[numgroups*localid + groupid] = sum; \n    } \n} \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid ScatterKeys(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localvals = safe_load_int4_intmax(in_keys, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localvals >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LDS \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals.x = keys[localid << 2]; \n            localvals.y = keys[(localid << 2) + 1]; \n            localvals.z = keys[(localid << 2) + 2]; \n            localvals.w = keys[(localid << 2) + 3]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n        int4 bin = (localvals >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        if (localid < NUM_BINS) \n        { \n            scanned_histogram[localid] += sum; \n        } \n    } \n} \n \n \n \n__kernel \n__attribute__((reqd_work_group_size(GROUP_SIZE, 1, 1))) \nvoid ScatterKeysAndValues(// Number of bits to shift \n    int bitshift, \n    // Input keys \n    __global int4 const* restrict in_keys, \n    // Input values \n    __global int4 const* restrict in_values, \n    // Number of input keys \n    uint           numelems, \n    // Scanned histograms \n    __global int const* restrict  in_histograms, \n    // Output keys \n    __global int* restrict  out_keys, \n    // Output values \n    __global int* restrict  out_values \n    ) \n{ \n    // Local memory for offsets counting \n    __local int  keys[GROUP_SIZE * 4]; \n    __local int  scanned_histogram[NUM_BINS]; \n \n    int globalid = get_global_id(0); \n    int localid = get_local_id(0); \n    int groupsize = get_local_size(0); \n    int groupid = get_group_id(0); \n    int numgroups = get_global_size(0) / groupsize; \n \n    __local uint* histogram = (__local uint*)keys; \n \n    int numblocks_per_group = NUMBER_OF_BLOCKS_PER_GROUP; \n    int numelems_per_group = numblocks_per_group * GROUP_SIZE; \n    int numblocks_total = (numelems + GROUP_SIZE * 4 - 1) / (GROUP_SIZE * 4); \n    int maxblocks = numblocks_total - groupid * numblocks_per_group; \n \n    // Copy scanned histogram for the group to local memory for fast indexing \n    if (localid < NUM_BINS) \n    { \n        scanned_histogram[localid] = in_histograms[groupid + localid * numgroups]; \n    } \n \n    // Make sure everything is up to date \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    int loadidx = groupid * numelems_per_group + localid; \n    for (int block = 0; block < min(numblocks_per_group, maxblocks); ++block, loadidx += GROUP_SIZE) \n    { \n        // Load single int4 value \n        int4 localkeys = safe_load_int4_intmax(in_keys, loadidx, numelems); \n        int4 localvals = safe_load_int4_intmax(in_values, loadidx, numelems); \n \n        // Clear the histogram \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Do 2 bits per pass \n        for (int bit = 0; bit <= 2; bit += 2) \n        { \n            // Count histogram \n            int4 b = ((localkeys >> bitshift) >> bit) & 0x3; \n \n            int4 p; \n            p.x = 1 << (8 * b.x); \n            p.y = 1 << (8 * b.y); \n            p.z = 1 << (8 * b.z); \n            p.w = 1 << (8 * b.w); \n \n            // Pack the histogram \n            uint packed_key = (uint)(p.x + p.y + p.z + p.w); \n \n            // Put into LDS \n            histogram[localid] = packed_key; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan the histogram in LDS with 4-way plus scan \n            uint total = 0; \n            group_scan_exclusive_sum_uint(localid, GROUP_SIZE, histogram, &total); \n \n            // Load value back \n            packed_key = histogram[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Scan total histogram (4 chars) \n            total = (total << 8) + (total << 16) + (total << 24); \n            uint offset = total + packed_key; \n \n            int4 newoffset; \n \n            int t = p.y + p.x; \n            p.w = p.z + t; \n            p.z = t; \n            p.y = p.x; \n            p.x = 0; \n \n            p += (int)offset; \n            newoffset = (p >> (b * 8)) & 0xFF; \n \n            keys[newoffset.x] = localkeys.x; \n            keys[newoffset.y] = localkeys.y; \n            keys[newoffset.z] = localkeys.z; \n            keys[newoffset.w] = localkeys.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localkeys = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            keys[newoffset.x] = localvals.x; \n            keys[newoffset.y] = localvals.y; \n            keys[newoffset.z] = localvals.z; \n            keys[newoffset.w] = localvals.w; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n \n            // Reload values back to registers for the second bit pass \n            localvals = ((__local int4*)keys)[localid]; \n \n            // Make sure everything is up to date \n            barrier(CLK_LOCAL_MEM_FENCE); \n        } \n \n        // Clear LDS \n        histogram[localid] = 0; \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Reconstruct 16 bins histogram \n        int4 bin = (localkeys >> bitshift) & 0xF; \n        atom_inc(&histogram[bin.x]); \n        atom_inc(&histogram[bin.y]); \n        atom_inc(&histogram[bin.z]); \n        atom_inc(&histogram[bin.w]); \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        int sum = 0; \n        if (localid < NUM_BINS) \n        { \n            sum = histogram[localid]; \n        } \n \n        // Make sure everything is up to date \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        // Scan reconstructed histogram \n        group_scan_exclusive_uint(localid, 16, histogram); \n \n        // Put data back to global memory \n        int offset = scanned_histogram[bin.x] + (localid << 2) - histogram[bin.x]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.x; \n            out_values[offset] = localvals.x; \n        } \n \n        offset = scanned_histogram[bin.y] + (localid << 2) + 1 - histogram[bin.y]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.y; \n            out_values[offset] = localvals.y; \n        } \n \n        offset = scanned_histogram[bin.z] + (localid << 2) + 2 - histogram[bin.z]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.z; \n            out_values[offset] = localvals.z; \n        } \n \n        offset = scanned_histogram[bin.w] + (localid << 2) + 3 - histogram[bin.w]; \n        if (offset < numelems) \n        { \n            out_keys[offset] = localkeys.w; \n            out_values[offset] = localvals.w; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n \n        scanned_histogram[localid] += sum; \n    } \n} \n \n \n__kernel void compact_int(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_group_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n} \n \n__kernel void compact_int_1(__global int* in_predicate, __global int* in_address, \n    __global int* in_input, uint in_size, \n    __global int* out_output, \n    __global int* out_size) \n{ \n    int global_id = get_global_id(0); \n    int group_id = get_group_id(0); \n \n    if (global_id < in_size) \n    { \n        if (in_predicate[global_id]) \n        { \n            out_output[in_address[global_id]] = in_input[global_id]; \n        } \n    } \n \n    if (global_id == 0) \n    { \n        *out_size = in_address[in_size - 1] + in_predicate[in_size - 1]; \n    } \n} \n \n__kernel void copy(__global int4* in_input, \n    uint  in_size, \n    __global int4* out_output) \n{ \n    int global_id = get_global_id(0); \n    int4 value = safe_load_int4(in_input, global_id, in_size); \n    safe_store_int4(value, out_output, global_id, in_size); \n} \n \n \n#define FLAG(x) (flags[(x)] & 0x1) \n#define FLAG_COMBINED(x) (flags[(x)]) \n#define FLAG_ORIG(x) ((flags[(x)] >> 1) & 0x1) \n \nvoid group_segmented_scan_exclusive_int( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut( \n    int localId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n        shmem[groupSize - 1] = 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \nvoid group_segmented_scan_exclusive_int_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            // optimize with a conditional = operator \n            if (FLAG_ORIG((2 * localId + 1)*stride) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = 0; \n            } \n            else if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \nvoid group_segmented_scan_exclusive_int_nocut_part( \n    int localId, \n    int groupId, \n    int groupSize, \n    __local int* shmem, \n    __local char* flags, \n    __global int* part_sums, \n    __global int* part_flags \n    ) \n{ \n    for (int stride = 1; stride <= (groupSize >> 1); stride <<= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            if (FLAG(2 * (localId + 1)*stride - 1) == 0) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + shmem[(2 * localId + 1)*stride - 1]; \n            } \n \n            FLAG_COMBINED(2 * (localId + 1)*stride - 1) = FLAG_COMBINED(2 * (localId + 1)*stride - 1) | FLAG((2 * localId + 1)*stride - 1); \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n \n    if (localId == 0) \n    { \n        part_sums[groupId] = shmem[groupSize - 1]; \n        part_flags[groupId] = FLAG(groupSize - 1); \n        shmem[groupSize - 1] = 0; \n    } \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    for (int stride = (groupSize >> 1); stride > 0; stride >>= 1) \n    { \n        if (localId < groupSize / (2 * stride)) \n        { \n            int temp = shmem[(2 * localId + 1)*stride - 1]; \n            shmem[(2 * localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1]; \n \n            if (FLAG((2 * localId + 1)*stride - 1) == 1) \n            { \n                shmem[2 * (localId + 1)*stride - 1] = temp; \n            } \n            else \n            { \n                shmem[2 * (localId + 1)*stride - 1] = shmem[2 * (localId + 1)*stride - 1] + temp; \n            } \n \n            FLAG_COMBINED((2 * localId + 1)*stride - 1) = FLAG_COMBINED((2 * localId + 1)*stride - 1) & 2; \n        } \n \n        barrier(CLK_LOCAL_MEM_FENCE); \n    } \n} \n \n \n__kernel void segmented_scan_exclusive_int_nocut(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int(localId, groupSize, keys, flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n__kernel void segmented_scan_exclusive_int_nocut_part(__global int const* in_array, \n    __global int const* in_segment_heads_array, \n    int numelems, \n    __global int* out_array, \n    __global int* out_part_sums, \n    __global int* out_part_flags, \n    __local int* shmem) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    __local int* keys = shmem; \n    __local char* flags = (__local char*)(keys + groupSize); \n \n    keys[localId] = globalId < numelems ? in_array[globalId] : 0; \n    flags[localId] = globalId < numelems ? (in_segment_heads_array[globalId] ? 3 : 0) : 0; \n \n    barrier(CLK_LOCAL_MEM_FENCE); \n \n    group_segmented_scan_exclusive_int_nocut_part(localId, groupId, groupSize, keys, flags, out_part_sums, out_part_flags); \n \n    out_array[globalId] = keys[localId]; \n} \n \n \n__kernel void segmented_distribute_part_sum_int( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    //inout_array[globalId] += sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; in_flags[globalId + i] == 0 && i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                inout_array[globalId + i] += sum; \n            } \n        } \n    } \n} \n \n__kernel void segmented_distribute_part_sum_int_nocut( \n    __global int* inout_array, \n    __global int* in_flags, \n    int numelems, \n    __global int* in_sums \n    ) \n{ \n    int globalId = get_global_id(0); \n    int localId = get_local_id(0); \n    int groupSize = get_local_size(0); \n    int groupId = get_group_id(0); \n \n    int sum = in_sums[groupId]; \n    bool stop = false; \n    //inout_array[globalId] += sum; \n \n    if (localId == 0) \n    { \n        for (int i = 0; i < groupSize; ++i) \n        { \n            if (globalId + i < numelems) \n            { \n                if (in_flags[globalId + i] == 0) \n                { \n                    inout_array[globalId + i] += sum; \n                } \n                else \n                { \n                    if (stop) \n                    { \n                        break; \n                    } \n                    else \n                    { \n                        inout_array[globalId + i] += sum; \n                        stop = true; \n                    } \n                } \n            } \n        } \n    } \n} \n
/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \n INCLUDES \n **************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n/************************************************************************* \n TYPE DEFINITIONS \n **************************************************************************/ \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct  \n{ \n    // BVH structure \n    __global BvhNode const*       nodes; \n    // Scene positional data \n    __global float3 const*        vertices; \n    // Scene indices \n    __global Face const*          faces; \n    // Shape data \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*           extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH structure \nvoid IntersectSceneClosest(SceneData const* scenedata,  ray const* r, Intersection* isect) \n{ \n    const float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    int idx = 0; \n \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                IntersectLeafClosest(scenedata, &node, r, isect); \n                idx = (int)(node.pmax.w); \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n} \n \n \n \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata,  ray const* r) \n{ \n    float3 invdir  = make_float3(1.f, 1.f, 1.f)/r->d.xyz; \n \n    int idx = 0; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        // If this is the leaf try to intersect against contained triangle. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                if (IntersectLeafAny(scenedata, &node, r)) \n                { \n                    return true; \n                } \n                else \n                { \n                    idx = (int)(node.pmax.w); \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                ++idx; \n            } \n        } \n        else \n        { \n            idx = (int)(node.pmax.w); \n        } \n    }; \n \n    return false; \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosestAMD( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits, // Hit datas \n__global int*          raycnt  \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id  = get_global_id(0); \n    int local_id  = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAnyAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults,  // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRCAMD( \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits, // Hit datas \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    Intersection isect; \n \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[ridx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRCAMD( \n    // Input \n    __global BvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shapes \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults,   // Hit results \n    __global int* raycnt \n    ) \n{ \n    __local int nextrayidx; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (local_id == 0) \n    { \n        nextrayidx = 0; \n    } \n \n    int ridx = 0; \n    while (ridx < *numrays) \n    { \n        if (local_id == 0) \n        { \n            nextrayidx = atomic_add(raycnt, 64); \n        } \n \n        ridx = nextrayidx + local_id; \n \n        if (ridx >= *numrays) \n            break; \n \n        // Fetch ray \n        ray r = rays[ridx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[ridx] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \nint numrays,               // Number of rays to process                     \n__global int* hitresults  // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,      // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays,     // Number of rays in the workload \n__global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest(&scenedata, &r, &isect); \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n// Input \n__global BvhNode const* nodes,   // BVH nodes \n__global float3 const* vertices, // Scene positional data \n__global Face const* faces,    // Scene indices \n__global ShapeData const* shapes,     // Shapes \n__global ray const* rays,        // Ray workload \nint offset,                // Offset in rays array \n__global int const* numrays,     // Number of rays in the workload \n__global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n \n \n \n#define STARTIDX(x)     (((int)(x->pmin.w))) \n#define SHAPEIDX(x)     (((int)(x.pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n \ntypedef struct \n{ \n    // BVH structure \n    __global BvhNode*       nodes; \n    // Scene positional data \n    __global float3*        vertices; \n    // Scene indices \n    __global Face*          faces; \n    // Transforms \n    __global ShapeData*     shapedata; \n    // Root BVH idx \n    int rootidx; \n} SceneData; \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nbool IntersectLeafClosest( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangle(r, v1, v2, v3, isect)) \n    { \n        isect->primid = face.id; \n        return true; \n    } \n \n    return false; \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    BvhNode const* node, \n    ray const* r                      // ray to instersect \n) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    int start = STARTIDX(node); \n    face = scenedata->faces[start]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n    if (IntersectTriangleP(r, v1, v2, v3)) \n    { \n        return true; \n    } \n \n    return false; \n} \n \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneClosest2L(SceneData* scenedata, ray* r, Intersection* isect) \n{ \n    // Init intersection \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    // Precompute invdir for bbox testing \n    float3 invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    // Current shape id \n    int shapeid = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, isect->uvwt.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafClosest(scenedata, &node, r, isect)) \n                    { \n                        // Adjust shapeid as it might be instance \n                        isect->shapeid = shapeid; \n                    } \n \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n                        shapeid = scenedata->shapedata[shapeidx].id; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        // rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended up traversing bottom level BVH \n        // in this case idx = -1 and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topidx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            r->o = topray.o; \n            r->d = topray.d; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n \n// intersect Ray against the whole BVH2L structure \nbool IntersectSceneAny2L(SceneData* scenedata, ray* r) \n{ \n    // Precompute invdir for bbox testing \n    float3 invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    float3 invdirtop = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n    // We need to keep original ray around for returns from bottom hierarchy \n    ray topray = *r; \n \n    // Fetch top level BVH index \n    int idx = scenedata->rootidx; \n    // -1 indicates we are traversing top level \n    int topidx = -1; \n    while (idx != -1) \n    { \n        // Try intersecting against current node's bounding box. \n        BvhNode node = scenedata->nodes[idx]; \n        if (IntersectBox(r, invdir, node, r->o.w)) \n        { \n            if (LEAFNODE(node)) \n            { \n                // If this is the leaf it can be either a leaf containing primitives (bottom hierarchy) \n                // or containing another BVH (top level hierarhcy) \n                if (topidx != -1) \n                { \n                    // This is bottom level, so intersect with a primitives \n                    if (IntersectLeafAny(scenedata, &node, r)) \n                        return true; \n                    // And goto next node \n                    idx = (int)(node.pmax.w); \n                } \n                else \n                { \n                    // This is top level hierarchy leaf \n                    // Save top node index for return \n                    topidx = idx; \n                    // Get shape descrition struct index \n                    int shapeidx = SHAPEIDX(node); \n \n                    // Get shape mask \n                    int shapemask = scenedata->shapedata[shapeidx].mask; \n                    // Drill into 2nd level BVH only if the geometry is not masked vs current ray \n                    // otherwise skip the subtree \n                    if (Ray_GetMask(r) && shapemask) \n                    { \n                        // Fetch bottom level BVH index \n                        idx = scenedata->shapedata[shapeidx].bvhidx; \n \n                        // Fetch BVH transform \n                        float4 wmi0 = scenedata->shapedata[shapeidx].m0; \n                        float4 wmi1 = scenedata->shapedata[shapeidx].m1; \n                        float4 wmi2 = scenedata->shapedata[shapeidx].m2; \n                        float4 wmi3 = scenedata->shapedata[shapeidx].m3; \n \n                        // Apply linear motion blur (world coordinates) \n                        //float4 lmv = scenedata->shapedata[shapeidx].linearvelocity; \n                        //float4 amv = scenedata->shapedata[SHAPEDATAIDX(node)].angularvelocity; \n                        //r->o.xyz -= (lmv.xyz*r->d.w); \n                        // Transfrom the ray \n                        *r = transform_ray(*r, wmi0, wmi1, wmi2, wmi3); \n                        //rotate_ray(r, amv); \n                        // Recalc invdir \n                        invdir = make_float3(1.f, 1.f, 1.f) / r->d.xyz; \n                        // And continue traversal of the bottom level BVH \n                        continue; \n                    } \n                    else \n                    { \n                        // Skip the subtree \n                        idx = -1; \n                    } \n                } \n            } \n            // Traverse child nodes otherwise. \n            else \n            { \n                // This is an internal node, proceed to left child (it is at current + 1 index) \n                idx = idx + 1; \n            } \n        } \n        else \n        { \n            // We missed the node, goto next one \n            idx = (int)(node.pmax.w); \n        } \n \n        // Here check if we ended up traversing bottom level BVH \n        // in this case idx = 0xFFFFFFFF and topidx has valid value \n        if (idx == -1 && topidx != -1) \n        { \n            //  Proceed to next top level node \n            idx = (int)(scenedata->nodes[topidx].pmax.w); \n            // Set topidx \n            topidx = -1; \n            // Restore ray here \n            *r = topray; \n            // Restore invdir \n            invdir = invdirtop; \n        } \n    } \n \n    return false; \n} \n \n \n// 2 level variants \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n) \n{ \n \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n            // Write data back in case of a hit \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global Intersection* hits // Hit datas \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        int idx = offset + global_id; \n        ray r = rays[idx]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n            IntersectSceneClosest2L(&scenedata, &r, &isect); \n \n            hits[idx] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC2L( \n    // Input \n    __global BvhNode* nodes,   // BVH nodes \n    __global float3* vertices, // Scene positional data \n    __global Face* faces,    // Scene indices \n    __global ShapeData* shapedata, // Transforms \n    int rootidx,               // BVH root idx \n    __global ray* rays,        // Ray workload \n    __global int* numrays,     // Number of rays in the workload \n    int offset,                // Offset in rays array \n    __global int* hitresults   // Hit results \n) \n{ \n    int global_id = get_global_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapedata, \n        rootidx \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[offset + global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n            hitresults[offset + global_id] = IntersectSceneAny2L(&scenedata, &r) ? 1 : -1; \n        } \n    } \n} \n
/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nINCLUDES \n**************************************************************************/ \n/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \n/************************************************************************* \nDEFINES \n**************************************************************************/ \n#define PI 3.14159265358979323846f \n \ntypedef struct _bbox \n{ \n    float4 pmin; \n    float4 pmax; \n} bbox; \n \ntypedef struct _ray \n{ \n    float4 o; \n    float4 d; \n    int2 extra; \n    int2 padding; \n} ray; \n \ntypedef struct _Intersection \n{ \n    int shapeid; \n    int primid; \n    int padding0; \n    int padding1; \n \n    float4 uvwt; \n} Intersection; \n \ntypedef struct _ShapeData \n{ \n    int id; \n    int bvhidx; \n    int mask; \n    int padding1; \n    float4 m0; \n    float4 m1; \n    float4 m2; \n    float4 m3; \n    float4  linearvelocity; \n    float4  angularvelocity; \n} ShapeData; \n \ntypedef bbox BvhNode; \n \ntypedef struct _Face \n{ \n    // Vertex indices \n    int idx[3]; \n    int shapeidx; \n    // Primitive ID \n    int id; \n    // Idx count \n    int cnt; \n \n    int2 padding; \n} Face; \n \n#ifndef APPLE \n \nfloat4 make_float4(float x, float y, float z, float w) \n{ \n    float4 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    res.w = w; \n    return res; \n} \n \nfloat3 make_float3(float x, float y, float z) \n{ \n    float3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \nfloat2 make_float2(float x, float y) \n{ \n    float2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint2 make_int2(int x, int y) \n{ \n    int2 res; \n    res.x = x; \n    res.y = y; \n    return res; \n} \n \nint3 make_int3(int x, int y, int z) \n{ \n    int3 res; \n    res.x = x; \n    res.y = y; \n    res.z = z; \n    return res; \n} \n \n#endif \n \nfloat3 transform_point(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z + m0.s3; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z + m1.s3; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z + m2.s3; \n    return res; \n} \n \nfloat3 transform_vector(float3 p, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    float3 res; \n    res.x = m0.s0 * p.x + m0.s1 * p.y + m0.s2 * p.z; \n    res.y = m1.s0 * p.x + m1.s1 * p.y + m1.s2 * p.z; \n    res.z = m2.s0 * p.x + m2.s1 * p.y + m2.s2 * p.z; \n    return res; \n} \n \nray transform_ray(ray r, float4 m0, float4 m1, float4 m2, float4 m3) \n{ \n    ray res; \n    res.o.xyz = transform_point(r.o.xyz, m0, m1, m2, m3); \n    res.d.xyz = transform_vector(r.d.xyz, m0, m1, m2, m3); \n    res.o.w = r.o.w; \n    res.d.w = r.d.w; \n    return res; \n} \n \nfloat4 quaternion_mul(float4 q1, float4 q2) \n{ \n    float4 res; \n    res.x = q1.y*q2.z - q1.z*q2.y + q2.w*q1.x + q1.w*q2.x; \n    res.y = q1.z*q2.x - q1.x*q2.z + q2.w*q1.y + q1.w*q2.y; \n    res.z = q1.x*q2.y - q2.x*q1.y + q2.w*q1.z + q1.w*q2.z; \n    res.w = q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z; \n    return res; \n} \n \nfloat4 quaternion_conjugate(float4 q) \n{ \n    return make_float4(-q.x, -q.y, -q.z, q.w); \n} \n \nfloat4 quaternion_inverse(float4 q) \n{ \n    float sqnorm = q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w; \n     \n    if (sqnorm != 0.f) \n    { \n        return quaternion_conjugate(q) / sqnorm; \n    } \n    else \n    { \n        return make_float4(0.f, 0.f, 0.f, 1.f); \n    } \n} \n \nvoid rotate_ray(ray* r, float4 q) \n{ \n    float4 qinv = quaternion_inverse(q); \n    float4 v = make_float4(r->o.x, r->o.y, r->o.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->o.xyz = v.xyz; \n    v = make_float4(r->d.x, r->d.y, r->d.z, 0); \n    v = quaternion_mul(qinv, quaternion_mul(v, q)); \n    r->d.xyz = v.xyz; \n} \n \n// Intersect Ray against triangle \nint IntersectTriangle(ray const* r, float3 v1, float3 v2, float3 v3, Intersection* isect) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > isect->uvwt.w) \n    { \n        return 0; \n    } \n    else \n    { \n        isect->uvwt = make_float4(b1, b2, 0.f, temp); \n        return 1; \n    } \n} \n \nint IntersectTriangleP(ray const* r, float3 v1, float3 v2, float3 v3) \n{ \n    const float3 e1 = v2 - v1; \n    const float3 e2 = v3 - v1; \n    const float3 s1 = cross(r->d.xyz, e2); \n    const float  invd = native_recip(dot(s1, e1)); \n    const float3 d = r->o.xyz - v1; \n    const float  b1 = dot(d, s1) * invd; \n    const float3 s2 = cross(d, e1); \n    const float  b2 = dot(r->d.xyz, s2) * invd; \n    const float temp = dot(e2, s2) * invd; \n     \n    if (b1 < 0.f || b1 > 1.f || b2 < 0.f || b1 + b2 > 1.f \n        || temp < 0.f || temp > r->o.w) \n    { \n        return 0; \n    } \n     \n    return 1; \n} \n \n#ifdef AMD_MEDIA_OPS \n#pragma OPENCL EXTENSION cl_amd_media_ops2 : enable \n#endif \n \n// Intersect ray with the axis-aligned box \nint IntersectBox(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? 1 : 0; \n} \n \nfloat IntersectBoxF(ray const* r, float3 invdir, bbox box, float maxt) \n{ \n    const float3 f = (box.pmax.xyz - r->o.xyz) * invdir; \n    const float3 n = (box.pmin.xyz - r->o.xyz) * invdir; \n \n    const float3 tmax = max(f, n); \n    const float3 tmin = min(f, n); \n \n \n#ifndef AMD_MEDIA_OPS \n    const float t1 = min(min(tmax.x, min(tmax.y, tmax.z)), maxt); \n    const float t0 = max(max(tmin.x, max(tmin.y, tmin.z)), 0.f); \n#else \n    const float t1 = min(amd_min3(tmax.x, tmax.y, tmax.z), maxt); \n    const float t0 = max(amd_max3(tmin.x, tmin.y, tmin.z), 0.f); \n#endif \n \n    return (t1 >= t0) ? (t0 > 0.f ? t0 : t1) : -1.f; \n} \n \nint Ray_GetMask(ray const* r) \n{ \n    return r->extra.x; \n} \n \nint Ray_IsActive(ray const* r) \n{ \n    return r->extra.y; \n} \n \nfloat Ray_GetMaxT(ray const* r) \n{ \n    return r->o.w; \n} \n \nfloat Ray_GetTime(ray const* r) \n{ \n    return r->d.w; \n} \n/************************************************************************* \nEXTENSIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nTYPE DEFINITIONS \n**************************************************************************/ \n#define STARTIDX(x)     (((int)((x).pmin.w))) \n#define LEAFNODE(x)     (((x).pmin.w) != -1.f) \n#define SHORT_STACK_SIZE 16 \n \n \ntypedef struct \n{ \n    bbox lbound; \n    bbox rbound; \n} FatBvhNode; \n \ntypedef struct \n{ \n    // BVH structure \n    __global FatBvhNode const*     nodes; \n    // Scene positional data \n    __global float3 const*         vertices; \n    // Scene indices \n    __global Face const*         faces; \n    // Shape IDs \n    __global ShapeData const*     shapes; \n    // Extra data \n    __global int const*             extra; \n} SceneData; \n \n/************************************************************************* \nHELPER FUNCTIONS \n**************************************************************************/ \n \n \n \n/************************************************************************* \nBVH FUNCTIONS \n**************************************************************************/ \n//  intersect a ray with leaf BVH node \nvoid IntersectLeafClosest( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r,                // ray to instersect \n    Intersection* isect          // Intersection structure \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangle(r, v1, v2, v3, isect)) \n        { \n            isect->primid = face.id; \n            isect->shapeid = scenedata->shapes[face.shapeidx].id; \n        } \n    } \n} \n \n//  intersect a ray with leaf BVH node \nbool IntersectLeafAny( \n    SceneData const* scenedata, \n    int faceidx, \n    ray const* r                      // ray to instersect \n    ) \n{ \n    float3 v1, v2, v3; \n    Face face; \n \n    face = scenedata->faces[faceidx]; \n    v1 = scenedata->vertices[face.idx[0]]; \n    v2 = scenedata->vertices[face.idx[1]]; \n    v3 = scenedata->vertices[face.idx[2]]; \n \n#ifdef RR_RAY_MASK \n    int shapemask = scenedata->shapes[face.shapeidx].mask; \n \n    if (Ray_GetMask(r) & shapemask) \n#endif \n    { \n        if (IntersectTriangleP(r, v1, v2, v3)) \n        { \n            return true; \n        } \n    } \n \n    return false; \n} \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n            if (leftleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n            } \n \n            if (rightleaf) \n            { \n                IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return isect->shapeid >= 0; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneClosest(SceneData const* scenedata, ray const* r, Intersection* isect) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    isect->uvwt = make_float4(0.f, 0.f, 0.f, r->o.w); \n    isect->shapeid = -1; \n    isect->primid = -1; \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, isect->uvwt.w); \n        righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, isect->uvwt.w); \n \n        if (leftleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.lbound), r, isect); \n        } \n \n        if (rightleaf) \n        { \n            IntersectLeafClosest(scenedata, STARTIDX(node.rbound), r, isect); \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n            continue; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n            continue; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n            continue; \n        } \n \n                idx = *--sptr; \n    } \n \n    return isect->shapeid >= 0; \n} \n#endif \n \n#ifndef GLOBAL_STACK \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r, __global int* stack, __local int* ldsstack) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    __global int* gsptr = stack; \n    __local  int* lsptr = ldsstack; \n \n    if (r->o.w < 0.f) \n        return false; \n \n    *lsptr = -1; \n    lsptr += 64; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n \n    while (idx > -1) \n    { \n        while (idx > -1) \n        { \n            node = scenedata->nodes[idx]; \n \n            leftleaf = LEAFNODE(node.lbound); \n            rightleaf = LEAFNODE(node.rbound); \n \n            lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n            righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n            if (leftleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n                                    return true; \n            } \n \n            if (rightleaf) \n            { \n                if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                                return true; \n            } \n \n            if (lefthit > 0.f && righthit > 0.f) \n            { \n                int deferred = -1; \n                if (lefthit > righthit) \n                { \n                    idx = (int)node.rbound.pmax.w; \n                    deferred = (int)node.lbound.pmax.w;; \n \n                } \n                else \n                { \n                    idx = (int)node.lbound.pmax.w; \n                    deferred = (int)node.rbound.pmax.w; \n                } \n \n                if (lsptr - ldsstack >= SHORT_STACK_SIZE * 64) \n                { \n                    for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n                    { \n                        gsptr[i] = ldsstack[i * 64]; \n                    } \n \n                    gsptr += SHORT_STACK_SIZE; \n                    lsptr = ldsstack + 64; \n                } \n \n                *lsptr = deferred; \n                lsptr += 64; \n                continue; \n            } \n            else if (lefthit > 0) \n            { \n                idx = (int)node.lbound.pmax.w; \n                continue; \n            } \n            else if (righthit > 0) \n            { \n                idx = (int)node.rbound.pmax.w; \n                continue; \n            } \n \n            lsptr -= 64; \n            idx = *(lsptr); \n        } \n \n        if (gsptr > stack) \n        { \n            gsptr -= SHORT_STACK_SIZE; \n \n            for (int i = 1; i < SHORT_STACK_SIZE; ++i) \n            { \n                ldsstack[i * 64] = gsptr[i]; \n            } \n \n            lsptr = ldsstack + (SHORT_STACK_SIZE - 1) * 64; \n            idx = ldsstack[64 * (SHORT_STACK_SIZE - 1)]; \n        } \n    } \n \n    return false; \n} \n#else \n// intersect Ray against the whole BVH structure \nbool IntersectSceneAny(SceneData const* scenedata, ray const* r) \n{ \n    const float3 invdir = native_recip(r->d.xyz); \n \n    if (r->o.w < 0.f) \n        return false; \n     \n    int stack[32]; \n \n    int* sptr = stack; \n    *sptr++ = -1; \n \n    int idx = 0; \n    FatBvhNode node; \n \n    bool leftleaf = false; \n    bool rightleaf = false; \n    float lefthit = 0.f; \n    float righthit = 0.f; \n    int step = 0; \n \n    bool found = false; \n \n    while (idx > -1) \n    { \n        node = scenedata->nodes[idx]; \n \n        leftleaf = LEAFNODE(node.lbound); \n        rightleaf = LEAFNODE(node.rbound); \n \n        lefthit = leftleaf ? -1.f : IntersectBoxF(r, invdir, node.lbound, r->o.w); \n        righthit = rightleaf ? -1.f : IntersectBoxF(r, invdir, node.rbound, r->o.w); \n \n        if (leftleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.lbound), r)) \n            { \n                found = true; \n                break; \n            } \n        } \n         \n        if (rightleaf) \n        { \n            if (IntersectLeafAny(scenedata, STARTIDX(node.rbound), r)) \n                    { \n                        found = true; \n                        break; \n                    } \n        } \n \n        if (lefthit > 0.f && righthit > 0.f) \n        { \n            int deferred = -1; \n            if (lefthit > righthit) \n            { \n                idx = (int)node.rbound.pmax.w; \n                deferred = (int)node.lbound.pmax.w;; \n            } \n            else \n            { \n                idx = (int)node.lbound.pmax.w; \n                deferred = (int)node.rbound.pmax.w; \n            } \n \n                    *sptr++ = deferred; \n        } \n        else if (lefthit > 0) \n        { \n            idx = (int)node.lbound.pmax.w; \n        } \n        else if (righthit > 0) \n        { \n            idx = (int)node.rbound.pmax.w; \n        } \n \n        if (lefthit <= 0.f && righthit <= 0.f) \n            idx = *--sptr; \n    } \n \n    return found; \n} \n \n#endif \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectClosest( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes, // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n         \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n__kernel void IntersectAny( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    int numrays,               // Number of rays to process                     \n    __global int* hitresults  // Hit results \n    , __global int* stack \n    ) \n{ \n \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    if (global_id < numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectClosestRC( \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,      // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global Intersection* hits // Hit datas \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate closest hit \n            Intersection isect; \n#ifndef GLOBAL_STACK  \n            IntersectSceneClosest(&scenedata, &r, &isect, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id); \n#else \n            IntersectSceneClosest(&scenedata, &r, &isect); \n#endif \n            // Write data back in case of a hit \n            hits[global_id] = isect; \n        } \n    } \n} \n \n__attribute__((reqd_work_group_size(64, 1, 1))) \n// Version with range check \n__kernel void IntersectAnyRC( \n    // Input \n    __global FatBvhNode const* nodes,   // BVH nodes \n    __global float3 const* vertices, // Scene positional data \n    __global Face const* faces,    // Scene indices \n    __global ShapeData const* shapes,     // Shape data \n    __global ray const* rays,        // Ray workload \n    int offset,                // Offset in rays array \n    __global int const* numrays,     // Number of rays in the workload \n    __global int* hitresults   // Hit results \n    , __global int* stack \n    ) \n{ \n    __local int ldsstack[SHORT_STACK_SIZE * 64]; \n    int global_id = get_global_id(0); \n    int local_id = get_local_id(0); \n    int group_id = get_group_id(0); \n \n    // Fill scene data  \n    SceneData scenedata = \n    { \n        nodes, \n        vertices, \n        faces, \n        shapes, \n        0 \n    }; \n \n    // Handle only working subset \n    if (global_id < *numrays) \n    { \n        // Fetch ray \n        ray r = rays[global_id]; \n \n        if (Ray_IsActive(&r)) \n        { \n            // Calculate any intersection \n#ifndef GLOBAL_STACK  \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r, stack + group_id * 64 * 32 + local_id * 32, ldsstack + local_id) ? 1 : -1; \n#else \n            hitresults[global_id] = IntersectSceneAny(&scenedata, &r) ? 1 : -1; \n#endif \n        } \n    } \n} \n
/********************************************************************** \nCopyright (c) 2016 Advanced Micro Devices, Inc. All rights reserved. \n \nPermission is hereby granted, free of charge, to any person obtaining a copy \nof this software and associated documentation files (the "Software"), to deal \nin the Software without restriction, including without limitation the rights \nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom the Software is \nfurnished to do so, subject to the following conditions: \n \nThe above copyright notice and this permission notice shall be included in \nall copies or substantial portions of the Software. \n \nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE \nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, \nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN \nTHE SOFTWARE. \n********************************************************************/ \n \ntypedef struct \n{ \n    float3 pmin; \n    float3 pmax; \n} bbox; \n \n// The following two functions are from \n// http://devblogs.nvidia.com/parallelforall/thinking-parallel-part-iii-tree-construction-gpu/ \n// Expands a 10-bit integer into 30 bits \n// by inserting 2 zeros after each bit. \nstatic unsigned int ExpandBits(unsigned int v) \n{ \n    v = (v * 0x00010001u) & 0xFF0000FFu; \n    v = (v * 0x00000101u) & 0x0F00F00Fu; \n    v = (v * 0x00000011u) & 0xC30C30C3u; \n    v = (v * 0x00000005u) & 0x49249249u; \n    return v; \n} \n \n// Calculates a 30-bit Morton code for the \n// given 3D point located within the unit cube [0,1]. \nunsigned int CalculateMortonCode(float3 p) \n{ \n    float x = min(max(p.x * 1024.0f, 0.0f), 1023.0f); \n    float y = min(max(p.y * 1024.0f, 0.0f), 1023.0f); \n    float z = min(max(p.z * 1024.0f, 0.0f), 1023.0f); \n    unsigned int xx = ExpandBits((unsigned int)x); \n    unsigned int yy = ExpandBits((unsigned int)y); \n    unsigned int zz = ExpandBits((unsigned int)z); \n    return xx * 4 + yy * 2 + zz; \n} \n \n// Assign Morton codes to each of positions \n__kernel void CalcMortonCode( \n    // Centers of primitive bounding boxes \n    __global bbox const* bounds, \n    // Number of primitives \n    int numpositions, \n    // Morton codes \n    __global int* mortoncodes \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    if (globalid < numpositions) \n    { \n        bbox bound = bounds[globalid]; \n        float3 center = 0.5f * (bound.pmax + bound.pmin); \n        mortoncodes[globalid] = CalculateMortonCode(center); \n    } \n} \n \n \nbbox bboxunion(bbox b1, bbox b2) \n{ \n    bbox res; \n    res.pmin = min(b1.pmin, b2.pmin); \n    res.pmax = max(b1.pmax, b2.pmax); \n    return res; \n} \n \ntypedef struct \n{ \n        int parent; \n        int left; \n        int right; \n        int next; \n} HlbvhNode; \n \n#define LEAFIDX(i) ((numprims-1) + i) \n#define NODEIDX(i) (i) \n \n// Calculates longest common prefix length of bit representations \n// if  representations are equal we consider sucessive indices \nint delta(__global int* mortoncodes, int numprims, int i1, int i2) \n{ \n    // Select left end \n    int left = min(i1, i2); \n    // Select right end \n    int right = max(i1, i2); \n    // This is to ensure the node breaks if the index is out of bounds \n    if (left < 0 || right >= numprims)  \n    { \n        return -1; \n    } \n    // Fetch Morton codes for both ends \n    int leftcode = mortoncodes[left]; \n    int rightcode = mortoncodes[right]; \n \n    // Special handling of duplicated codes: use their indices as a fallback \n    return leftcode != rightcode ? clz(leftcode ^ rightcode) : (32 + clz(left ^ right)); \n} \n \n// Shortcut for delta evaluation \n#define DELTA(i,j) delta(mortoncodes,numprims,i,j) \n \n// Find span occupied by internal node with index idx \nint2 FindSpan(__global int* mortoncodes, int numprims, int idx) \n{ \n    // Find the direction of the range \n    int d = sign((float)(DELTA(idx, idx+1) - DELTA(idx, idx-1))); \n \n    // Find minimum number of bits for the break on the other side \n    int deltamin = DELTA(idx, idx-d); \n \n    // Search conservative far end \n    int lmax = 2; \n    while (DELTA(idx,idx + lmax * d) > deltamin) \n        lmax *= 2; \n \n    // Search back to find exact bound \n    // with binary search \n    int l = 0; \n    int t = lmax; \n    do \n    { \n        t /= 2; \n        if(DELTA(idx, idx + (l + t)*d) > deltamin) \n        { \n            l = l + t; \n        } \n    } \n    while (t > 1); \n \n    // Pack span  \n    int2 span; \n    span.x = min(idx, idx + l*d); \n    span.y = max(idx, idx + l*d); \n    return span; \n} \n \n// Find split idx within the span \nint FindSplit(__global int* mortoncodes, int numprims, int2 span) \n{ \n    // Fetch codes for both ends \n    int left = span.x; \n    int right = span.y; \n \n    // Calculate the number of identical bits from higher end \n    int numidentical = DELTA(left, right); \n \n    do \n    { \n        // Proposed split \n        int newsplit = (right + left) / 2; \n \n        // If it has more equal leading bits than left and right accept it \n        if (DELTA(left, newsplit) > numidentical) \n        { \n            left = newsplit; \n        } \n        else \n        { \n            right = newsplit; \n        } \n    } \n    while (right > left + 1); \n \n    return left; \n} \n \n// Set parent-child relationship \n__kernel void BuildHierarchy( \n    // Sorted Morton codes of the primitives \n    __global int* mortoncodes, \n    // Bounds \n    __global bbox* bounds, \n    // Primitive indices \n    __global int* indices, \n    // Number of primitives \n    int numprims, \n    // Nodes \n    __global HlbvhNode* nodes, \n    // Leaf bounds \n    __global bbox* boundssorted \n    ) \n{ \n    int globalid = get_global_id(0); \n \n    // Set child \n    if (globalid < numprims) \n    { \n        nodes[LEAFIDX(globalid)].left = nodes[LEAFIDX(globalid)].right = indices[globalid]; \n        boundssorted[LEAFIDX(globalid)] = bounds[indices[globalid]]; \n    } \n     \n    // Set internal nodes \n    if (globalid < numprims - 1) \n    { \n        // Find span occupied by the current node \n        int2 range = FindSpan(mortoncodes, numprims, globalid); \n \n        // Find split position inside the range \n        int  split = FindSplit(mortoncodes, numprims, range); \n \n        // Create child nodes if needed \n        int c1idx = (split == range.x) ? LEAFIDX(split) : NODEIDX(split); \n        int c2idx = (split + 1 == range.y) ? LEAFIDX(split + 1) : NODEIDX(split + 1); \n \n        nodes[NODEIDX(globalid)].left = c1idx; \n        nodes[NODEIDX(globalid)].right = c2idx; \n        //nodes[NODEIDX(globalid)].next = (range.y + 1 < numprims) ? range.y + 1 : -1; \n        nodes[c1idx].parent = NODEIDX(globalid); \n        //nodes[c1idx].next = c2idx; \n        nodes[c2idx].parent = NODEIDX(globalid); \n        //nodes[c2idx].next = nodes[NODEIDX(globalid)].next; \n    } \n} \n \n// Propagate bounds up to the root \n__kernel void RefitBounds(__global bbox* bounds, \n                          int numprims, \n                          __global HlbvhNode* nodes, \n                          __global int* flags \n                          ) \n{ \n    int globalid = get_global_id(0); \n \n    // Start from leaf nodes \n    if (globalid < numprims) \n    { \n        // Get my leaf index \n        int idx = LEAFIDX(globalid); \n \n        do \n        { \n            // Move to parent node \n            idx = nodes[idx].parent; \n \n            // Check node's flag \n            if (atomic_cmpxchg(flags + idx, 0, 1) == 1) \n            { \n                // If the flag was 1 the second child is ready and  \n                // this thread calculates bbox for the node \n \n                // Fetch kids \n                int lc = nodes[idx].left; \n                int rc = nodes[idx].right; \n \n                // Calculate bounds \n                bbox b = bboxunion(bounds[lc], bounds[rc]); \n \n                // Write bounds \n                bounds[idx] = b; \n            } \n            else \n            { \n                // If the flag was 0 set it to 1 and bail out. \n                // The thread handling the second child will \n                // handle this node. \n                break; \n            } \n        } \n        while (idx != 0); \n    } \n} \n
/-K=o64=y
//\n// Copyright 2017-2023 Valve Corporation.\n//\n// Licensed under the Apache License, Version 2.0 (the "License");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an "AS IS" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable\n#pragma OPENCL EXTENSION cl_khr_byte_addressable_store : enable\n\n// --------------------------------------------------------------------------------------------------------------------\n// Constants\n// --------------------------------------------------------------------------------------------------------------------\n\n#define PI                          3.14159f              // Mathematical constant Pi\n#define SOURCE_RADIUS               0.1f                  // Radius of the sound source sphere (in meters)\n#define LISTENER_RADIUS             0.1f                  // Radius of the listener sphere (in meters)\n#define SPEED_OF_SOUND              340.0f                // Speed of sound in air (in meters per second)\n#define RAY_SURFACE_OFFSET          1e-2f                 // Small offset to prevent ray self-intersection (meters)\n#define SPECULAR_EXPONENT           1e+2f                 // Exponent for specular reflection in Phong shading model (unitless, higher value = more specular)\n#define NUM_BANDS                   3                     // Number of frequency bands (e.g., Low, Mid, High)\n#define NUM_BINS                    256                   // Number of time bins used for energy histograms\n#define BIN_DURATION                0.01f                 // Duration of each time bin (in seconds)\n#define NUM_LOCAL_HISTOGRAMS        2                     // Number of local histograms per workgroup (for atomic contention reduction, tunable)\n\n// --------------------------------------------------------------------------------------------------------------------\n// CoordinateSpace\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) CoordinateSpace_t\n{\n    float3 right;\n    float3 up;\n    float3 ahead;\n    float3 origin;\n} CoordinateSpace;\n\nCoordinateSpace createCoordinateSpace(float3 normal)\n{\n    CoordinateSpace space;\n    space.ahead = normal;\n\n    if (fabs(normal.x) > fabs(normal.z))\n    {\n        float3 right = (float3) (-normal.y, normal.x, 0.0f);\n        space.right = normalize(right);\n    }\n    else\n    {\n        float3 right = (float3) (0.0f, -normal.z, normal.y);\n        space.right = normalize(right);\n    }\n\n    space.up = cross(space.right, space.ahead);\n\n    return space;\n}\n\nfloat3 transformLocalToWorld(CoordinateSpace space,\n                             float3 direction)\n{\n    return direction.x * space.right + direction.y * space.up - direction.z * space.ahead;\n}\n\nfloat3 transformWorldToLocal(CoordinateSpace space,\n                             float3 direction)\n{\n    float3 transformedDirection;\n    transformedDirection.x = dot(direction, space.right);\n    transformedDirection.y = dot(direction, space.up);\n    transformedDirection.z = -dot(direction, space.ahead);\n    return transformedDirection;\n}\n\nfloat3 transformHemisphereSample(float3 direction,\n                                 float3 normal)\n{\n    CoordinateSpace tangentSpace = createCoordinateSpace(normal);\n    return normalize(transformLocalToWorld(tangentSpace, direction));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Random Sampling\n// --------------------------------------------------------------------------------------------------------------------\n\n// The following code is from the Radeon Rays / Baikal GitHub repository. It can be found at:\n//      https://github.com/GPUOpen-LibrariesAndSDKs/RadeonProRender-Baikal/blob/master/Baikal/Kernels/CL/sampling.cl\n\ntypedef struct RNG_t\n{\n    uint    value;\n} RNG;\n\nuint wangHash(uint seed)\n{\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nuint randUint(local RNG* rng)\n{\n    rng->value = wangHash(1664525U * rng->value + 1013904223U);\n    return rng->value;\n}\n\nfloat randFloat(local RNG* rng)\n{\n    return ((float)randUint(rng)) / 0xffffffffU;\n}\n\nvoid initRNG(uint seed, local RNG* rng)\n{\n    rng->value = wangHash(seed);\n}\n\nfloat2 uniformRandom2d(local RNG* rng)\n{\n    return (float2) (randFloat(rng), randFloat(rng));\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Directivity\n// --------------------------------------------------------------------------------------------------------------------\n\n// NOTE: Custom directivity callbacks are not supported at this time.\ntypedef struct __attribute__((packed)) Directivity_t\n{\n    float dipoleWeight;\n    float dipolePower;\n} Directivity;\n\nfloat evaluateDirectivity(float3 point,\n                          CoordinateSpace coordinates,\n                          Directivity directivity)\n{\n    float3 worldSpaceDirection = normalize(point - coordinates.origin);\n    float3 localSpaceDirection = transformWorldToLocal(coordinates, worldSpaceDirection);\n\n    float cosine = -localSpaceDirection.z;\n    return pow(fabs((1.0f - directivity.dipoleWeight) + directivity.dipoleWeight * cosine), directivity.dipolePower);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Material\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct __attribute__((packed)) Material_t\n{\n    float  absorptionLow;\n    float  absorptionMid;\n    float  absorptionHigh;\n    float  scattering;\n    float  transmissionLow;\n    float  transmissionMid;\n    float  transmissionHigh;\n} Material;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Radeon Rays Helpers\n// --------------------------------------------------------------------------------------------------------------------\n\n// This must exactly match the ray data structure (struct ray) used by Radeon Rays.\ntypedef struct Ray_t\n{\n    float4  o;\n    float4  d;\n    int2    extra;\n    int2    padding;\n} Ray;\n\n// This must exactly match the hit data structure (struct Intersection) used by Radeon Rays.\ntypedef struct Hit_t\n{\n    int       shapeid;\n    int       primid;\n    int       padding0;\n    int       padding1;\n    float4    uvwt;\n} Hit;\n\n// --------------------------------------------------------------------------------------------------------------------\n// IIR Filtering\n// --------------------------------------------------------------------------------------------------------------------\n\ntypedef struct IIR_t\n{\n    float a1, a2;\n    float b0, b1, b2;\n} IIR;\n\n// --------------------------------------------------------------------------------------------------------------------\n// Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void generateCameraRays(global CoordinateSpace* camera,\n                               global Ray* rays)\n{\n    uint width = get_global_size(0);\n    uint height = get_global_size(1);\n    uint u = get_global_id(0);\n    uint v = get_global_id(1);\n    uint index = v * width + u;\n\n    float du = ((u / (float) width) - 0.5f) * 2.0f;\n    float dv = ((v / (float) height) - 0.5f) * 2.0f;\n\n    rays[index].o = (float4) (camera->origin, FLT_MAX);\n    rays[index].d = (float4) (normalize(du * camera->right + dv * camera->up - camera->ahead), 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\nkernel void generateListenerRays(global CoordinateSpace* listeners,\n                                 global float4* sphereSamples,\n                                 global Ray* rays)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t listenerIndex = get_global_id(1);\n    size_t index = listenerIndex * get_global_size(0) + rayIndex;\n\n    rays[index].o = (float4) (listeners[listenerIndex].origin, FLT_MAX);\n    rays[index].d = (float4) (sphereSamples[rayIndex].xyz, 0.0f);\n    rays[index].extra = (int2) (0xffffffff, 1);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Sphere Occlusion Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat raySphereIntersect(global const Ray* ray,\n                         float3 center,\n                         float radius)\n{\n    float3 origin = ray->o.xyz;\n    float3 direction = ray->d.xyz;\n\n    float3 v = origin - center;\n    float r = radius;\n\n    float B = 2.0f * dot(v, direction);\n    float C = dot(v, v) - (r * r);\n    float D = (B * B) - (4.0f * C);\n\n    if (D < 0.0f)\n        return FLT_MAX;\n\n    float t = -0.5f * (B + sqrt(D));\n    return t;\n}\n\nkernel void sphereOcclusion(uint numSources,\n                            global const CoordinateSpace* sources,\n                            uint numListeners,\n                            global const CoordinateSpace* listeners,\n                            global Ray* rays,\n                            global Hit* hits)\n{\n    uint numRays = get_global_size(0);\n    uint rayIndex = get_global_id(0);\n\n    for (int i = 0; i < numListeners; ++i)\n    {\n        uint index = i * numRays + rayIndex;\n\n        float listenerSphereHitDistance = raySphereIntersect(&rays[index], listeners[i].origin, LISTENER_RADIUS);\n        if (0.0f <= listenerSphereHitDistance && listenerSphereHitDistance < hits[index].uvwt.s3)\n        {\n            rays[index].extra.y = 0;\n            hits[index].primid = -1;\n            return;\n        }\n\n        for (int j = 0; j < numSources; ++j)\n        {\n            float sourceSphereHitDistance = raySphereIntersect(&rays[index], sources[j].origin, SOURCE_RADIUS);\n            if (0.0f <= sourceSphereHitDistance && sourceSphereHitDistance < hits[index].uvwt.s3)\n            {\n                rays[index].extra.y = 0;\n                hits[index].primid = -1;\n                return;\n            }\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Shading + Shadow/Bounced Ray Generation Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\nfloat3 calculateHitPoint(Ray ray,\n                         Hit hit)\n{\n    return ray.o.xyz + hit.uvwt.s3 * ray.d.xyz;\n}\n\nfloat3 calculateHitNormal(Ray ray,\n                          Hit hit,\n                          global float4* normals)\n{\n    float3 hitNormal = normals[hit.primid].xyz;\n    if (dot(hitNormal, ray.d.xyz) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    return hitNormal;\n}\n\nfloat pointSourceIrradiance(float distance,\n                            float minDistance)\n{\n    float attenuation = 1.0f / max(distance, minDistance);\n    float irradiance = (1.0f / (4.0f * PI)) * (attenuation * attenuation);\n    return irradiance;\n}\n\nfloat3 reflect(float3 incident,\n               float3 normal)\n{\n    return normalize(incident - (2.0f * dot(incident, normal) * normal));\n}\n\nkernel void shadeAndBounce(uint numSources,\n                           global const CoordinateSpace* sources,\n                           uint numListeners,\n                           global const CoordinateSpace* listeners,\n                           global const Directivity* directivities,\n                           uint numRays,\n                           uint numBounces,\n                           float irradianceMinDistance,\n                           global const Ray* rays,\n                           global const Hit* hits,\n                           global const float3* normals,\n                           global const int* materialIndices,\n                           global const Material* materials,\n                           uint numDiffuseSamples,\n                           global const float4* diffuseSamples,\n                           uint randomNumber,\n                           float scalar,\n                           global Ray* shadowRays,\n                           global Ray* reflectedRays,\n                           global float4* energyDelay,\n                           global float4* accumEnergyDelay)\n{\n    size_t numChunks = max(numListeners, numSources);\n    size_t numPrimaryRays = get_global_size(0) / numChunks;\n    size_t numShadowRays = get_global_size(0);\n\n    uint rayIndex = (numListeners > 1) ? get_global_id(0) : (get_global_id(0) % numPrimaryRays);\n    uint chunkIndex = get_global_id(0) / numPrimaryRays;\n    uint listenerIndex = (numListeners > 1) ? chunkIndex : 0;\n    uint sourceIndex = (numSources > 1) ? chunkIndex : 0;\n    uint shadowRayIndex = get_global_id(0);\n\n    // If this ray is disabled, don't do anything.\n    if (rays[rayIndex].extra.y == 0 || hits[rayIndex].primid < 0)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        reflectedRays[rayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n        return;\n    }\n\n    // Random number generation for work group.\n    local RNG rng;\n    local float randomFloat;\n    local uint randomUint;\n    if (get_local_id(0) == 0)\n    {\n        initRNG(randomNumber + rayIndex, &rng);\n        randomFloat = randFloat(&rng);\n        randomUint = randUint(&rng);\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n    // Calculate hit point.\n    float3 rayDirection = rays[rayIndex].d.xyz;\n    int triangleIndex = hits[rayIndex].primid;\n    float hitDistance = hits[rayIndex].uvwt.s3;\n    float3 hitPoint = rays[rayIndex].o.xyz + hitDistance * rayDirection;\n\n    // Calculate hit normal.\n    float3 hitNormal = normals[triangleIndex].xyz;\n    if (dot(hitNormal, rayDirection) > 0.0f)\n    {\n        hitNormal = -hitNormal;\n    }\n\n    // Calculate hit material.\n    Material hitMaterial = materials[materialIndices[triangleIndex]];\n    float3 hitMaterialAbsorption = (float3) (hitMaterial.absorptionLow, hitMaterial.absorptionMid, hitMaterial.absorptionHigh);\n\n    // Calculate shadow ray direction.\n    float3 source = sources[sourceIndex].origin;\n    float hitToSourceDistance = distance(hitPoint, source);\n    float4 hitToSource = (float4) (normalize(source - hitPoint), 0.0f);\n\n    // Skip the ray if:\n    //  a) the hit point is inside the listener, or\n    //  b) the hit point is too close to the source, or\n    //  c) the ray hit a backfacing triangle.\n    if (hitDistance <= LISTENER_RADIUS ||\n        hitToSourceDistance <= irradianceMinDistance ||\n        dot(hitToSource.xyz, hitNormal) < 0.0f)\n    {\n        shadowRays[shadowRayIndex].extra = 0;\n        energyDelay[shadowRayIndex] = (float4) 0.0f;\n    }\n    else\n    {\n        // Generate the shadow ray.\n        shadowRays[shadowRayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * hitToSource.xyz, hitToSourceDistance);\n        shadowRays[shadowRayIndex].d = hitToSource;\n        shadowRays[shadowRayIndex].extra = (int2) (0xffffffff, 1);\n\n        // Calculate shading values.\n        float3 energy = (1.0f / PI) * hitMaterial.scattering * max(0.0f, dot(hitNormal, hitToSource.xyz));\n        energy += ((SPECULAR_EXPONENT + 2.0f) / (8.0f * PI)) * (1.0f - hitMaterial.scattering) * pow(fabs(dot(normalize(hitToSource.xyz - rayDirection), hitNormal)), SPECULAR_EXPONENT);\n        energy *= scalar;\n        energy *= evaluateDirectivity(hitPoint, sources[sourceIndex], directivities[sourceIndex]);\n        energy *= pointSourceIrradiance(hitToSourceDistance, irradianceMinDistance);\n        energy *= accumEnergyDelay[rayIndex].xyz * ((float3) 1.0f - hitMaterialAbsorption);\n\n        float delay = (hitDistance + hitToSourceDistance) / SPEED_OF_SOUND;\n        delay += accumEnergyDelay[rayIndex].w - (distance(source, listeners[listenerIndex].origin) / SPEED_OF_SOUND);\n\n        energyDelay[shadowRayIndex] = (float4) (energy, delay);\n    }\n\n    barrier(CLK_GLOBAL_MEM_FENCE);\n\n    // Generate the bounced ray.\n    if (numListeners > 1 || sourceIndex == 0)\n    {\n        accumEnergyDelay[rayIndex].xyz *= ((float3) 1.0f - hitMaterialAbsorption);\n        accumEnergyDelay[rayIndex].w += hitDistance / SPEED_OF_SOUND;\n\n        float4 reflectedDirection = (float4) 0.0f;\n        if (randomFloat < hitMaterial.scattering)\n        {\n            uint sampleIndex = randomUint % numDiffuseSamples;\n            float3 transformedDiffuseSample = transformHemisphereSample(diffuseSamples[sampleIndex].xyz, hitNormal);\n            reflectedDirection = (float4) (transformedDiffuseSample, 0.0f);\n        }\n        else\n        {\n            reflectedDirection = (float4) (reflect(rayDirection, hitNormal), 0.0f);\n        }\n\n        reflectedRays[rayIndex].o = (float4) (hitPoint + RAY_SURFACE_OFFSET * reflectedDirection.xyz, FLT_MAX);\n        reflectedRays[rayIndex].d = reflectedDirection;\n        reflectedRays[rayIndex].extra = (int2) (0xffffffff, 1);\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Image Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherImage(uint numSources,\n                        global const int* occluded,\n                        global const float4* totalEnergy,\n                        global float4* image)\n{\n    size_t rayIndex = get_global_id(0);\n    size_t numRays = get_global_size(0);\n\n    for (uint i = 0; i < numSources; ++i)\n    {\n        if (occluded[i * numRays + rayIndex] < 0)\n        {\n            image[rayIndex] += totalEnergy[i * numRays + rayIndex];\n        }\n    }\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Energy Field Gather Kernel\n// --------------------------------------------------------------------------------------------------------------------\n\nkernel void gatherEnergyField(float scale,\n                              global const float4* totalEnergy,\n                              uint offset,\n                              global const int* occluded,\n                              global const float* shCoefficients,\n                              global int* energy)\n{\n\t// The number of global work-items for this kernel is #rays * #bands * #channels.\n\t// The number of local work-items for this kernel is #bins * 1 * 1. Here, #bins is a compile-time constant.\n\t// This kernel runs in three stages:\n\t//\t1.\tEach work-group operates on a subset of rays, and accumulates their energy into one of multiple\n\t//\t\tlocal-memory histograms.\n\t//\t2.\tEach work-group adds all of its local-memory histograms together.\n\t//\t3.\tThe work-groups cooperate and combine their local-memory histograms into a global-memory histogram.\n\n    uint rayIndex = get_global_id(0);\n    uint band = get_global_id(1);\n    uint channel = get_global_id(2);\n\n    size_t numRays = get_global_size(0);\n\n    bool isOccluded = (occluded[offset + rayIndex] >= 0);\n\n\t// FIXME: shouldn't this be just get_local_id(0)?\n    const int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\n\t// Each work-group stores NUM_LOCAL_HISTOGRAMS histograms in local memory. These are interleaved, i.e.,\n\t// bin i of histogram j is at index (NUM_LOCAL_HISTOGRAMS * i + j) in the buffer. We use multiple local-memory\n\t// histograms to reduce the chance that an atomic_add leads to contention (see below for details).\n    local int localEnergy[NUM_BINS * NUM_LOCAL_HISTOGRAMS];\n\n\t// These base pointers are used in stage 2 of the kernel. See below for details.\n    local int* workItemEnergy = localEnergy + mul24(localIndex, NUM_LOCAL_HISTOGRAMS);\n\n\t// Initialize all local-memory histograms to zero.\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        workItemEnergy[i] = 0.0f;\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 1\n\t// Each work-item processes one ray. If it is not occluded (i.e., it carries non-zero energy), the energy is added\n\t// to one of the local-memory histograms for the work-group. These adds need to be atomic, since multiple rays\n\t// being processed in the same work-group may write to the same bin of the same histogram. The contention\n\t// due to atomic_adds can be reduced by increasing NUM_LOCAL_HISTOGRAMS, at the cost of increased local memory\n\t// usage.\n    if (!isOccluded)\n    {\n\t\t// Adjacent work-items in a work-group do not use the same local-memory histogram. A work-item with local\n\t\t// index i writes to local-memory histogram (i % NUM_LOCAL_HISTOGRAMS).\n\t\t// When calculating the bin index, bin index i is mapped to index  NUM_LOCAL_HISTOGRAMS * i in the\n\t\t// local-memory buffer. This is because the histograms are interleaved.\n        local int* shiftedLocalEnergy = localEnergy + localIndex % NUM_LOCAL_HISTOGRAMS;\n\n        global float* rayEnergy = (global float*) (&totalEnergy[offset + rayIndex]);\n\n        float time = totalEnergy[offset + rayIndex].w;\n        uint bin = convert_uint_sat(floor(time / BIN_DURATION)) * NUM_LOCAL_HISTOGRAMS;\n\n        if (bin < NUM_BINS)\n        {\n            float energyValue = scale * rayEnergy[band] * shCoefficients[channel * numRays + rayIndex];\n            int quantizedEnergyValue = convert_int_sat(floor(energyValue));\n            atomic_add(shiftedLocalEnergy + bin, quantizedEnergyValue);\n        }\n    }\n\n    barrier(CLK_LOCAL_MEM_FENCE);\n\n\t// Stage 2\n\t// Each work-item processes one bin. The corresponding bins for all local-memory histograms are added, and the\n\t// result is stored in a private variable. No atomic operations or barriers are required here, since each work-item\n\t// operates on independent data.\n    int accumulatedEnergy = 0;\n    for (int i = 0; i < NUM_LOCAL_HISTOGRAMS; i++)\n    {\n        accumulatedEnergy += workItemEnergy[i];\n    }\n\n\t// Stage 3\n\t// Each work-item processes one bin. The summed values from the local-memory histograms are added to the corresponding\n\t// bin in a global-memory histogram. Here, atomic_adds must be used, because multiple work-groups may be trying to\n\t// write to the same global-memory bin at the same time.\n    atomic_add(energy + channel * NUM_BANDS * NUM_BINS + band * NUM_BINS + localIndex, accumulatedEnergy);\n}\n\n// --------------------------------------------------------------------------------------------------------------------\n// Reconstruction Kernels\n// --------------------------------------------------------------------------------------------------------------------\n\n#define ENERGY_THRESHOLD            1e-7f\n#define MIN_VARIANCE                1e-5f\n#define NUM_WORK_ITEM_SAMPLES       32\n#define WORK_GROUP_SIZE\t\t\t\t64\n\nkernel void applyIIRFilter(global IIR* filters,\n                           global float* impulseResponse,\n\t\t\t\t\t\t   uint numBins,\n\t\t\t\t\t\t   uint samplesPerBin,\n\t\t\t\t\t\t   uint numSamples)\n{\n    size_t band = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t numBands = get_global_size(0);\n    size_t numChannels = get_global_size(1);\n    size_t batch = get_global_id(2);\n\n\tlocal float localSamples[(NUM_WORK_ITEM_SAMPLES * WORK_GROUP_SIZE) + NUM_WORK_ITEM_SAMPLES];\n\n\tconst int localIndex = get_local_id(1) * get_local_size(0) + get_local_id(0);\n\tlocal float* workItemSamples = &localSamples[localIndex * NUM_WORK_ITEM_SAMPLES];\n\n    global float* signal = &impulseResponse[(batch * numChannels * numBands * numSamples) + (channel * numBands * numSamples) + (band * numSamples)];\n\n\tfloat xm1 = 0.0f;\n\tfloat xm2 = 0.0f;\n\tfloat ym1 = 0.0f;\n\tfloat ym2 = 0.0f;\n\n    global IIR* filter = &filters[band];\n\n    float a1 = filter->a1;\n    float a2 = filter->a2;\n    float b0 = filter->b0;\n    float b1 = filter->b1;\n    float b2 = filter->b2;\n\n\tfor (uint i = 0; i < (numBins * samplesPerBin); i += NUM_WORK_ITEM_SAMPLES)\n    {\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tworkItemSamples[j] = signal[i + j];\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tfloat x = workItemSamples[j];\n\t\t\tfloat y = (b0 * x) + (b1 * xm1) + (b2 * xm2) - (a1 * ym1) - (a2 * ym2);\n\n\t\t\txm2 = xm1;\n\t\t\txm1 = x;\n\t\t\tym2 = ym1;\n\t\t\tym1 = y;\n\n\t\t\tworkItemSamples[j] = y;\n\t\t}\n\n\t\tfor (uint j = 0; j < NUM_WORK_ITEM_SAMPLES; ++j)\n\t\t{\n\t\t\tsignal[i + j] = workItemSamples[j];\n\t\t}\n    }\n}\n\n// todo: linear reconstruction?\nkernel void reconstructImpulseResponse(global int* energy,\n\t\t\t\t\t\t\t\t\t   uint samplingRate,\n                                       uint samplesPerBin,\n\t\t\t\t\t\t\t\t\t   uint numSamples,\n\t\t\t\t\t\t\t\t\t   global float* airAbsorption,\n\t\t\t\t\t\t\t\t\t   global IIR* filters,\n                                       global float* whiteNoise,\n                                       global float* impulseResponse,\n                                       uint offset,\n\t\t\t\t\t\t\t\t\t   float scale)\n{\n    size_t bin = get_global_id(0);\n    size_t band = get_global_id(1);\n    size_t channel = get_global_id(2);\n\tsize_t numBins = get_global_size(0);\n    size_t numBands = get_global_size(1);\n    size_t numChannels = get_global_size(2);\n\n    global float* impulseResponseBin = &impulseResponse[offset + (channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n    global float* whiteNoiseBin = &whiteNoise[(channel * numBands * numSamples) + (band * numSamples) + (bin * samplesPerBin)];\n\n    float e0 = (float)energy[0*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n    float e = (float)energy[channel*numBands*NUM_BINS + band*NUM_BINS + bin] / scale;\n\n    if (fabs(e) < ENERGY_THRESHOLD || fabs(e0) < ENERGY_THRESHOLD)\n    {\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = 0.0f;\n        }\n    }\n    else\n    {\n        float tMean = ((bin + 0.5f) * samplesPerBin) / samplingRate;\n        float tVariance = MIN_VARIANCE;\n\n        int sample = bin * samplesPerBin;\n        float binEnergy = 0.0f;\n\n        float t = sample / (float) samplingRate;\n        float dt = 1.0f / (float) samplingRate;\n\n        float g = exp(-((t - tMean) * (t - tMean)) / (2.0f * tVariance));\n        float dg = exp(-(dt * ((2.0f * (t - tMean)) + dt)) / (2.0f * tVariance));\n        float ddg = exp(-(dt * dt) / tVariance);\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] = g * whiteNoiseBin[i];\n            binEnergy += impulseResponseBin[i] * impulseResponseBin[i];\n            g *= dg;\n            dg *= ddg;\n        }\n\n        float normalization = e / sqrt(e0 * sqrt(4.0f * PI));\n\n        normalization *= exp(-0.5f * airAbsorption[band] * SPEED_OF_SOUND * ((bin + 0.5f) * samplesPerBin * (1.0f / samplingRate)));\n\n        for (int i = 0; i < samplesPerBin; ++i)\n        {\n            impulseResponseBin[i] *= normalization;\n        }\n    }\n}\n\nkernel void combineBandpassedImpulseResponse(uint numSamples,\n                                             global float* bandImpulseResponses,\n\t\t\t\t\t\t\t\t\t\t\t global float* impulseResponse)\n{\n    size_t sample = get_global_id(0);\n    size_t channel = get_global_id(1);\n    size_t batch = get_global_id(2);\n\tsize_t numChannels = get_global_size(1);\n\n\tfloat value = 0.0f;\n\n    for (int i = 0; i < NUM_BANDS; ++i)\n    {\n        value += bandImpulseResponses[(batch * numChannels * NUM_BANDS * numSamples) + (channel * NUM_BANDS * numSamples) + (i * numSamples) + sample];\n    }\n\n\timpulseResponse[(batch * numChannels * numSamples) + (channel * numSamples) + sample] = value;\n}\n
/3W<HF
/49J
/6;eg
/7^94L
/8"LX
/9#9C
/9mW
/:AZq
/:aIf
/:gzD
/;'Wr95B
/<C0x
/<sGM
/=828
/G:CX
/K5<8
/Ki8
/Lx9*
/OR7
/Pz<s
/Qh9)
/R9f
/S<dxU
/T8s
/U;ob
/WF9
/X|8C
/a5;hE
/b9G
/b9i0x
/ge;C
/h0<S
/ka=d
/pp;0E
/r;9Tr
/s<zde
/u9Gv
/uE:4Z
/xG9*
/y;jh
0!\v4f8t4b<
0"q8
0#;M9
0'7W
0+<5o
0-based array is turned ON
0/8;&jt
00<M
00<O
00o;
0123456789
0123456789-
0123456789-+Ee
0123456789ABCDEFabcdef-+Xx
0123456789ABCDEFabcdef-+XxPp
02;b
02<6
02<N`N
02=1
02x<
03<;D
03=b
03{;m
042<
045>,D
05(:K
05:z
05;N
05;R.
05V;
05r;
06<\vu
07T:R
07Vi
086<
08Y;zQ\n<+
090;
09;z
09G|\t;i
09Mv
09az
09hD1
09j4
09kP\n;
0:09
0:<q6r
0:CA
0:CT
0:DJ
0:Ps
0:Yk
0:^U8
0:b0
0:eb
0:gi
0:qK#
0:qg 8
0:ze
0:zh#;L
0;1j
0;41
0;9E
0;B1
0;BY?
0;C8j8
0;Eq
0;Gu
0;JJs
0;Jp
0;R/y
0;_7C
0;cC
0;gL
0;gi{
0;hLw:*
0;iZ-:X
0;nU\r;f
0;nn
0;u8$
0;vn2:
0;xCg;
0<4xS7
0<>gG
0<Aa&
0<Av
0<Hq
0<Q2
0<\to1
0<cmJ
0<dV
0<eF
0<jI
0<ja
0<s4
0<xA
0<yng
0<zU\r
0=<ZN
0=sI;
0=sd
0=ue
0=wC
0>.I5
0>H8B=!
0>L8
0>RE
0>VM\>D
0>iv
0>x;D
0?K;1F
0@>1j4
0A6<
0A7;
0A;b
0A<|o
0B;Q;
0BP<
0BQ;
0C7;
0C8t
0D8=`
0D<F{
0D<q
0E:q
0E:z
0E|;Ox
0F<Z
0FV:6
0H+=i
0H<b
0Hq;qj\v
0J;F
0J<i7
0JV;\f
0K:y
0L:p
0L>S
0Lf8N
0Ll;
0MG;
0N;shY;
0Nh;
0O:e
0O;P
0P<D
0Q<V
0Qe:n
0R:;xW;
0R;4
0R;v
0R=Z
0S,;iJM
0S;\tw2:
0S>9
0SB<[
0U;N
0U;i
0Uf;:
0V;7
0V<v
0W:20
0Wu=
0X;Hy
0X;N
0Xh:u95;
0Xi;=
0Y:6
0Y:p
0Y;:N
0Y>q
0Z;C$
0Z;}e
0[s9
0\2<z
0\rD;0
0]w;f
0^;MzP:Q
0_:7r5
0b:1
0c9\f1
0c;Uw
0c;{w
0cW:
0df=
0dy=
0e:c
0e:r
0e\9f
0es;
0f9b
0gY;
0gt;`
0h:p
0h<nBp
0hU<a}
0hX;\t
0i<h
0il;x
0it;M
0jG;
0kn9
0lu:
0nt=
0o;J
0ou; 
0p9\n
0p:qK
0pU;
0q:}M
0q;C
0q;e
0qW=q
0qk;
0r;g
0s<w
0sh;K.
0t;n
0u;6B+<
0u<5
0u<:3
0u<d
0u]:w
0x%I64x
0x6;
0y<2\r6=
0z7=
0z:sO
0z>U
0zD;wD
0{1:p
1!n9
1%;tB
1':Il
1(G;X
1)9O
1)C/I
1+S;T
1-8=M8I
1-;zG
1-based array indexing is turned ON
1.0;o
1/8S
100.0f * cache_hits / cache_accesses
10l9
119[V,
123;(
12h;@
13*8
13,<j
13o;
14;&Q
14;DJ
14=zn
14f<
157<
159r
15:g7E:
15N;
15T<
16:h
16;A
16m8
17h;
18H\n
18Ir
18P]
18\r=p
18e=
194-
195<
199W|;%
19?3
19a&
1:2NV
1:2U\t
1:9m
1:Bt
1:H4
1:Hp(
1:MZ
1:Uf
1:m;3
1;+3U
1;2q
1;3]U
1;4`0
1;7t
1;9KP
1;>h7
1;Lq
1;NJ}
1;Nz
1;Or)
1;PU
1;Uu
1;XQ
1;bh
1;jh
1;n\vb
1;pA
1;pOe:f
1;qV
1;u{f
1;xE
1;xS
1<2M
1<51
1<6 T
1<IQ
1<IZ
1<MI
1<PG
1<PR
1<gK
1<gR
1<h.B
1<iP
1<nb
1<yj
1=9D
1=9nn
1=Ha
1=YF
1=[xE
1=b8
1=z9
1>Ha
1>P8
1>c\v8>gp
1>lK
1>vER=
1>yqm
1?JYY
1@t;2
1B/E
1B6;
1B9w
1B=Y
1BLQXC?l
1C;pW\n
1C<ID\r
1C>1
1D:U
1DZ<jF\n
1E4:
1E<Y
1Ec9
1F;B
1F;F
1F;O
1FW:C#
1G3;yWY:
1G;J{f
1GT:
1H>qJ
1I7;
1I8e
1Ir;
1Iw<C3?
1J9rt
1Jk;
1K2<m
1L9O7n8
1M=K
1N;\fQ
1N<p
1NM:M
1O9V
1P2;
1P9\t
1P;b
1Q:ay~:
1RF;
1RI;
1S5;:
1T'::1q
1T;=}88
1U:FK
1U:K
1U:h
1U;o
1Uh;T
1V";Bw
1V9)-
1V<3
1Vl;
1Vl;/
1W1;
1WD<t
1X4;2
1X;y
1X<T6
1Z:7
1[9T
1\>14C
1\n6;s
1\t;mo
1`Cy
1a&:M
1bO;d)
1bm;
1bu8
1c;0
1c;D\n
1d<r
1d=;A
1dV;o
1e<v
1f*8
1f<K
1f>f
1gV;i
1i{:P
1j6;
1jx;5
1k:5
1k<x
1kG:y5
1l;O
1m;(g
1m><uE>
1n:2N
1n;O
1o<G
1o<Q/
1oc;
1p;a
1p;x
1pX<
1q=G
1qJ<
1qS<
1r$;A
1r;Q
1rd>y
1sH=
1sL;
1t;j
1t=w
1u:i
1u<8
1u`9
1vJ9c
1w:d
1wX:<n
1x97
1y;6
1y<f
1zq:
1{S;c
1{q;kq
1|U;eG
2!:Xs
2"A:j
2"y;a
2#;PN
2#;xB
2$Jd
2(X<i
2*iZ
2+=-tG=br
2,S;TS"
2-=Zp
2.8OVd
2.=jiD=
2/x;Oq
20240722
20:W
20;P2
21a;?H8:6
21l<I
22:RNz
22<f
23=D
25;K
25a;
25h; 
25z:
2638
26I:
26K;$N
26u;
27=W
27O;P.
27i:
28&*7
28<M
28p;y
28v:
29&V
29&b\f9 
291\f
295S
299x
29@l
29Vb
29Y;
29[yi;
29i:
29iB
29r:]
29wa
29xc
2:495
2:6W\v:3
2:=jb
2:=uG
2:CJ
2:Ce
2:Ea
2:IH
2:L`o9L
2:Wf
2:YFk:k::
2:aw\t
2:b=m<f
2:gDx
2:ky?
2:mb
2;0a
2;266
2;8h
2;9G
2;A9T
2;Bi
2;Bx
2;CV
2;C\vx
2;F2r;P*
2;Fi
2;Hb
2;Jv
2;Mv
2;O9P
2;Qq
2;Sr
2;TiJ83CR;
2;V9
2;VK
2;arX;
2;bJ
2;cC
2;fU
2;h@s
2;jV
2;k5
2;pD
2;r5
2;sNL;
2;w`Y
2;yT[
2<"HB
2<46m
2<6r
2<=90
2<Bh$
2<Eu~
2<HZV
2<Hs
2<Ky0
2<PR
2<Rz
2<au
2<bq&
2<yR8
2<ye
2<zc
2=73
2=9p
2=QJ
2=cyS
2=iQ
2=no
2A;/A
2A;sZ\v
2AE:|
2Ao;S
2B4;
2B59
2B82
2B:;E
2B;8
2BN;
2B\n;A
2B`z
2Br3
2C\t9U=
2D;o8
2E=82R<d
2Ee<pI8
2Ej;?l3
2F;}4
2G:9
2G<m
2Gh<
2Gr;
2H9;
2I7<
2I;"bA
2Ip=
2J:Q
2J;gP
2Js;~n
2Jw;r
2L;m,
2M;4\r
2O5;\f
2OV=Z
2P:p
2P=7
2Q;rf\r<
2Q<Cc
2Q=ve
2Qy<C
2Rc;
2S:l
2Sq;
2T<*G
2TK;>nE
2T~:CS
2V1;(%v
2Va=
2WO:
2X>6
2Y0<o
2Z;9w
2Z<C
2Zl;
2[9h
2\f<13
2\f<1W
2\fe<g
2\n8<8
2\nx:s
2\r;pQ
2\v<ae
2^i<0
2`X9
2a;mV
2a\r9I
2a\v:)YD
2al:
2b'>Q8
2bu<_
2c<m
2d9m
2d:x
2dM;<
2dh=(X]
2f:w
2f<w\r7
2gv=
2h9sp?
2h:J
2h;4
2j;WL
2j<C
2jP;3hN
2l>qQ
2lx:z
2n;1
2o2;
2oj;/
2p;V+n
2p</MT<
2pU;
2q:7
2qh:
2r8!
2r:H
2r;q
2rq;x
2sm;
2t:I
2u+=O
2u:p
2v99
2vA;
2vJ;
2wx:rd
2x0=
2x9l
2xNEON
2xNEON 
2xS:
2xT=
2xd<
2yD<G
2yY9u&U
2z9Z
2z|;D
2{=sS
2{A\vDcC
3 7D
3 ;4T
3$8O
3$m<3
3%#90
3%8t
3%I;wDb
3%P;Ul
3(;s3
3)a>3)a>3)a>3)a>
3)a>3)a>3)a>3)a>3)a>3)a>3)a>3)a>
3*V<gL
3-:MPN:
3-d>R
30<J
319c
31;d
31;w
32-bit integer overflow problem
32Y;
333333
33:T#
33?A{
348a
34:Q
34B6
34Y=
34j<0
35i<sC[
35m;.
36;3\vR:
36E5
36\r=H
3790
37c;
38";r
38$Dk9
38(3q;
38;qwZ>)
38<l*
38<u
38HJ
38[8
38]9
39&W
39-B
395n
396js:
39C:
39HlA
39Na
39\tY
3:6ek
3:E{O
3:JpV;l\v
3:MTC
3:X3
3:fv
3:kC
3:nu
3:}3w
3;%y9
3;&4Y
3;/sA
3;1T
3;3A
3;6K
3;:HF
3;BR\
3;E\fM
3;Eh
3;T7
3;TW
3;Tu<
3;Xy
3;atH
3;b%C
3;j5 
3;nb
3;oY
3;s2
3;seU
3;t9B
3;tJz
3;tS
3;xg\t
3;{aD
3<3X
3<8b
3<Be
3<F,0
3<JT
3<TY
3<UF
3<V5
3<Za
3<c|y
3<d,U
3<dv
3<l0
3<py
3<t8
3<tId
3<y8B:
3=36
3=7D
3=D3
3=\fpZ
3=aV
3=iZ
3=kRq
3=n5
3=se
3=xjQ
3=xs
3>39
3>4A
3>\fc1
3>\ttu
3>_cV
3>fW
3>sW
3A;XI6;=
3Ah:M
3B$;E
3C3<
3C9P
3D;z
3D<s
3D=;l
3Da=
3E:t
3E<tF"
3EU;
3F:N
3F<wv
3G8;
3G8;}
3G9|(
3G;V%
3GV;VL
3H<5W
3H<T
3I9)ZZ:
3I:OP8;
3I@=P
3IG:
3J<;m
3Jg;d*>
3K:E
3KY;
3L:<h
3LA<n,
3LE<E
3LI=_
3M:R
3MC:
3Mb;
3N"9%
3N9d
3O:y
3O<qoW
3OIX:0w*:\f
3Ob;
3PW:
3R9)1
3R?I
3SM;
3Sk>r
3T8#
3UW;z
3UZ;
3V:.f
3V;G
3W;I
3W<d
3Wl;
3X9{o
3X<5
3Y;X
3YY:4F
3\99
3\:60
3\f;Lc
3\fW;T
3\r<p6L
3\v8CH
3a:8L
3a;8
3a\n<ZB
3b*<G
3b,;V2
3b;W
3b=F
3c*:"u09\n
3c,:KF
3c5:
3c;u
3da;
3eG<rb
3g;C
3g;g
3g\<M
3gv;
3hZ;
3h\n9
3i4;
3i;\tJ
3iB;
3ii;
3j;?g
3k:.R
3k;'N4
3k>Sgq>
3kU;L
3l1>
3l:D
3ld;R79;
3m;g
3m<J<
3mo=
3mo=EX
3nk=
3od=,
3p<0^
3pF:
3pa;
3pb=
3pm<~
3r:HX
3r=:WB
3s5<T
3sW;
3u5<
3ud9"
3v9\sZ
3wM<
3x;T{
3x>l
3xV;
3z<e
3zV<
4 97
4%V<2u
4(H:Y
4+N87
4,;Tf
4,<}K/;y'F;V
4.4.0
40:m
40;2
40<5
40<Y
40<k5+
40O;
40f<
419|i
41;qI
41<zgE
41>le
41V;
429m
42;YAg;
42<6\r
42<Ld
42B>F
43:~k
45:b
45:e
45;H@
45X9.H0
46v#
46|;0
475=,
47<,Z
47F<
47c#
48"o
48;7v
48;U
48;v_
48<z;
48a\
48c7,],
49%J
49)F
49-Qz
490!
496&
49>o
49A%)
49El
49I@
49W9
49hky
49l.l
49u O
49xs
49y#
49z;@
4:0F
4:1Pw
4:7U
4:FN!
4:Hm
4:KJ
4:KLl
4:XT(
4:bF
4:mC
4:nF\
4:oM
4;6C
4;81
4;FV
4;Lv
4;OB
4;Xu
4;Yx
4;[AE
4;eC
4;eH,
4;ep
4;hK
4;i1
4;mA\n;Q
4;mh
4;pj
4;t }956
4<-N2
4<4;Zv
4<?Ge
4<G0
4<YP6;+
4<]i7
4<fRq
4<gH
4<lO
4<nN-
4<nc
4<o>q
4<vQ
4=%om
4=6z"
4=HH3<
4=YTl
4=aG
4=d5
4=ib
4=lFp
4=nU
4=wT
4=xM
4>3RO>
4>9A
4>Cs
4>PQ
4>^M9
4>iy
4AF:
4Aj;H
4B9e
4B:)L
4C*!3
4C;X
4D3=!
4E9=&
4Er<
4F:v;
4G3<%E]
4G:p5
4Gp9
4Gu:
4H;u
4J;X
4JB:
4K;m7
4KC:
4L=L
4M*<e
4M8Y?6
4M:b
4N8=C~
4N;_4
4NH9I
4O?f
4OV:
4P8<
4R):wv
4R9\v]5
4R;SK
4R<K3"
4RJ=
4T:a
4TB<3
4TC:&
4U<C
4UZ>f
4V;Y
4VR=
4Vc70d 
4Y3:
4Y9;
4Y;t
4Yn>
4Z&;E
4Z9%
4Z<,B
4Z=3x
4ZC<
4\2Z0
4\fM9
4\i7n#
4\t<QU4
4]4<1
4a;o
4b6 
4bL<dM
4b]9
4cW;d
4d9#
4d:G
4d=j
4dz;
4e8f
4e:t
4eH;
4f;D
4fg<a
4g;v
4g<B%
4g<k
4gm;
4h:oW\v
4hG<"0
4i9CdS;{
4j;Q
4jV;>
4kn:
4l;8
4mH;:
4mL=
4mP=\n
4o:o
4oW<
4p:9
4p:jCH;y
4p=N
4po;V
4q:1
4q<+3U
4q=O
4qK>
4sT;
4t;3u\n
4u9Ig/
4u;i*
4uw:
4v=t]
4vy:j
4wH;
4xt;
4|6f:
4~L>c
5$P9
5%9ZKK
5%F9
5&;i8
5(96N\r
5(:bB
5)m:F^k
5+;ruL
50;m
519x?
51:`k
51:sk"
51I=y
51q:
52<V
53Y:,
54;Djp
55;Z
55=w
55t;
56*;n0<
56;Z
56<E
56<P~
56<g
56G:D
58:Y
58;y
58;|w
58i;
58l=
58tu
599c
59<q
59=I
59K9
59P 
59U<
59Y\n
59Z;
59ZEz:
59a=
59e7
59f<
59o@
59x^
5:%86
5:24
5:2z
5:PAY;
5:cz
5;6\r4:u
5;9Gx
5;B\c9
5;Ng
5;Ov
5;RRM
5;SV
5;T3\
5;VL
5;XK
5;Y`a
5;[fG
5;c7
5;cw3
5;e5X=L
5;kR
5;kc1<4H
5;m7
5;mW
5;n4b:\n
5;om
5;qty
5;r\vb8hr
5<#pD
5<24
5<8o
5<=FR
5<Au
5<BO
5<FE.:TP
5<Kl
5<Mq
5<Uu
5<Y_T
5<Z/X
5<ay]
5<bA
5<e+L=H
5<eB0=
5<h4
5<xH
5<xr
5<z+g
5=8I
5=G;Q
5=RY
5=TU
5=mN
5=ww
5=y%3
5>B9
5>De
5>Hq
5>Wy
5>cQW>
5A<w
5Ai<
5B9!
5C3=f3
5C5<
5C;s
5CU=
5D0<dr\f
5D;J
5D;r
5Dc;
5E>haR><
5Ei<4
5FB;[J
5FM<5tE
5Fj;q i
5G;q
5GJ:
5H;RJ
5H<Z
5HG:u
5I;I
5JX:
5K;9
5K<dX
5K=3
5L;U
5Lt<
5Lv;E?{
5M;j2\f
5Mr;
5N9t.y9
5NC<Dz
5O+9
5O:w
5ON9
5QQ\r7
5R8;>
5R;2
5R;D
5RC9!
5S9[
5S;T>g:0
5S`9
5Sd:2
5TK;c>d
5U9+y
5U;C
5UC7
5UN;
5Uj<
5V9;4:
5V;'di
5V=Po
5V>t
5V[:8
5WL;
5Y!9
5Y;:8
5Y=Q
5Yi:
5Z;pV
5[9m
5\f4:T
5\t9e
5\v7x6\v.h7\v%tx
5\v8x6\v/h7\v&
5\v;hag
5_;pE
5a7;
5a;4s
5ag:Z
5b691n6
5c4;
5c:Q
5c:vu
5c;U
5cI<S
5cQ;
5d:^b
5dh:
5eI<
5f:4$
5h4;
5h5<d
5h:4
5h>n
5hd:
5i';G
5i<i\
5j.<O
5j5;
5j:'v
5jr;
5k":d
5k:h
5n:"f8
5n<<99Q
5nO;
5o< I
5oC<
5p8PP
5pME:i
5pt;
5qB=g
5qm;
5r:Q}4
5rv;S
5s0;B/
5t9{
5t;9
5t<>k
5t<j
5t=>9
5td<
5u%y
5ul:
5ux<%
5v:1
5v=r
5w;J
5xA9E_]:
5xF;+gE
5xa;E
5yY<
5z(<S
5~t;X
6 9od
6 xy
6!x<0R
6"9U
6$E5
6%<L9
6%<sR
6';pIY:
6)c\t9
6+nK
6,;vV
6/do;
60Cy
60N;
60\ry
61f;\tMK
62u=
638z
64);Y
643:
64:Y@
64c=
65K<
666<jHv;
66;3
66;M
66=w
66?:e
66wW
67f;
67i:B
68;l
68P9
68\no[
68^dh<f\A<2
69<n
69K>,
69dx\r
69k=
69}7
6:9p
6:9r
6:C8*;acy
6:CI1:
6:Dhi
6:Ig
6:Lx
6:Vr
6:f?0
6:fi
6:iSB:V
6:m0
6:ph
6:scM9
6:wB
6;!Iz;p
6;17
6;9e
6;Eq
6;FR?
6;Fj
6;GB
6;G~G
6;H3
6;H5
6;J{p
6;Pq"
6;QH5
6;QJ
6;QQ
6;Vs
6;Vy
6;aS
6;kY
6;m/A
6;m5
6;tf
6;ti
6<'(4;nAK<[
6<,|n=XQ1=3Y
6<4wJ
6<82
6<CI
6<EN
6<LC 
6<Nz
6<Pc]
6<Pr3<
6<R`a
6<SW
6<T(w
6<V8b
6<WS
6<Xd
6<Yk
6<Zk
6<aD#
6<hi$
6<iD4
6<i\tg
6<tP
6<xB
6=3D
6=4i
6>bH
6>pl
6?<Vj
6@0y
6@1<8
6@1y
6@2y
6@3y
6@9h^
6@;dV
6A$:r
6AB+
6AP:
6AV9
6B0z
6B;Q
6B<r
6C4<
6C=p9
6CV;
6Cd<
6Cr;
6D=X
6DK<]
6E4<
6E6;
6E:Eo#;
6E=o
6F9<
6F;Dd\t
6F}9\t
6G3<n
6H:a
6H<=Y
6HE;
6HT:
6Hn;
6I;uBV;
6Ix=5#
6JU<
6K>9
6KL<
6KP<m
6KT;
6L<9
6LG:
6M3<
6M<6
6M>5F
6MC`
6MR;{
6N;\nx
6No;
6O;o
6P,y
6P224>0D&F
6P5y
6P6y
6P7y
6P8y
6P9<
6P9y
6P:y
6P;&t
6Q:@Y
6S1z
6S7=
6S~D
6V;J
6Vb;
6Wa:
6X;X
6Xe=
6Y;j
6ZN;
6\;VX
6\niP
6\rd;7
6\t5;a
6\v;r45
6\vfQ8
6]=D4
6`9Q
6`Ay
6`By
6`Ly
6`tl:hO
6a7z
6a8I
6a<ww
6aR;5
6akA
6bB;n^;
6bM=
6d2(;
6d;4
6d;w|
6d;z
6d<HMr
6dQ-
6e;vu
6e=x
6eF<
6eV;
6eZa:
6eu9
6e}:}Ru:t
6f9'
6f9\fw
6f:5
6fG>
6g$*9
6g=$Y
6g\rH
6h:p
6i8:
6iB|
6iZ<vb!;
6jG<,Q"
6k0;H
6kR9
6kY=t
6ko;T%
6l:x
6l;c\f
6m=z
6mZ<DgJ
6n2:
6nB;r\v]
6nh>
6o,9
6o4=
6o:B
6o;K
6oh;\f
6p4y
6p7MOf
6pR;0
6q;fUR
6q=*s
6r8"
6r9 5
6s>c
6t;>4
6t;C
6t<o
6tX<\v21
6u+z
6w9()
6w=0
6w?X
6x:i
6x<Q\nX
6z<4
6zN9
6zz<c
6{9O
6}k9X
6~0i
7 8Q
7 9j
7!u9z
7"9l
7#<yj
7$Jm
7&Rn<
7&n>h\fn
7(9v6
7,8i
7,gJ
7/AG
705u
70:Y@4:I}
70;lH
70?Hz
70S=
70hD
70sm;
70t9
71=p
71J;?
72%;s
72-<f
72r=AY
73&;Y
747<
74V$
757;
75<8+
75<\nA
75=v
75AJ9\n
76:q
76<G
76\v9>
770:
77;tc
78!h
78=v
78P:
79/R
7909b'
794t
79?G8;%
79Ew
79J\r
79VF
79Xr
79\rYA
79bVt
79bp\r:(L
79dj
79hP>;
79na
79p`
79ts
79vK
79y"8
7: 6J;@75
7:(Un
7:Dvg
7:LR
7:R9
7:\f5s
7:\nn89
7:\nxy
7:d4
7:iR
7:lM
7:s4
7:vbA;
7;&sJ
7;(wV
7;0M2
7;9O
7;B\te
7;CE'
7;EL
7;Ef
7;LG!
7;OV
7;RO
7;VE
7;Xz
7;aU
7;e6
7;eP
7;f0
7;hB
7;lH
7;nI
7;rn
7;s\M
7;xC
7;ym
7<0B
7<0F-
7<AD
7<D?E
7<Fk
7<HO
7<LB>
7<QR\t
7<Qw 
7<dDW=v
7<eG
7<jD
7<kt]
7<w6,
7<}Dw
7=1\nJ
7=MZ3
7=bZ
7=g4
7=lB
7=ro>
7=wRj>K
7>0O
7>28
7>GW
7>J6
7>LS>
7>YP
7>kZ
7>xy
7@T9
7A5c:
7A<f
7AD29
7AP:!o4
7A^J
7Ah-
7B:<E
7B={9
7B_V
7C3<
7C:P
7C;3
7C=V
7E>9Lo=d
7EB<
7F7:
7Fj:
7Fy]
7G0;
7GAs
7H9x\fY
7Ho?:
7I3:
7J5=
7JA;
7LO=
7M;n
7NF79
7O;8
7O;9
7O>Jx
7Op<
7P9;
7P9_1
7PE<
7PR;D)k
7Q;E#i
7Q;P
7Q<F[l
7Q<c
7Qj]
7RE<^
7RIn;
7RP<
7Ri9
7S;`i
7T:5
7T:zS
7U;L
7Vmq:w
7W;Q
7WM=
7WO:
7X:C
7Xd<
7Y+a
7YX<
7Yt2
7Z1|9e
7Z<C
7Z>9
7Zh<
7\r:8B
7\rSV
7\t7J;
7\t;SK
7]5;h
7]99
7]km
7a;e
7ae:%z
7b2=
7bJ;C7
7bR>|
7c9<
7c<l
7cJ;
7cY\n
7d;F
7d;O
7f>5]
7fi9
7gC:
7hdL
7i:lp
7i;g
7i<Y8
7j,<KDa=
7jI^
7jax
7jnj;D
7k<a
7l:g
7lp<
7luh
7m;4D
7m<3
7mH;
7mh:h'
7nJ:
7ni&9N?
7nt;-
7p;f 3;q
7p<<xq
7pAD
7q;8\y9
7ql:
7rc/
7s&<5
7s-i;
7s1<R1
7s;j
7sxV
7ta:
7tq<
7u<NT
7ur;yI
7uzH
7vA@;
7vO2
7vf;AJ
7w+z
7w<N
7x\te
7z4:
7zwy:
7{zc
7}LY
8 V<bz
8!6z
8!G6
8!Ib
8!eO
8"&08l
8"Cg
8"_z9
8#8r
8#HZ
8#Rg
8$0N
8$1A9
8$v2;E
8%t;y
8&#89K_
8&GS9=
8&hW;
8'yr
8(2C
8(e=E
8(y=9
8)fT;
8,3M:QN
8,xe
8-1;r
8.Rs9
8.Y;o
8/;in
8/NG8@
80?A
80G.
80L=:
80T.;
80bK
80hZ
81:\f3
81;*^C9~6B;
81;W
82:D
82AI9
82|L
83,T
833<^
83:aN<;
83;9M:
83A\r:
83ZL:
848&6
849&m
84<HAJ
84>eJ,
84A#
84Ne
84O?
84k=
85;mH
85<g
85<i
85>F
85G<r
85Ig
85jC
86:u6`
86;rJ2:
86>V9\f0
86N!
86^1
86a*;
86u|
86|I
87+C
872P:
873#6
87S~
87f\r
87|C9
88 80
88G;
88Nf
88Sk;_
88X<
88zg
897}:I3G;$/
89;6
89Bn
89H\f
89NL
89R+
89Z6
89\n0w;
89^W
89m8
89p5
89whS<\v
89~n0;h
8:(4J
8:1%Z;c
8:6,:5!m96~
8:7h
8:G4
8:J)9
8:Nk
8:QH:
8:ci
8:dIj:
8:h0
8:kG
8:m(g
8:tC
8:x\vB
8;2C
8;2y
8;4J
8;5P
8;6Y\v
8;BOU
8;Bt::gW
8;Co7
8;Cs
8;Fk
8;Hf
8;IB
8;JV
8;PBA:
8;QFo
8;R4t
8;R5
8;RN
8;Z`j
8;\f=$;q:*=qx
8;b8
8;eB
8;e_H
8;fy3;r
8;jMa:aX
8;mH793
8;xNw;m
8;xP
8;yHc;
8;yf
8;zsM;^
8<'NC
8<08
8<6M
8<8s
8<A6
8<ES5
8<Ik
8<Mh0
8<Oe
8<Sf
8<TYf
8<Vl
8<Wx-
8<XX
8<Z2
8<Z7
8<f<f9
8<kO
8<s?L
8<ss
8=93
8=@lM
8=GO
8=Qsg>^
8=m9
8=wk
8=x$5>Y
8>(D1
8>7Q:
8>D9
8>G2
8>GO:}X
8>ZF
8?5W
8?Gn
8?LH
8?QL
8?Rl
8@HXf
8@Hd;L
8A0*
8A19
8A;?k
8A=a
8A>cS
8ABo
8AIy:
8Aa'
8B+59&pt9
8B0W
8B:m
8B;I
8BC\f
8BJU
8BNK:Z
8BQ.
8BWd
8BXu:
8BYV;N
8Ba|
8Bko9f
8Bq'9
8Bw':
8C&v
8C:p
8Cj;<s
8D;K
8D=V;C
8DM\
8De;p
8DvJ
8ED2
8EoW9
8F k
8F=a
8F]R
8FnO:
8G0;
8G;xT
8GO0:
8GdH;z
8H"k;
8H3;
8H=E;y
8HF7:
8HS2:A
8H\tm
8H_f
8Hg:k
8Hzi
8I@X;
8Ia\n;u
8Ib(
8Ie4:
8Im 
8J:;R
8J:G
8J;N
8JQ>
8J\f<qJ
8J\n0
8KB;
8KnZ
8KyD9
8L$n9
8L=a@
8LT.
8Lg.
8Lrq
8Lx;
8M=9
8MY;+
8M\tb;
8M\v;X1
8MoR
8Mw/
8MwL:
8N;H
8N<T
8N='1
8N>u
8NE;
8NG1:'}
8NS`:iVR
8N_I
8Nf;
8Nh(
8Nr{
8O*;H
8O<Ze
8O=a6
8Ob;
8P)6;
8P9M
8P=R2
8Pc\t;
8Pjm;
8Py;
8QB<
8QU,:
8Qd$
8Qzt
8R"L;x
8R)G:
8R;X
8SZ|
8Sf7
8Sg9
8StL
8T:OS
8T:W
8TAK
8Tc8
8Tco:(
8U9\f9
8U;\ncN;
8U<D
8UK\n9
8UL<
8Uh<
8UtW
8Uv<
8UwR
8V\t1
8Ve.:
8Vk;J_
8Vmq:
8Vn\f9
8Vx;:
8W09
8W2E
8W;2o|;
8W;H
8W;P/
8W@K
8WE\t8
8WG:
8Wq<
8X4d;
8Xah
8Xv:
8Y3<:fc
8Y:2
8Y<M
8Y|I
8Z3:
8Z6\t:m
8Z;O
8Z=2
8ZGc9
8ZP{
8ZT{:
8ZU9
8ZX; 
8[1;9
8[Xl:
8\f8<D
8\f9u
8\fu0
8\n0W
8\nWT
8\tnL
8\tpw9q
8\v?m9y`
8\vph
8\vqS
8^L5
8_0E
8_9"3a
8_UC
8_Vv
8`89\v
8a<8.
8a=W
8aA?
8aE;
8aF<;
8aK;
8a]T
8aa<w
8b(1;
8b0<
8b:#H
8b:c{p:
8b:g-
8b<,Z
8bG2
8bQB
8bS9
8bX^
8b\n7
8bf=`a8
8bwE:O
8c~q
8d1;
8d;k
8d=?9Y
8d=@r
8d?O
8dY=
8e1:
8e:u:c
8e;)K
8e;b
8eJ.
8eY<L?
8el4
8ep ;
8fS6:
8fu\r:
8f}M
8g1C
8gUC]
8gk=
8gnu;!~N;
8gwa
8gz#
8h3<
8h;k
8h\r8<
8ieg;
8j<m:
8jO<
8jP;
8j\r=o
8jdt
8jk;
8k:)I
8kAN
8kSl
8kV<
8kXA
8kqp;H
8kz[91\
8l8\n
8l<\tj
8lA99c
8lvZ
8m+:it;
8m:StY
8m=OSb
8m>G;
8mA=#
8mz^
8n"3:
8n<PnZ
8o4&
8o;Dl
8o;EIJ
8o>v
8p4[;=0
8p6y:\n
8p9>
8pUx
8p\;k
8pb0;S
8q::\tcK:\t"b;
8q<Y_
8r3&:
8r6)
8r>w\
8rx<
8s%L9
8s,3
8s/2;
8s2d8
8s;cW
8t90
8t;e13
8t;l
8tL)
8tR/;R
8tY0
8tZJ;P\tV;E
8u39
8uP+:
8ut}
8u{b;
8v1g9
8v?Q:X
8vH<\vPZ
8vL96W
8w:]C2;
8wMu
8w}e
8x98
8x?I:z
8x_2:
8xs/
8y=D
8yJ4<
8yZ;
8yfi;
8yjG8
8y~Q
8z"J
8z4R
8z7D
8zH=
8zR\t;
8zq(;X
8zr;.
8|FU
8};44
8}LF8
8~;qw
9 Eq8
9 HV;
9 XY
9 Y3
9 sd
9 uD;
9!6N:q
9!Hq:
9!WR:
9!Zs;
9!cC
9!r9:U
9!vc
9!{99
9".E9
9"1Q
9"4;2
9";U1
9"]Q;tY
9"o&8+Pj:4T
9"q0
9#4d
9#Mm
9#b5;
9#tE
9$5B
9$5u
9$NU
9$WK;
9$fI
9%/C9
9%0N9
9%Fp
9%Pk;
9%SP;iO
9%aB
9%kn
9%uK
9%uR;
9%|E9
9&2D
9&73
9&JS
9&K8
9&QC;
9&hY
9&pV
9&wI
9'eA
9'f8
9'sS;
9(8E;
9(Al
9(e;aP
9(qN
9(t1;
9(vX
9)AA
9)H7
9)Js
9)eA:
9*8a
9*ES
9*H5<
9*K:r
9*QY:
9*jQ
9*l|9
9*s<0
9*tI
9*x0
9+:m9
9+B<9
9+NP
9+Y9;4
9+b9;
9+qZ;
9+xG
9,3Q9
9,B0
9,FK;
9,Z8<
9,_W8
9,gt
9,mV
9-0U
9-G1;
9-W\n:Vk69
9-a;V
9-ib9
9-xU:
9.0,9
9.9;6
9.Mt:
9.PR
9.SR
9.Si:
9.ae;
9.dL:
9.rO9
9.}c:Mi
9/'s9
9/5i:
9/CT
9/Pp
9/Q 9y
9/X?9
9/d1
9/gI:
9/hb;
9/}M9u
90-\v8B
90;Hc
90;x
90<5
90=9;
90>l
90AM
90D'
90E.
90f#<0hm
90s*
90sP
90sx;
90t;
90}t
91#v:4
91/H
910<
911\t
915\v
91<?q
91=r
91C-:a
91O'
91TK
91\fK
91m0
91n;h
91w`
92$n9c
92)d
92)h
92)u
924*
92:5
92;b}
92;d\tr
92<T;v)
92>L
92B\r;F
92Gq
92_J8@
92ae:
92i;9d
92sY
92x?
92zp
93>O
93D8;
93M]
93Oe7
93W<;
93n6
93y8
94'W
940f
945<y
949^;2
94:8,
94;H
94Sm
94UT
94\r;O
94ac:
94{e
95#X
95(h9
95)A
95*q
950Y
951\t:J
957g:
95;U
95Cv;
95FM;
95M{
95NP
95Y\t9
95d]
95jk
96#1
96#G
96'V
967A
96:D
96;MC
96<W-
96F,
96K"<i
96VR;v
96X4
96f'
96q:?
96qe8
96t{
97'k
9738;L
9785;
97>A
97@2:
97Q[
97XF
97Zs
97\r; AS
97b*
97d]:=w
97l1
97lk
97z:
98'd
98.B
981O
981h
98F*
98Wdu:
98c6x
98cd
98m:$J
98o,;
98tt: 
98tx
98xE;
98x\t
98xd
98z8.;
99 u9
99,6
991%
99;W
99<1
99<9I
99<V
99<f
99>Q
99Fg:
99Hy
99Kq-
99P8
99\2
99\fu:U
99\w
99_H
99hX;
99iK9
99m#:
99oi
99s\v;
99~N
9:0\fu
9:4.9
9:58
9:8S
9:9Y
9:9s:
9:Dq
9:WD
9:WT\v
9:Wg
9:XV
9:Z9
9:[i59
9:bIm
9:dq
9:lwt
9:rM9vG@:
9:xt
9;0N
9;1y
9;35
9;39;
9;5B$
9;6a
9;7D
9;B0
9;DC
9;HP
9;Jc
9;O2
9;OL
9;Oh
9;R8
9;RK[
9;YB
9;Yk
9;Yz
9;Zr;
9;\va:4K5:`iX:
9;]cM
9;aV#
9;dg
9;eZ
9;ew
9;fD
9;gs
9;jm7<Cp
9;lI
9;n6\v
9;q 8
9;qc
9;qtE=
9;r|w
9;ts
9;vM
9;y7
9;|P;eW
9<)M72
9<1*:F4
9<3X
9<8O
9<@hI
9<H8d<
9<MJ
9<Q4:
9<Sx
9<W64
9<blO
9<gE
9<p5;
9<td
9<vg
9=0R:
9=8H;J
9=;9E
9=Cb
9=Kg
9=q>C
9=x<4
9>8q
9>BF
9>Sg
9>Uj
9>egZ
9>uQ[;Y
9?8G
9?Fb
9?m8:7
9?pk:
9?t7
9@3w
9@4J
9@@Y9ZS
9@I6
9@We:>5
9@XY
9@\nY9
9@lQ
9AC`
9AI\t
9A[7
9A^A9
9A^`9
9AdJ:
9Af\n:
9Ann
9Ar-:{f;9
9Av;
9AvL
9B J:s@
9B$j
9B3h
9BL!:
9BU1;
9Bn=
9BqW
9C9I#
9C9Q
9C<s
9C=rP
9CIB
9CJk;
9CS\v;
9CZ\v;
9C\t6
9C`N3
9Ca)
9Cd\r
9ChM
9Ct"
9Cwj8
9D%W9
9D)5;
9D4q
9D65
9D<-y
9D<8
9D<Q
9DE\f;aUF:
9DJJ
9DOX
9DOr
9DSS:
9DTn
9DUI:
9DYf:
9D\nh
9DbF
9Dfi;
9DgX;STU<
9DsH
9E,E:G
9E6G
9E6V;
9E6t;
9EE.9Y
9EHZ;
9ES9\n5c
9ET[:
9E\r19
9Ebp;]
9El":
9ElN
9Er\
9Ey{7
9F#J
9F$ 9
9F'c9
9F*Z:
9F6=
9F:cJA;
9F>6;
9FA)
9FBv
9FF>\d
9FQ<
9F]a
9F^k9
9Ff%
9Fpw
9FyA
9G$8
9G$U
9G.D
9G7V
9G:P
9G:hO
9G;9
9G<t
9GDF
9GG/:
9GKr
9GZh
9G[M
9G\vS:$f)9
9Gap
9Gg:m
9Gt:
9H7&;1
9H94
9H=A
9H=r
9HH#
9HPu9*ms
9HX.
9H\fr9
9Hjg:
9Hn%:U
9Hp.
9Hz\f
9H}\n:5N
9I$29
9I'N:
9I=d
9IKU;/
9ION: 
9IR!:
9I\fR:
9I\nZ
9I_D:
9J&7:
9J;N3W
9J;e|
9J>t9+
9JHi:w
9J\n'6
9Jb\n
9Ji-
9Jk<jw
9Jp 
9Jr*;
9K%{<0lj
9K-R;ys
9K2#
9K91
9K9;
9K;8
9K=t
9KCH
9KG?;GD);
9KK>;
9K\fP
9KkK:
9Km-
9Kn=
9Kpm
9Kt27
9Kw<!
9K{39
9K~8
9L"N
9L%i
9L*V
9L9V
9L:i
9L<b
9L>bN2>
9LB~
9LD@
9LNv
9L\n7:
9L\nA
9L\rO:
9Lj4;
9Lj\f:
9Lp1:
9Lz_
9L~D
9M"D
9M3M
9M:Z
9MBJ
9MI+;{C
9MO$
9MRR
9Mb:
9Mg<
9Msd87
9MuI
9MxC
9N.o:
9N1e<
9N4&:
9N7w9}G
9NB\n:3
9NIz:G
9NdB
9NkY9
9No4
9Nz);
9O)3
9O4\r
9O5S;q
9O8B;
9O8\v
9O;a
9O<D
9O>k
9OC\
9OIC<
9OR=
9OR[:
9OV.
9Ov\v;
9O|Z
9P1S:
9PD^
9PIQ
9PL)
9PO$:
9PR{
9PSc;Y
9Pa]9(,H9
9Pc5
9Pfa
9Pg\
9Pj3
9Q(3;
9Q(y;
9Q)q:
9Q4:)I6
9Q:?9
9QO>
9QW$;
9QZ)
9Q\fz
9Q\n<
9Q_e
9QcW9q
9Qd8F
9Qv]9
9Qw9y
9R!L
9R#M:
9R-L:
9R0<
9R1B
9R6w
9R;ZH
9RPI
9RX:
9Rbj9
9Rd<
9S3M
9S>K<C
9SB;:9
9SQA
9SYV:
9S\J;
9SjF;
9SlH:
9Ss^;
9Svx
9T1[:}LQ
9T7;
9T9]:x
9TAw8
9TOZ
9TT;
9TV:
9TV\t
9Tc)
9TdK
9Tj1
9Tt<
9Tw>8
9Tz?9
9Tzs;
9T|F
9U2>9
9U;2
9U;6[v
9UD;.
9UO@6
9UUT8
9U[C87
9Uty
9Uu0:,
9V(i
9V)Q;
9V+<j
9V5&
9V:2
9V<7;Kt
9V<9v
9VAE
9VBA;2-+
9VC<
9VL;W
9VN*<
9V\np;
9VfH:
9Vn~;
9Vr`
9W!s;{m
9W6!;x:
9W8@:\R
9WBS:@
9WH\r
9WQ0
9WQ;DV
9WQY
9Wi5;
9WpK
9Wvk
9X.t:
9XEC8Ii
9XH':
9XX+:\t&f;%c
9X\fF:
9X]m:
9X_G
9X`t
9XbH
9XbN:9R#;
9Xg\n
9XoV;
9Y$v:D
9Y&O
9Y(1;bk<
9Y+e
9Y-0:
9Y4+
9YWV
9Y]M
9Z/m9
9Z0m
9Z47<75C
9Z4y
9Z<;Dp#
9ZMd
9ZO5
9ZQK9J
9Z\fB
9Z\rO:
9Zd\t
9Zfc
9Zn0:.
9Zw;>
9Zw};
9Zyd
9[L9:
9[gs
9\:h9
9\Dt
9\\vh94
9\d7
9\e<9
9\f5s:
9\f9Z
9\f:QN
9\fMv:
9\fVO
9\h1
9\n+Y8
9\n6t
9\n7o;
9\nA;v
9\nP9z
9\nXu
9\nez
9\nh_9I
9\nhm;
9\r<8X
9\rBE
9\rbt
9\rg4;
9\rrk
9\t59C
9\t6S;
9\tMM
9\tUZ
9\tXv;
9\tmH<
9\tmW
9\tsH
9\ud9
9\v j9hKU:
9\vFz9v'
9\vG?8
9\vQx:
9\vde:U
9]4C:
9]99
9]:j9
9]o?9]o
9]si
9^AQ
9^I7;
9^bg
9^c4
9_57
9_XY:
9_en
9_n6
9_pa
9`8x
9`Yb
9`rh
9`zk
9a1j
9a;B
9aB3;
9aY <
9a\tQ
9add:
9ag.
9anD;
9ao\f
9aqS;
9as&
9avx::BVH4Triangle4Intersector4HybridMoellerNoFilter
9awY
9aw\t;RA
9ax?
9b!J;
9b(E;
9b/C
9b/x
9b:Cw
9b;nj1
9b<@c
9b@Y
9bFa:
9bH;<
9bHB
9bU\r;
9bZR
9bdt;vCb
9bf\f
9bl-:3l
9bod8
9bs:
9bsU9
9c-d:7
9c-m;A
9c8g
9c;q
9c<7
9cCL:
9cM<
9cN';
9cR.
9c\99E
9ceF
9chw
9cl;
9csb9w
9cxo;
9d4d
9d<d
9dEh
9dT,=
9dU3:
9dcz
9e9O:e
9e=I;
9eH-
9eMd
9eO:;
9eRY<
9eS&
9eUl
9eYV:
9e[W
9ed*
9el:*\i
9en|:
9eo;<
9e|S
9e}j
9f%o
9f.X8
9f9\
9fA0
9fC1
9fKO
9fM;
9fQT:q
9fRI
9f`i
9fa);
9fcw
9fp=:
9fq;
9g(V:
9g1K
9g;O
9gN>9N
9gV"
9g[Y
9g\nc
9geS;
9gf\v
9gfr9|
9gh];
9gky
9gl:
9got
9gt;
9gt[
9gw8
9h 3
9h'R
9h5LH
9h9C
9hG5:f
9hNX;
9hPJ;4%
9hU<?km
9hX1:
9ha\t:j
9hd?
9hix9
9hj]
9hqS
9ht9
9h~n
9i$w9
9i1#
9i3M
9i;6
9i<S
9iL$:-p
9iW"
9ih\r:I
9ii]
9ij 
9il+
9j0\r:
9j4*
9j5\v
9j97
9j;i}W
9jHN:
9jNj
9jX=
9jYL;%
9j`M;p
9jb<<
9jh"
9jh-
9joS
9juU:
9jxt9
9k#r
9k0a
9k3V
9k4<
9k7$
9k7N
9k9=
9k9J
9k=2z
9kC 
9kEX
9kPs
9kV'
9k[P
9kdR;"
9khO9ad
9kvh
9k{I:c$
9l9^
9l;N
9lBU9
9lE^
9lP;
9lPS
9lXJ;
9lXk
9lmP:
9lpA
9ltE
9lv\r
9l}i
9m)1
9m2?<W
9m90
9m;m
9m<N
9mBD
9mK;
9mP-
9mP/:U
9mSy
9mXZ:L
9md\
9mhe8
9mi*;
9mu89+
9mu8;#q
9mwL
9n4\t:T
9nI<
9nP3
9nT":B
9nV)
9n[k
9n\tc
9nd%
9njO
9ntH
9nuo
9nxU
9oE#9{
9oF-:p|V:6
9oP|
9oWQ
9oW\t;
9ob9:
9otd
9otx:7
9ouE:
9o|;967
9p#2
9p3 :t
9pS[7z
9pZ#:
9p]E;
9pa\r
9pd(9
9pfM:(
9phJ
9ps$
9pt%
9p|a:
9p}9
9q(X
9q+B;nn
9q5y
9q7/:
9q9^
9q:Mj
9q;tx|
9qAQ:
9qD*:
9qD<
9qH\v9
9qI!;
9qIj
9qQz:
9qRb
9qY<:
9q\rC
9qcM
9qm\t
9r*P
9r*U;
9r-E
9r0o:
9r<)H
9rAc
9r\ff
9r`d
9ra\t
9rc0
9rcE9V
9rhu
9riI
9rl`
9rx8
9rz:
9s-x:
9s;BM
9sF/
9sGN
9s\vY:n\v8
9s`A;L`
9sh};
9t%K
9t6%;w
9t:qY\n:
9t;i
9tL)9'e
9tUr
9tVK9
9t[g
9t\f3
9t\v96
9te8
9tjr
9tkr
9tlH;
9tm 
9tm]
9u#P
9u-H:
9u4;
9u:3
9u:9
9uOi;]
9uPl
9uS]:
9uve9#
9uy_
9v J;*0
9v)k
9v*q
9v0;
9v9WO
9v=m
9v>Y:
9v>v:
9vH=;
9vM>
9vQ[
9vT8;
9vZ[
9v\fF:
9v\te9
9v\te9%@
9v\vE9M
9v]7
9v_u;h
9vc'
9vg@:A
9w'Q:
9w3/:
9w9;
9w9\t:l
9w;a
9wD.
9wQP;
9wUI
9wa<:
9wg9
9wp*:
9wp0
9x*%:MAB:
9x*h:
9x,<dy
9x9;P
9x=Z
9xQ3
9xk8s
9xkW
9xxr9SYo8
9y&9
9y;9
9yA:B
9yB&
9yI?:r-
9yJQ
9yf 
9ypI;
9y~o
9z E9
9z'3
9z(3
9z)x
9z*k
9z3\v
9z84k
9z9g
9z9|v*
9zCl
9zPl:
9z[U<
9z_9
9zd.
9zh:
9zny
9z}a9
9{ M9Y
9{67
9{6r:u\n
9{8;4
9{W2
9{bt:
9{u09
9{vy
9|VG
9}NA:
9}Xp
9}iT:
9~00
9~D1;d
9~N6:
9~ea
9~j2;
9~n92
: ?x9M5
: float expected
: identifier expected
: integer expected
:!A89
:!AR9
:"bo:JZ
:&DC:th
:'At8
:'Cr;WV
:'dm9
:)iA9
:*3V9
:+S7;31
:+ud8
:,At9J:
:-6t9
:-9r7
:.3L;2V
:.rZ98r
:.v#9Lo_9
:/d49
:0)b8
:00\f9
:0:):Qt/:f;
:0?j:Id
:0Ee
:0Mk;
:0Pj:
:0Pq
:0QG
:0To:@75:
:0YC
:0Yr709
:0\09
:0eJ9
:0lX:
:0uB=
:0uM9
:0zj;V
:10K
:1A5
:1I27K
:1Q9
:1W9
:1X;E
:1ex
:1gt;O
:1j9
:1ko
:1rE;k
:1yG:
:2*69
:21=8
:278
:2Bf
:2Dw:
:2F5:
:2FK
:2GS9
:2\n[:S0e:#)
:2]v9
:2co:
:2ou;
:2r*9U
:2ux:
:2vb
:2xk:F
:2z-9
:3*Z9
:31N;
:39J
:3;kU
:3<N9
:3TR
:3ZI;
:3bp;
:3cg
:3hi:
:3iD:P
:3nP9
:3uh
:3}b;\nCR;eL
:4"T:PD
:4Bx:
:4MP
:4RE>
:4Z6
:4`q9P\r
:4jQ
:4n5;
:4oW<
:4p[7w
:4v8
:4ve;x
:4w1
:522
:53b:
:54F
:5B99
:5B]9
:5By
:5Jp
:5Mc
:5QR
:5Wg
:5kB;
:5qh
:5qq9
:60P
:66F
:67H;
:6<DT
:6C1=
:6Gg;E.C
:6KA
:6O5
:6RK:
:6SE
:6VE
:6aW;
:6kB
:7+u:PH
:7,8r
:71F
:729:g
:72Z
:76Z9
:76o
:7EK:
:7Gr
:7Hl:
:7Ld:I=
:7M0
:7W5
:7W8
:7YB:
:7bh
:7h4<
:7in;
:7o;S
:7oH
:7so
:8)09
:80T
:83l;
:843;
:86b
:87;C
:87W<
:89hd
:8Ms;\fTf
:8Sf<
:8Z8;
:8dd
:8o_9^Q
:8pG8
:8rg
:9/x9l
:91n;
:93;fK
:93R;
:99-9X
:9C99
:9GY
:9HY
:9Ig:Y 
:9JU:
:9QKV;
:9Uj
:9\tV9
:9`F9
:9ax
:9ft;
:9sm8
:9t3
:9yD
:9yH9B
::548
:;1b{9eV&;.
:;BMr:Km
:;BNC
:;q0L
:;yOT
:<Ua;pr
:<V4f
:<xc4
:=0CE
:=JZm
:=RN;Q5u
:>9uZa
:>TJ;Z6
:?Aq:UV
:@Oi9
:A5g;e
:AKn:h
:AM:am:PM:pm
:AMW:
:AOO
:AOV:
:AZE:
:AaI
:Ab6
:Abg
:Acb;
:AmL
:Aq5
:AsG:
:Aua;
:Az1
:AzS8
:B"D8
:B5P;
:B7E
:BBz;
:BIg
:BT6
:Bpt:
:BrI;
:Bri;
:C39|
:C6U
:C7r9
:C9L
:CAF;
:CEc
:CHw
:CI8
:CJL
:CP9
:CR1
:CS5
:CTd
:CYk
:CiR:
:CjB;
:CjO:
:CkK:
:CqY:Y
:Cwu:
:D7m
:D8v
:D9e:
:D=h9
:DEV9*
:DFA
:DJ8;
:DJQ;B
:DL2
:DSp;d
:DTy
:Deq
:DgR
:Dmc
:DpR
:DpT
:DuA:
:DuG
:Dva<R
:Dvc:e4
:Dvf
:Dz1;
:E1I:
:E2m
:E3b8
:E7h9`
:ECC;
:EH2
:EHb9
:EHm
:EZC
:Ebh
:Ee9:
:EeP
:EhS
:EkJ;
:Ev6
:F7A
:F<MU
:FCc;
:FJU
:FL4
:FL_;eS
:FNp;
:FVQ;
:FZ4:
:F\V9^J
:FfZ91
:Fg09
:FhS
:Fjw
:Fml
:Fov
:Fqk:
:Fxt
:FyN
:G 99
:G20=l^
:G8s
:GEG;\rs
:GFo
:GG5
:GOw;
:GWB
:GX$8aQ
:Gk4
:GlQ;
:GoK:
:GvN
:H%B;IM4:G
:H2\t;c44
:H41
:H74
:HFa
:HM2;
:HNG
:HPE:
:HPI
:HQJ
:HQe
:HVZ
:HWX
:HX0
:HYR
:He7
:HeG
:Hn<D
:Ho1
:HpH
:HwC:
:Hw{8
:I(j9
:I3?9
:IBH
:IJ0
:INY
:ITP
:IaX
:IrU
:Itc:
:IvP9
:J s8
:J0k
:J4c
:J5D
:JAj;P
:JB3:
:JD5
:JDC
:JEV
:JGH8
:JGs
:JIu:
:JJU
:JJn
:JLH;
:JPy
:JQa
:JT:wx\t
:Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December
:Jbk9f
:JeT
:Jho
:JlG
:Jnj:.N
:JuG<
:Jua;
:JwH;k5
:Jy2:
:K.Z9R
:K1t;
:K4B
:K7r:3`9:%0
:KBV9
:KIz;
:KPX
:KXD
:KYf9
:K^a9ma
:Klh:Rw|:
:KpI;J
:KwG
:Kz<1fS
:K{A9
:L=j8
:LA^9
:LDA;
:LE:B
:LK2
:LLX;
:LPS
:Lag
:Lbn
:LgM
:LgX
:Lgk<pMm
:Ljr
:Ll2;
:Lpd9
:LrI=
:LsJ9
:LsK
:LsY;w
:LyT:
:M23;
:MF?9
:MOy:O
:MUr
:MkB8
:MlU
:MpU;
:MsS;
:N0B
:N0l;g
:N3u
:N5q
:N7w:
:N9F
:NBr:
:NCL9*
:ND1
:NFt
:NH4
:NNF
:NOp
:NRI
:NSm;
:NTU
:NWg
:NoO
:O!t8
:O(H8
:O1U
:OHS
:OH_7
:OI2;#C#8T9^
:OLM
:OMs9Gr
:OMt
:OYH
:Of ;EKr<
:OsZ;
:Oxb;V
:OyQ
:P1d
:P9W;
:P;29
:PBg
:PM}9
:PQN;n
:PYi:
:PbQ;y
:Pm7
:Pt*9Z 
:Px$9
:PyY6
:Q0h:
:Q2-8
:Q4y
:Q5y
:QAS
:QAy:
:QBV
:QCN:J
:QMU;
:QUW
:QWs
:QXX9l
:QfQ9
:Qgd:
:QhN9
:Qs2
:Qwc
:QyB;
:R04
:R2H
:R9U
:RGI;
:RIk;
:RM6
:RZR
:RZf
:Rfd
:RzK
:S$u8
:S9k
:SHx:
:SK2
:SKo
:SLY:Ca
:SMM:
:Sev
:Sgw
:SmC
:Smc:[oT<
:SoH
:Ss=pM
:Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday
:T1R:3\
:T2E:m@
:T7t;
:T8;3
:TAw
:TH99
:TKJ
:TOn=
:TPw
:TS1
:TSo
:TT.:77
:TVu;
:TWA
:TYj8
:T\fU;Sm
:Tba:Wi
:Tjj
:T~780
:UAC
:UCf9
:UOW9
:UOm;
:UQL;
:USC9)
:UTc;
:UUm;
:UUr
:Ub1
:UoF;
:UsT
:Uwi:
:Uzz:C
:V4D
:VHZ:
:VK7;
:VOF;
:VQ7
:VTR
:Vei;
:VfT
:VkW
:VqA
:VqJ;
:Vr1;
:Vr9
:VsC
:VwF
:Vwc:
:Vyv
:VzO:
:W2f
:W3o
:W87
:W@Y7
:WCv;
:WEY
:WK?;7zx:i4
:WKL:
:WNd;S
:WO_9
:WSg:
:WZp:h9!<B
:Wb0:
:WwE;
:WxD
:Wz+9Sx
:X2Y:
:X5x
:X:9.08
:XL7;
:XMA:
:XNp
:XOy:
:XT,9
:XU5:
:XZQ
:XdA
:Xmz
:XpS
:Xrt
:Y*w9
:Y0<9m
:YD4
:YEt;
:YHb=0
:YLs;
:YOi
:YOy
:YQ<We9
:YTP
:YXB;
:Yi^9
:YmE:
:Yo2:
:YzB
:Z1V;
:Z44
:Z5-;iK
:Z7:M
:Z9F<rti;Q
:ZGG
:ZGz:
:ZRp
:ZWz;nc
:ZX4
:Zda
:ZgC;d
:Zhg
:ZlH:co
:Znk;
:Znw
:Zto;
:ZwX
:ZzJ
:[AX:gex:J
:[od8
:\149
:\D\;k(4;10
:\RM:PS
:\Sw8q,
:\f0U808
:\fic9aaP;
:\nh0;7F
:\r8gM
:\tCI9I
:\vHI8
:\vV9F
:\v|G9RT
:]G\t<]G\t<]G\t<]G\t<I
:]G\t<]G\t<]G\t<]G\t<]G\t<]G\t<]G\t<]G\t<I
:]iU;GA
:^1N;dC
:_fP:zV
:`HX9
:`Qm9
:`jV8g
:aBs
:aHJ
:aSC
:aT0:b
:aay
:acJ
:ach
:acz
:afe
:agp:
:ahJ
:aho9K>\t
:akB
:anV
:ao4
:ath:
:avC;
:az1;
:b(l8X
:b6b;
:bAS
:bCZ:
:bEX
:bO4
:bVf;
:bY5
:bZR;v
:baK
:be0:
:bqK
:brh:
:byo
:b~3;lI
:cBG;
:cUI:
:cYP
:cas:0
:cc0
:cfD:
:clk
:clx
:cq9
:ctt
:czQ
:d1D;
:d2O
:d31
:dCS9
:dCm
:dDW
:dQL9>
:dU:d
:dW4:
:dWQ
:d`89
:dco:
:drR
:dw8<
:e%89z
:e1C
:e6D9
:e:x9
:eED
:eP2;
:eV3
:eYl
:ed3
:eek
:efG;R
:egE
:el6
:emE
:en097
:en8
:enZ;
:enn:u
:epa
:er"8
:es1;<7
:f u:gw
:f43;
:fJV:
:fJV;
:fKJ:
:fNy;
:fY)9I
:fex
:fg0:
:fj0
:fjO:
:fnr;
:fq9
:fwp
:g4k
:g5h
:g67
:g6N:B
:gCS
:gDx:
:gGF:
:gKX
:gOM:
:gXA
:gc4
:ghK:
:guB:
:gvd;>L
:gyU:b
:gzL;
:h-F9
:h-x9
:h.M9
:h00:
:h1M
:h4G
:h4m
:h=c7
:hMd
:hNk
:hdK:3
:hdz
:hek
:hkD
:hoP
:iEL8
:iOK:
:iS9:
:iWN
:iZF;
:ieV
:igP4
:ihf<
:ikh
:ipv
:iqY:
:ivK;H
:iyA
:j1a
:j8D
:j939
:jD3:
:jE/8
:jLC:
:jPj;
:jQz
:jTw;
:jW2;5]Q;
:jaE
:jgE;TY
:jkG
:jpR
:jwS:
:k!d9
:k'M9
:k+g:Y6
:k04
:k3y:
:k46:!S
:k4A:
:k50
:k89;~W
:kEp9
:kF5
:kIH;
:kKL:
:kNH
:kOH
:kQ4
:kQQ:I
:kSi
:kU?8
:kYO
:kYQ;
:kZO
:ka1
:kc3:
:kcZ
:ku3
:kw57:
:l2Y
:l6T
:l7J<
:lBC;
:lHN
:lbS;9bU;
:lfW;I
:lfl
:liF;5F
:ljH;p{
:lnc;
:lpm
:lwV:
:ly5
:m"2;lxO;
:m%o9
:m2G<
:mAg
:mB1
:mGn
:mUi
:mVD
:mWA9o
:mWC:1
:mWT;
:mYJ
:maR
:mcF
:md3
:mjF
:mx::dh89mG
:m~J9
:n2v
:n37
:n6U
:n7T7H
:nBl
:nK5;
:nP9
:n`Z9
:nbP
:nbR
:nbe:
:ngf:
:nnB
:nns:
:nnu;Sl]
:nrn
:o3Q;
:o96
:o9JBD:
:oEW
:oEX
:oVJ
:oc59
:oqV9
:otO
:oxp;O
:oz7:
:o}w9
:o~7:95
:p1i
:p2w
:p5D
:p7u
:p@e8
:pAv:3`
:pBn9
:pDf;~I
:pJe;
:pNR
:pR1<2
:pTy:
:pWH
:pXs
:pb7
:phj:
:pig;
:pr2
:q0g
:q2d;
:q35;bK
:q5-;fW
:q9p
:qN2
:qZk
:qaa
:qiX:S
:qjM;
:qmf:
:r V9
:r?a8
:rFV:J
:rHR;
:rK6
:rN-7
:rNR
:rO|:wv
:rR0
:rTG
:rU9;
:rUG
:rYF;
:r`j9
:rff;
:rp9
:rw5<Rh
:rya
:r{P9
:s/z8
:s2n
:s37:
:s80
:sCo:
:sGG
:sNA
:sSO:
:sgN
:shJ
:sso;2b
:stW:
:svd
:svk9>"
:sx8
:t02:
:t1L9<
:t59
:t7m
:tCU:Y.
:tFv
:tR0:
:tSQ:
:tZJ
:tbG=
:tdP:
:tdo
:thy<F
:tk3;
:tpQ:
:uC39
:uD9
:uDS9
:uFw9
:uJx
:uUT
:uV9
:uW{9
:uXQ
:uib:
:um2
:usC
:uvb
:uw0
:uw6
:uwj
:v0@8
:v;Wr
:vC0:J
:vCN
:vD4
:vHN
:vJ2:
:vLu
:vQU;
:vf+9
:viT;
:vjF:
:vkE
:vpp
:vqw:
:vz3:
:vzL
:vzY
:w11:c
:wEH
:wG0:
:wGB:J
:wLC<
:wNM:>Vk9M
:wT4
:wX7
:wdw
:wjp<
:wko:
:wq2:
:wqu:B
:wrL
:wy1
:x.S9L
:x9W
:xDT:
:xF7
:xOv
:xVo
:xXs<S
:x[Q:xJx;
:xcb
:xh"9A
:xiI
:xjZ;
:xmk
:xo78$E
:xuT
:xwK
:y2o9,p
:y94
:yGm
:yML
:yMb9
:yP1;
:yUl;
:yXh
:y\fy9
:yd7;
:ygr
:yk8
:ypg<9M
:ysI
:ytV;D
:yuS;
:yvG
:yvr
:z h9
:z&j9
:z0a;
:z3a9
:z5D
:z94;
:z9E
:zEd
:zGf:XV
:zHP
:zOn:
:zUY
:zV9:
:zWG:
:zZF
:zcL;
:zfa
:zhX
:zjN
:zjS:6>Q:aph:
:zm?9CD
:zmb
:zn6
:{e99
:{fY;7a
:}a#;f\f<<c3
; M9Q
; a9<4L
; hz;Xz
;"Q2;Wg
;"ys9
;#T19\n"X;&\r
;$b2:ve2
;%9F9
;(2|8Et
;(BE9
;(cC<j6W
;(j59
;*RH7
;,?'<F19:\n<
;-mi7
;/mA9
;0.y9
;018>
;0BS
;0C0
;0DF;
;0II;6
;0Mr
;0Ph
;0RC
;0Tj7=
;0WD
;0Za
;0eL
;0kv
;0q1<
;0rU
;0vA
;0yd
;12B
;13R
;14C
;14T
;14y
;17D<
;1Ar
;1F1
;1NI;K
;1Te
;1Vs;
;1YM
;1Yn;
;1Yx
;1fj7[
;1hq<Y
;1i]9{K
;1lV
;1nB
;1q6
;1q8
;1u0;t`b9
;1w3;
;1yq
;20b
;21];ZD
;24K
;27x
;29r
;2C4
;2Hw
;2RZ
;2U1<J
;2Vv=F
;2Wf;
;2bF;y;
;2jG:z
;2jy
;2of
;2qv
;2tD
;2tq
;307
;32V:
;33n;
;36A;rn5;
;384
;385
;3D{7
;3NN
;3RK
;3TF<F_
;3Uk;
;3VX<
;3Xm;
;3ZH
;3Zz<
;3e3
;3ek;
;3fX;
;3gU
;3mT;
;3n6
;3nP
;3tD;
;3uN
;3vQ:6
;3xj
;44c
;469;}X
;47E
;49r
;4Bo;n
;4C4
;4Ek
;4GE:m
;4LK
;4Mx
;4VQ
;4Xo;
;4aB9
;4dQ
;4k!:C8
;4op
;4pl
;4x*9S
;51r
;59R
;5E4:
;5LA
;5OI
;5\t79
;5iw
;5m4
;5q0
;5q1;R
;5w2
;5yl
;68n<
;6AB
;6CB
;6H6
;6WC
;6X;B
;6X[;dIR;S
;6Y9
;6dr
;6fj
;6mb;
;6qO<F
;6tR
;6wi
;72L=L
;75Z;
;75\r9
;79B
;7A8
;7A9=
;7BB
;7Cu<d/
;7Hw
;7Ls
;7OA
;7Q/8
;7SK
;7V4
;7e1
;7iD
;7kD
;7sP
;7uo<
;7v8
;80a
;81g;
;86n
;88r
;89d
;8FR
;8Qw
;8S@9
;8UV:
;8Ww;z
;8XB
;8bB
;8fe<
;8o0
;8p6;
;8pH:
;8rU
;8vL;
;901
;92B;F_k;gl
;98l
;9C28
;9FY
;9KW
;9S2
;9TB
;9UD
;9Uw
;9WG
;9YO
;9Y_Q8
;9gn
;9ia{90
;9lt
;9sn
;9|7[9Uu
;9}li
;:Jpp
;:T?E;EAf
;:c79
;:n42
;:sZ9
;;%7q:42i;a
;;5Z9t>
;;9e9
;<1BR
;<P5=BM
;<S38u\f
;<UHa9
;<cJB
;<vl9
;<wFT
;=0wg
;?c:LW99
;@7z8
;@=u<K\nQ<f<
;A2m
;A3d
;A6y
;AGE
;AGV
;AN4
;APS
;ATp
;AT}9dI3
;AaB
;Aj8
;Aow
;ApN
;AqM<
;ArB
;AsZ
;Ax5;U
;A{A=dg
;B/];7j';\t!
;B4L
;B8Y;
;B9E
;BC6
;BDA
;BF9:
;BJ6
;BN.x
;BNi;
;B\s;Mse<\vu0<&
;Bd8;
;BnI<Bb#
;BnO
;Bqj
;C1C
;C1I
;C1O;
;C3B:r
;C8F
;C93
;C<y5
;CE3;
;CMc;
;CSC
;CSY
;CW8<
;CWR8
;Cax
;CeL
;Cgx
;Ckb
;Cuo
;CwE
;D3F
;D4S<U
;D4n
;D7M;
;DC0;
;DL6
;DM3
;DMa
;DWg
;DXE
;DYr
;Da1
;DbF;
;DfK
;DfW
;DlY
;DoY
;Dup
;E2[<oO
;E8q
;E92:W
;EGx
;EJ;8N\t;vj<;nN
;EJg
;ELV:
;ELa
;EOT
;EQK;
;Ea5
;Eb<b
;Egx
;EhL
;En7
;EsO
;Ezr
;E|H9q
;F&p;bH
;F1z:
;F7q
;F89
;F8N;
;FIb
;FIg=k4
;FPS
;FTU
;FUD
;FVM
;FVq
;FW0
;FZ_9
;FfM=
;Fh 9e
;FmN
;FpX;
;FtC=
;Ftf;rJ
;Fv3
;FxO
;FzD
;G63
;G8z:qW
;G;d9
;G>z7
;GCg
;GFm
;GRC<r
;GSB
;GSU<
;GVb
;GZu<M*
;Gaf
;GpF<
;GqA;
;GsL
;Gz6;
;H!89
;H7Q
;HU0
;HUK:
;HWZ
;HY1:Q
;HYW
;HeH
;Hg%;e5
;HjA
;HkX;
;HvV;
;H{\f<OUv<8Ra
;I58<
;I8T
;IFQ
;ILQ<
;ILm
;IX1
;IfA
;Ij9<
;IjL;C
;Ilu;Q
;Ima;
;J1P
;J2K
;J4\r9
;J6u9<)
;J9Wj^
;JB2
;JGV
;JID
;JLC
;JQx
;JR3;
;JRr:
;JW,:IYK;
;JaF
;Jcc:
;Jcm
;Ji8
;JiN;
;JrF
;Jv3;
;JvO
;Jwa
;K1o
;K4w;E
;K6x
;K79
;K8";>|C:NL';V
;KAF:0
;KK1:
;KRQ
;KTE
;KWc;j
;KbV
;KgO;
;KlG
;Klf;
;KpJ
;Kt4
;Kt@<TN
;L2e
;L6o;
;L<59
;LCf;
;LCr;xp
;LMd;
;LQN;
;LTW;zh]<
;LYp
;Ld<2
;LfH;xR
;Llt
;Lv2
;Lw#;aR
;Lx4;V
;Lzj;
;M3I
;M6N;
;MFq;
;MQR;
;MVC9bj
;MXT
;McA
;Mdi
;Mei;
;Mhc9
;Mrx
;Mww;
;Myx
;N"7<aX3=
;N2A:
;N8P
;NHF
;NNB
;NVK;
;NYf
;NZa9
;NbQ
;Nep:
;Ngz:
;NlS
;Nm3
;Nso<Uh <[EF;
;NvI;
;O34<u
;O7M
;O;Q;0S
;OBY
;OC2
;OC;Ox
;OGL
;OQl
;OSW
;OdF;
;Ojl
;Oq:s
;OwR<H
;Owl;
;Ozo
;P14
;PA2
;PD5
;PH7
;PKS;L{
;PSF
;PTt
;PVw
;PWz
;PZN
;Pfi
;PgZ;
;Pgl
;Piw
;PkD
;PmN;
;Ppe
;PrD<
;PsQ
;PwK:7
;Pzg
;Q0n
;Q2a
;Q6"9
;QGJ
;QHV
;QJT
;QQH:Nj
;QQc;
;QSu
;QXe
;Qfb;
;Qhp:
;Qk}9UH
;Qmn
;Qox<
;Qqt
;QtB;
;QwI;2
;R78
;R9L
;RD0;
;RNG
;RPM
;RRD<
;RTm
;RbD
;RdM
;Rnj;
;RpT
;RuZ
;RyV;I7
;Rze;
;S1U
;S2D<U
;S4L
;S7o
;S8B
;S9b
;SC8
;SD3:
;SHV
;SNL;
;SNN;
;SNp
;SPM
;SVT:
;SZi
;S\n99\f6
;Sj-;16\r9
;SoW
;Spp
;SqR
;Sw5
;SwM
;Sx7;
;Sxb;
;Syg8
;T4f:
;T4j=
;T7p
;T8-9D
;TE5
;TEP:$q
;TJT
;TKG
;TKH
;TN&9
;TN7
;TYV
;TZb<
;Tb4
;Tkc
;Tke:
;TsK;
;Ttg
;Tts;1>
;Twn;
;Tyo;
;U27<S
;U2E
;U5z
;U62;
;UAh
;UDd
;UE3
;UQq;"O
;USa
;UVD
;UZL
;UcZ;
;Ugn
;Ul9
;Ulr:
;UmA
;Uot
;Ut3
;UuG<
;UvW;aRr;
;Ux3
;UxG=
;V5M:
;VCa
;VEk
;VIu
;VR0;X
;VR7
;VTa
;VYJ
;VdP
;Vg0
;Vus
;Vv7
;VvY
;Vwl
;V}0<NTq:Q
;W2N
;W58
;W5L:q6
;W6J;
;W8m;A
;WCK
;WCh
;WFk
;WHP
;WIs
;WK6
;WKD9
;WNi
;WWM
;We7
;WjS:
;Wk8
;WpP
;Wpf
;Wq4
;Wqr
;Wvp;
;Wwx
;X0K
;X4y
;X5w9}^O;}C
;X7B
;XDC
;XJo
;XJx9
;XL6
;XNN;
;XNQ
;XOC;
;XOK;t
;XTR;|b
;XeV
;XgT
;XjX
;Xjg:
;Xkv
;Xmn
;Xq3;f
;XqO:
;Xrc
;Xz5
;Y0Z
;Y53
;Y9g:
;YDK
;YLt
;YM]9J
;YND:
;YVe
;YX5
;YXI<
;YZf
;YaF
;YaL;
;Yaw
;Yb5
;YkH
;Yp4
;Yr9
;YxY
;Yzc
;Z4b;
;Z@t<3y
;ZC3;
;ZCZ
;ZCr;B
;ZDW
;ZFF;
;ZGx
;ZM4
;ZPT
;ZW6
;ZZP
;Zg8
;ZiH
;Zkd<
;Zli
;Zr3
;Zvy
;ZwG;
;ZwU
;\rq<NuW
;\rv6<h-1;J_$<`a
;\tz/9u1
;]e&;|?R;7>
;]nm9C1
;_Ep9
;a1E
;a1X
;a5N
;a5p
;a6P
;a7L;
;a7m<
;a8a
;a9t;2
;a;GI
;aDK
;aDV
;aFK
;aGI
;aHh:P
;aJM;
;aJY:
;aT7:
;acN
;aeC
;agH;\tD
;ahS=
;aiL
;ane
;atc
;b01
;b03;
;b58<A
;b5S
;b7d
;bBv
;bH"9JJ\n
;bHU
;bLx
;bSM>X<
;bUb
;bXf:R
;ba1;
;baB
;bh5;
;bkd
;bw}:Lb
;c0F
;c3h
;c7V
;c9b
;c<CBX
;c?K9
;cEA:
;cF+;UH
;cFB
;cJ4
;cJb<
;cKL;
;cMq;
;cNj
;cSD
;cTQ;
;cTW
;cW+;Ah
;cYU
;cb6
;ceS:b
;cfn<
;ckX
;coM
;ctY
;cu7;
;cvB
;cyD
;d1X
;d4A
;d4N:
;d55
;d5e<^L
;d6Q
;d8M;
;d99
;d9r<A
;dED
;dHi
;dJQ
;dU2
;dUK:6
;dW1
;dWL
;dYf
;dbT
;diu
;dr0
;duB:
;dv);P7
;e!29
;e2T
;e3z
;e6M
;e8G;]5
;e8c
;eHN
;eIG;
;eIL
;eJ.85
;eJG
;eJc
;eNY
;eT4
;eXB9%
;eZM
;ebH8
;ebb
;ebq
;edH
;ee2:w
;enR
;epr;
;eqV:
;erN
;evb
;ewM;3?
;exq
;f5A:
;f6t
;f8@<!(P;1H
;fDU;
;fEo;N;
;fGb
;fJA
;fJJ;
;fMY
;fNh<
;fOJ
;fOy9
;fW9
;fYj
;fYt
;fb0:
;fh6
;fpa;
;fq5<1
;fuQ:|vs:
;fyg
;g0s
;g3c;
;g3q
;g9u
;gAU
;gF2
;gRD
;gTs
;gUf
;gc1
;ggY
;gl18{
;gmO
;goH
;gpJ
;gsV
;gtq;
;gu;wI
;gwd
;gwz;
;gzX:
;h0l
;h1E
;h68;
;h7p
;h9O
;hBB<
;hBH;
;hDm
;hFC
;hFK
;hMo
;hND
;hY5
;hYg:
;hgY
;hj3
;hoV
;hq1
;hrU:
;hsu;
;hsz
;hxY;
;hyS
;i1P
;i80;
;i9r
;iAw
;iB8
;iLU
;iN0
;iNR
;iUu
;iVO
;iWz
;iZG
;im1
;isZ;f
;itY
;izL;x
;j3M
;j7i
;jFb;
;jIi;
;jQ7:5(u;
;jS.9eI(:8I
;jXl;
;jaS
;jgr:g
;jh0<
;jjN
;jnl
;jo7:
;jp2
;jvT
;jwz
;k02
;k3a
;k5D
;k6N
;k7E
;k7l:
;kDZ
;kG5
;kGe
;kH\v;A39;BUn:8:/;
;kLn
;kTL
;kUM
;kbs
;kkJ
;knI
;knc
;kqL
;kqZ
;kse<
;kuy<
;l2B
;l6u
;l@R9
;lAM
;lFu
;lJb:
;lP1=
;lQB
;lUO
;lW2:8
;lZ1<x
;lfE;
;lfP
;lll
;lm?;DjW;
;lwN
;m4s
;m9K
;m;D4
;m;VM
;mBa
;mMP
;mOD;7
;mSV;Ux
;md5
;mfR
;mki<L
;ml4<
;mp~9GGW;
;muL;
;mwH9?l\f:@Z`8eTE;
;mxE:
;n0y:
;n5D<
;nBg;
;nBh
;nJc
;nJ|;6v5;
;nKU
;nL8
;nOV
;nRA;
;nV3
;nY6
;nrU
;nyr
;o1o;f
;o3X
;o4t<
;o6b
;o7t
;oDE
;oEB
;oFA
;oI6
;oSR
;oaP
;odk
;ogM
;ook:e
;op0
;osN
;osP9
;p36:
;p<W:sbI:
;pAu
;pCj
;pF<h:d
;pHH
;pHU9
;pS8
;pTA
;pej;0
;pfZ
;pl':U!y:JW
;pr7
;puS
;py3
;py79'
;pzp;
;q87
;qAp
;qBK
;qCE
;qD1
;qI8
;qJ7
;qKc
;qOq
;qP6
;qPp
;qeE;
;qf5;
;qhZ;
;qhu
;qiT;B
;qj/9;E
;qju
;qqc
;r12
;r1B
;r6K
;rBI
;rEH
;rF2
;rGN
;rIP
;rOT
;rV<l
;rb0<
;reD
;rk9Bi
;rrA<l
;rsl
;ruB
;s3S=
;s4k;
;s67
;s91
;s9j
;s9m;
;sBp:
;sG1
;sL1
;sNA
;sPk;
;sRp
;sS4
;saU
;sdN<
;sg3
;sgn
;skH
;spW;w
;sqE
;syI
;t26
;t7j
;tBt
;tCZ
;tQD
;tTi
;tUg
;tbp
;tbr9
;th/;On
;tjE
;tkU
;tlT9t
;tnM;:Lf
;tpw
;tv1<
;u0<4
;u7J
;u9i
;uD=W2
;uFW
;uHg
;uJ0
;uJA:4a
;uJl
;uJo
;uNL
;uPj;
;uRD
;uU=L
;uYS<
;uZH
;ubY
;ube
;udh
;up?t
;upA;
;uqq
;uv\r;DF
;uyp9
;uzs
;v0i
;v2o
;v6M
;v7k:
;vFd
;vHO
;vJZ;
;vQL9
;vY8j
;vY:V
;vaX
;vdX
;vv>9
;v}69
;w04
;w0g
;w0k
;w5s
;w6U
;w6c;
;wC2
;wLG
;wXw
;wY4
;wbv
;wg6<
;wh3:
;wl2;
;wmw;
;wrH;
;wrk
;wuj;
;wvp
;x5g;
;x7m;
;x87;
;xAU
;xB5
;xEr
;xGH;
;xHY
;xIX;
;xJF;E6
;xJa;
;xN9
;xO3
;xS5;
;xUQ
;xVQ=
;x`D<7J
;xa9;EJ
;xbd9
;xc?9
;xhT
;xjr
;xnl
;xtc
;xuY
;xzb
;y.K91
;y1U;
;y5C:
;y67;
;y71
;yCY
;yEc
;yIR;
;yLE
;yNw
;yPQ
;yTg
;yTh
;yVP:
;yWx;
;yX9
;ydR
;yfz
;yk6;
;ykW=
;ykf;
;ypI
;ypz
;ysy
;yut
;yzC<Z
;z3n
;z4\f<Elf;
;z8J:X
;z9Z<
;zAK<
;zND
;zVm
;zWM;L
;zYD
;zbx
;zcc
;zep
;zfw
;zkQ
;zoR
;zsd
;{ \r9mpe;Dk":
;{nW:n$Z;K5J:
;|7o9
;|CI9y
<   no multiple minimum degree on the separator nodes         >
< Dn9
< Factors L and U >
< Hybrid Solver PARDISO with CGS/CG Iteration >
< Linear system Ax = b >
< Linear system Ax = b > < transpose >
< Parallel Direct Factorization with number of processors: > %d
< Preprocessing with input permutation >
< Preprocessing with multiple minimum degree with constraints >
< Preprocessing with multiple minimum degree, tree height >
< Preprocessing with state of the art partitioning metis>
< Reduction for efficient parallel factorization >
< with multiple minimum degree on the separator nodes         >
<# Generated by Steam Audio\n
<%5fj
<'EI;zL
<,4R=i7
<0C<P
<0Dn
<0N9N
<0RE
<0Vg
<0aP
<0qx=
<0u=B
<0wv
<13A
<1Ip
<1Qv<
<1TG
<1km
<1wP=%Id=
<1xE;
<1zM
<1zb
<20l;g
<24e
<29B
<2GJ
<2PN
<2h:3
<2l1<
<2ql
<2sq
<35O
<382
<38M
<39=q
<39q<
<3C7
<3JP
<3XZ
<3kg;iX
<3pf;
<3qJ
<4+p8
<4:dg
<4:pt
<4DH
<4GD
<4gR
<4gi<
<4zT<
<5Kg
<5No<
<5S3
<5ll
<5y9
<61I
<62F;u
<62J
<66F
<67V
<69s
<6DN
<6QX
<6Rf
<6V8
<6XS
<6nd<f
<6wo=e
<70r
<76A
<7PB
<7Va
<7dW
<7iA
<7mX
<8CF
<8MW
<8ZT
<8bunz8
<8cs
<8dl
<8hF
<8iV=
<8mT
<99N
<9:jg
<9Bh
<9Dr
<9EC
<9MF
<9MJ=
<9N;u
<9PW<
<9RX
<9U9
<9bT
<9gb
<9jK;Tl
<9y7
<:Mf1
<;R1a
<;l7J
<;s3T
<;uvs
<;zJZ9
<<z0y
<@En[vP
<A4F
<A;czC
<AUv
<AV9G
<Ac9
<ArA
<B1D<
<B6a
<B9;X
<B;F4
<BAt
<BEI
<BH7
<BOO<
<BV<d
<BZ45
<C43
<C45
<C9n,.;8j
<C<2sR
<CGK=
<CPC
<CWs
<Cah
<Cb0
<CbQ
<CbU
<CcR;9
<ClJ
<CtW=
<CzY
<D0D
<D1h
<D4k
<D6K
<D7W
<D8b
<DFb
<DK7
<DVt
<DYw>
<Dbd
<Df7
<Dl8
<DmD
<DoV
<Dqt=c>
<DyK
<E:4R
<EOB
<ERn
<EUI
<EY2
<EfP
<Eg3
<Ek4?
<EnR
<F45
<F4L
<F9h
<FBS
<FKJ
<FLw
<FS7
<Fj9
<FlB
<Fm<j
<Fzb
<GDI
<GMo
<GRw
<Gbn;
<Ghg<
<GpE
<Gqj=
<Gtq
<H!K=eC
<H51
<H6U<
<HQb
<HUl
<HWf
<Hbt
<Hte<
<HvG>
<IJN
<INE
<IdZ
<IgC
<Iga
<Ii3
<IjB
<ItX
<J0c
<J16
<J47
<J:Um
<J<UP6
<JF0
<JGV
<JMy>
<JO2<i7y
<JSe
<JTxV`TXX
<JWP;
<Jf9
<JsV;
<Jy!8
<K4h
<KBY
<KI5
<KN\n9
<KOu
<KQN
<KUn
<KXg
<KcP
<KfZ
<Kxq=
<Ky2:
<L2A
<L3v<
<L8B
<LEv;B
<LM8
<LgQ<R;
<LlJ
<LoZ
<Ltj9_
<Lx1
<MCp
<MFo
<MSP
<MSQ
<MYZ=t)
<Ma2
<Mau
<Mco
<MiD
<Mlh:
<MnI<
<NE9
<NWW=D
<Nw9
<O<RoL
<OF<;AX
<Ook
<Oos<"m
<OuL
<P0C
<P3u
<P84
<P;Qs
<PY6
<P\rT91
<Pir
<Pj3=
<PlC=
<Plo
<Q5l
<Q6e;
<QAn=
<QHZ
<QJl=
<QMM
<QMk
<Qdh
<Qmn
<R9w]
<RHU
<RQ<o
<RZ4
<Raa<
<Rfq
<Rho<
<Rw8=
<S0O<
<S3v
<S5n
<SBk
<SCG
<SM6<
<Sal:
<SkV
<Soc
<SuF
<T28:
<T5c
<TAt
<TEE
<Th2
<TnC;
<TpR<
<U6w<N
<U7X
<UAV
<UDp
<UHG;8X
<UOr
<UUa
<UV6<
<Ufc=
<Ujr<
<Uue=
<Uw7=
<Uya;
<Uyw
<V"a9
<V38sHR
<V3i
<V5M=
<VCN
<VNA
<VTn
<Va7:
<Vd;kT
<Vhn
<VjZ
<VlE
<Vn4<rD'
<VpV=
<Vr8
<VuK<y
<W%3<Wx
<WDS
<WER
<WHa
<Wey
<Wn0
<Wou
<X3m
<X53
<XBF:
<XHj
<XOX<
<XSI
<XZm<
<Xc;FKu;
<Xfy9q
<Xhf;
<Xqf
<Xtg>
<Y46
<Y6W
<Y7c
<YF0
<YNX
<Yf1
<Z2c
<Z3U
<Z4g<Vh
<ZHR<
<ZH\t>1@+?`k
<ZNg
<Zr7
<[P09o
<\nIr;15
<\tQX<sF
<\tWZ<omJ<
<_ly9
<a%;vGj
<a5o
<aAN
<aDl
<ahA
<arx<
<av3
<axs
<b2G
<b3n
<b3s
<b8w=
<bLc
<bd3
<blJ
<bms
<bo9
<bol
<bp6=
<c3j
<c9L
<c\R<1b
<cdR
<cr:q
<crx
<cue
<cx89
<d0m=
<d4V
<dEI
<dKr
<dSW
<dUP
<dY1
<dab;
<dhr;w
<djn
<dwc
<eB@=HRS>vR
<eOL
<eQK
<eT\n<HY
<eW9
<eZn:0
<eaj
<ebO=
<edM
<em9
<f02
<f1&<Z7
<f70
<f84
<fGR
<fQZ>
<fZY
<fb;<Cu
<fc3
<feJ<F
<fpx<QFI<
<fvx;
<g4v:E
<g;oD
<gAt
<gBo
<gEa
<gWe
<gaL
<gff
<guy>
<gxQ
<gzY<
<h16;|x
<h1x>A
<h5e>v
<h8F>
<hJ8;zl
<hJe
<hMG
<hNd
<iAX
<iOb<
<iXE=
<iZT
<iZx
<iaQ
<ibX<
<ipv
<ixn<JtA<v:
<j3x;
<j9L
<jAl
<jJb>
<jlZ
<jvG
<jyx
<k5e<
<k6U
<k8k;
<k9y
<kCj
<kI1
<kOX>
<kOv
<kSz
<kT:F
<kna
<l0Q
<l3D<
<l3V<
<l4i
<l8e:
<lDy
<lQm8
<lYS
<lg2
<liA
<lsS
<m29
<m4g
<m6f
<mH0
<mgR
<mnD
<mo3
<mtj
<mv7
<mze
<n6o
<nAV
<nhC;
<nhk=
<nkB;z
<nkZ
<nwg
<o7Z
<oB2
<oCR
<oHe
<oTn;
<oUo
<oXX
<oel
<oj8
<onQ
<opU
<ov.:Z\v\f=p\t
<p58
<p5P
<p85
<pAi>
<pLq
<pLx
<pVT
<pc9<
<pep=
<pgW<
<puC
<pyG
<pz9<\nT
<pzs
<q52=
<q5G=
<qRd
<qTG
<qa4
<qi5
<qqj
<qrD
<qx7;
<r0J;
<r5I
<rC5
<rET>
<rHx
<rJL
<rJW
<rSX
<rWC8
<rXH
<reK=
<rgP
<rgR
<rj2
<rj9=Q
<rmU<
<roH
<rpK=
<rt8
<s0P
<s48
<s4C
<sG0
<sJ9<
<sNf
<sR7
<sRA; J
<sV7
<t1A
<t30
<teu;
<tpZ
<tu;B
<tw0
<ty7
<tzd
<u1A:
<uK0
<uLp;
<uNV;
<uNl
<uWE;
<uk1;
<upQ
<v6u
<vKB
<vLI
<vMW;q#6=2
<vMk
<vj2
<vjG=
<vjL9
<w4d
<wDg;
<wH<v
<wPW
<wSW
<wVO
<wj1
<wqM
<wub
<wyh;
<xHl<
<xRG
<xm3
<xoM=6
<xyD
<yP0
<ybA
<ydV
<yeP
<z0K
<z3B<
<z6Z
<zCF
<zOO
<zQD
<zTQ
<zZj
<zdV
<zhQ
<zuo
<zw9
<|9cQ
<|lD<dq4<K
= %$=l4h=*|
=!mK=lr
=%H5<mN
='V9#EM:z
=)ya=OYY>
=00=Ps
=05H<
=0Cu
=0NF>
=0j;9
=1Ow
=1WU
=1Wz<cl
=1mn
=251
=25;v
=27S
=2Bk
=2D3
=2DE=au
=2Li=
=2aB
=2p5
=2sI
=2wd
=3=M3
=3Fi=
=3UC
=45C
=4QY=M
=4YR<
=4df<W_9
=4s3
=50A
=5ML
=5NO>
=5fi=
=5gw
=5uJ;
=65o
=6XE<
=6cQ
=6yM
=7#bI;nR
=7Ks<
=7k9
=7l\tY
=7ua
=87s=
=8Q;g
=8TA
=8gM
=9F7
=9PK\
=9SP<Q
=9XJT
=9Zsd
=9j:h
=9ji
=9m0=
=9nD=wD
=9wS
=<dGO
=<muI
=<yJ=0xN>7
=== %s: solving a Hermitian indefinite system ===
=== %s: solving a Hermitian positive definite system ===
=== %s: solving a complex nonsymmetric system ===
=== %s: solving a complex structurally symmetric system ===
=== %s: solving a complex symmetric system ===
=== %s: solving a real nonsymmetric system ===
=== %s: solving a real structurally symmetric system ===
=== %s: solving a symmetric indefinite system ===
=== %s: solving a symmetric positive definite system ===
=== PARDISO is running in In-Core mode, because iparam(60)=0 ===
=== PARDISO is running in In-Core mode, because iparam(60)=1 and there is enough RAM for In-Core ===
=== PARDISO is running in Out-Of-Core mode, because iparam(60)=1 and there is not enough RAM for In-Core ===
=== PARDISO is running in Out-Of-Core mode, because iparam(60)=2 ===
===========
================
=================== Timing linear equation system solver ===================
==============================================================
================================================================================
==>INFO code =: %d
=>3P=\v1`<ci1
=@k93
=AJC<w
=Adn
=Ae=1
=AhZ=
=Avg
=B;Zz
=BB>7
=BKU=
=BL3
=BXn=
=BnB=^D
=BzE<
=CJ>sm
=CRP
=CYA>HM
=CuO
=D1y
=DNw=
=DwY=
=Dyp
=E$G=@Mt=w6
=E8a>9
=E?H2
=ETQ
=EVg
=Ecb>aS
=Ezz=
=F(9=lt
=FGO
=FHs>
=FPWy
=FbK=
=FiR=
=Fl7
=FlV
=Fmo?
=FoC
=FvU<
=GId
=GLs
=GVP=
=G|b=52
=G~8q
=H2E
=HG<?wQ.?"[
=Hz3
=Hz4
=H~S=ita
=IAb
=IKR=i
=ILr=
=IX4
=IZa
=Id9
=Ioc>
=Jmt=
=Jw7
=K=jP
=KJ3
=KZP
=Kao<
=Kp4
=L0h=
=L=BW
=LTB
=Le7
=MHD=
=MNj
=MR:}U8
=MX5
=M\tR>08N>Hb
=N:Bnz:l
=NBC
=NFn
=NOU>
=NZT
=NfR=
=NoG=
=O&G=GM
=O5x
=OaF
=OfX
=OrY
=OyR=MI
=P4T>
=PC6>g
=PZ)>0X
=Ps >O2
=Q0F>
=Q0P<
=QCU
=QCh
=QeW=
=R4L
=R76<
=RdU=
=Rl4
=S8x
=SHX
=SHX?
=SLL
=STJ>T
=Sbi=
=Ss1>
=TXT>
=TaD
=U1\v>/`L>e1
=UHM<g
=ULs=
=USU
=Uvc<
=VJY>
=Vjt
=W5R
=X3g=Xx
=XKQ
=XSh;Yq
=Xax>
=Xfs=
=Y5F>
=YGg
=YIo
=YOz;7
=YVQ=
=YWm
=Yp;b
=Z1J
=Z1x
=Z7s
=ZFa=b
=ZMB<
=ZeD
=ZrV
=Zu1;At
=[8Z=M1o>C*0?
=\ri4<wb
=]9R4p
=^L7=Vo
=aST
=ael
=aiO
=b3i>N
=b4D=
=bww
=cEP=>L
=cGb
=cSr
=csj
=ct5>
=dHU
=dPg
=dXC
=dmp
=dzx=
=e+`>}\t\r?u!
=eBG
=eu9>
=fTZ
=g0O
=g3}>Bi
=hCb=
=hEb>0
=hJd>
=hLX
=hu5
=i6h=JC
=i9v>T
=iMz=
=ifD
=ild
=iti=
=j7W
=jKh
=jfE>
=jfs=
=jg4>
=j{E>hI
=k0e
=kFn=
=kHE
=kV[8Y
=kmT
=koH
=lBq=
=lI1
=lOf
=lSp
=lW7
=lrs>
=m;o1J
=mqf
=nKl
=nVR
=oLn
=ob;m
=ox0>
=p3M
=p3n
=pgO
=pq6
=qGL="l~=M\f3=
=qeA
=qfI
=rZ5
=rl7=V
=rlP
=ro2
=s9E>
=s:bcB
=sDW
=sM;Ez
=sYP
=sga
=smd=
=tDQ
=tdG
=tf4
=tvm
=u5o=
=u9l
=uHW
=uK9>
=uK:M
=uWO<
=uXh<
=u\rw=Uf
=u^n=Zn
=ugu=
=uh4;E9u
=ukI
=usz
=utx
=uz0=
=v:9z
=vSZ
=voI
=vpI>
=wNT
=wZh
=weV=Fq
=wgQ=]h
=wqb
=xEJ
=xYQ>
=xb;i
=xmu=
=xzq=
=y23>
=yQk
=yU<j
=ybR
=ygo
=z3c
=z7V
=z;PC
=zR>_OB
=zVe
=zhb>f^
> using 
>%H5<mN
>-:MAh9k
>0J4
>0My
>0Ny
>0Oy
>0m;YG
>0r9
>1y8
>20H@.B<D>F>H
>2>mx
>2Fa
>2c0
>2fu
>3E9>l
>3ZC
>4Ni
>4gj
>4hl=
>5&b?B1s>={
>5zx
>6C9>L
>6mn>
>6wr
>74g
>89t
>8Na>
>8TV
>8nS>
>92c?
>9Cj=
>9QF>
>9ne=
>9p_5
>:GXR
>:nRw
>:oAJ;o
>;10v
>;22V
>;6Uq
><RzU
><gAd
>=dPN
>=k3a
>A5G
>A9V>
>BJb
>BZH>
>Bcz>
>CNe
>CfC=&p
>EDw>P
>EPj
>F8N
>F`Xy
>G0Y>
>G4B?
>HL;h
>Hmg?
>IG4=>V
>IaI
>Ih9
>IuC<
>J6a
>JkS>1C
>K9F>
>KHn
>KYu
>Kbc=
>LDo
>Ld;6,R
>LmB
>N:iw
>NBK
>NXx
>NZt>R
>Ndq9
>O9|W
>ODf>
>OLM>
>OpM
>P;K3
>PEy
>PJy
>Ra:v
>SNt
>SS;9
>Stc>
>Sx8m
>Sy*>TE
>T9Q=C
>T:9(j9
>TjQ>g[
>Ud6>O7n<
>Ugn
>V:dz8:
>V;h=vCN=
>Wlg
>XK4
>YHa>K]I
>YIg>
>Yas
>YiN<hA
>Z;Wj
>ZCB
>ZIh?
>ZcD
>Zqy=
>ZtH=
>Zu:k
>]|4>5IF>_X
>_hypotf
>a>Q>TQ
>aGa
>aM<J
>aQ<6`d
>bj2
>bmd;Z
>c5c
>c;j1
>cVc;
>dGk<US:
>d\W?d\W?d\W?d\W?
>dwc>
>e<iy
>edD>
>f]P>uep>
>fhx
>gRM
>h0I=
>hXC=
>hZ8>
>hti
>i;7Y
>iRa
>inT>
>jAj
>jNG
>jeA
>kUS
>kmT
>kuL>
>l7:t
>lRi
>lYL>
>mX5
>mqR<
>n1i>u
>ngw>
>oND
>olD
>p1X>{C
>puN
>qry=
>qxs?qxs
>rYQ
>sq4?
>tjC
>tvL<U
>twy
>uik=
>w<0q
>x4D>qI
>x8=p
>xOy>
>xU7
>xdp>n
>yI5
>yp6
>yw;d
>z6p
>zHo>
>}/\r>\tt/>]cM>
?$Vg3r
?(t%TvZ
?0 ACr
?0<QIx=
?0en:
?1mm
?2;nQ
?2Yar
?2m;c
?31w?
?37N
?3xb
?49G%
?4Fol
?4HC?
?4eR
?5JO<s
?5eK
?5xm?
?6$)2Az
?6z6
?7Pr?
?8H;E!Q
?8o,3
?97D;
?9aR
?9bG#
?9jWz
?9oF\v:I1
?9rq=
?9zf
?:0QE
?:ikR8qN&9\f;
?:og 9P
?;32y9<
?;Xkz
?;t\n?;\t#/<q
?<AFy
?<E83
?<gW7
?<oU2
?<qHb
?<tf3
?>YBT>x
?>gso
?@njv
?A;kD
?AL;B
?Ab<w
?All
?B+Q4
?B;RbT
?CnR
?D9m
?Dk;H
?EPS
?F0Yy
?Fa6Q
?G6?2
?GGHRD
?Gn3?
?H;Ir
?HS=8
?I=Xwm
?IR>Q
?JFH
?JOg/
?Kd %f %f %f\n
?L7A@V
?L9n
?MGQJ
?No transpose
?OBT
?Opv
?Overflow
?PIM
?P]DSH
?Precision
?Q6:jkf
?SGEBD2
?SGEBRD
?SGELQ2
?SGELQF
?SGEQR 
?SGEQR2
?SORG2R
?SORGL2
?SORGLQ
?SORGQR
?SSTEQR
?Va3
?W1a>C
?Wnl
?X;Ez
?XXVx
?X\tH$5
?Z:xI
?ZU1
?ZV6Q
?ZdN
?Zi:7
?\nCpg
?aIN
?an:I
?ayE
?bHN&n
?cW\rS
?cz9
?dpZ
?e78
?eti
?g6H=Co
?g<1t
?gRr
?h>dD
?hPK
?kQ<H
?l8\rZ
?logf
?nL9]
?nWr
?nXY.
?o9"G
?ouuE
?ppa>
?qc7O
?qxs?
?qxs?qxs?qxs?qxs?qxs?qxs
?r=u8
?rO:y
?sX=IV
?soSg
?sp2
?tX9
?taCn
?tce
?uI9
?uZEeu
?ul;7
?v9w
?v;6p
?xCz>
?xdgemm
?y1<C
?y:oSj:
?ypO<
?zM=G
?zhW
?|hO8
@ @">$<&<(>*@,(.(t
@06;r
@20W
@2h=9
@40W
@4\r<0Li
@5:yB
@6pby
@8iy(
@9'yr
@9F\tG
@9TL
@9_ns:i3
@:AE1
@:}47;0^68r
@;2Ky;Un
@<0Z0
@<0d7
@<X9e
@=EvL
@>66D
@>ewA
@A# Generated by Steam Audio\n
@A<9P
@I,<zuH
@J-;kUQ
@J;gO
@K!WC
@KF:)uV
@Ol9
@QE=W
@QH;Af;=jlG=
@Qq9
@RluC
@TBf
@Tz;s
@V9y
@W8;L
@X;p1
@\0:HQo
@\Z9zn
@`N3AD
@b9I"
@cn;3
@df=V
@g;VO
@h>2ip
@hH;2
@n;5Y
@p:ol
@v\f>GvS
@y8T
@yz8
@zM9
A"X9
A%t9
A'i:E
A)\gB
A*D;i
A+E:i
A,0;J
A,;HG
A.5<sx{
A.B0
A/691
A0?^C
A18E
A19/N
A1:HYS;
A2a<\w
A32;
A4;l
A4<r
A5:p
A5;$m
A5e:
A5x;K
A6*<P
A6G:
A8{9
A90P
A95V
A99R\fH:
A9<C;
A9?9)
A9E<g
A9F+
A9\ri
A:#1o
A:6x
A::QZ
A:OS
A:Ph
A:S6
A:Ss
A:To
A:kF
A:v9
A;1f
A;3y\n
A;5E
A;BD
A;E,U
A;ED
A;H$z
A;H7,:x
A;Ix
A;K6
A;Np
A;OS
A;Rm
A;ZH
A;bYi;DQ
A;cM
A;cZ
A;d9
A;dC
A;dd
A;j\r9
A;v<s;Kq
A;z0
A;zY
A<.os
A<1p
A<8v
A<Ag
A<CN
A<FRQ
A<Fn
A<HrH<
A<L4%
A<L:G
A<LT
A<ND
A<PxB
A<TH
A<W4M
A<aE
A<as
A<j'F
A<ks
A<n3
A<nZ
A<sI
A<vA
A=2J
A=N1
A=Oz-
A=Ql
A=\nvB
A=k"N
A=x9
A>93
A>J_S
A?:xP
A?cY
A?qZ
A@D9V
A@K=q6I
AAG;
AAW:uk
AAy:
AB;1
AB=X
AC;u
ACh B`z
AD4<;tH
AD9B
ADN>
AE:Ub
AE;I
AG:^3
AG;A
AG;jD*:^]\t;\r
AG;x
AG<3
AG<U
AGO=
AH;q5
AHG:
AHP<
AI(9%s@
AI8e\
AI99C`N3A
AJ9"
AJ9<X
AJ:c
AJA<)
AK;Hv^
AK;f(
AK<l
AK<v
AKZ<X
AKi;)lr;
AKq9
AM:1
AM:p2
AMFInit
AMFQueryVersion
AMF}
AMF}A
AMX-BF16
AMX-COMPLEX
AMX-FP16
AMX-INT8
AMX-TILE
AMw<
AO library failed to initialize!
AO<X~
AOE:
AOe:
AOl9
AP9:
AP9\f g:O
AP<jZ
AP<o
APIName
APIVersion
APXF
AP\r;li
APi9+
AR>+n
ARI SOFA API for Matlab/Octave
AR]9^
AS:a
ASl<1
AT4;
AT:0
AU;z
AUTO
AVF;
AVX2
AVX512
AVX512 
AVX512BW
AVX512BW 
AVX512CD
AVX512CD 
AVX512DQ
AVX512DQ 
AVX512ER
AVX512ER 
AVX512F
AVX512F 
AVX512IFMA 
AVX512IFMA52
AVX512PF
AVX512PF 
AVX512VBMI
AVX512VBMI 
AVX512VL
AVX512VL 
AVX512_4FMAPS
AVX512_4VNNIW
AVX512_BF16
AVX512_BITALG
AVX512_E1
AVX512_FP16
AVX512_MIC
AVX512_MIC_E1
AVX512_VBMI2
AVX512_VNNI
AVX512_VP2INTERSECT
AVX512_VPOPCNTDQ
AVXI 
AVX_10_1
AVX_10_1_512
AVX_IFMA
AVX_NE_CONVERT
AVX_VNNI
AVX_VNNI_INT16
AVX_VNNI_INT8
AW&qB>
AW2;Y
AWY<
AZ;w
A\f>az
A\n7<Y
A\v9j
A^9q
A_y9
Aa=m
AaQ;J
AaV<
Ab;lr
Ac>Uz
AcM;
AccelN::intersector1
AccelN::intersector16
AccelN::intersector4
AccelN::intersector8
Advanced Micro Devices
Ady;.s
Af;P
Af<ZXk<
AfC`
Ag5<I
Ag; v
Ag;2
Ag\v'A
Age;
Ah;Yk
Ai3;
Ai;6
Ai\BB
Aj;t
Aj<4
Ak9r
Aky;
Al;y
Al<c
Al>A
Am,DC
Am<NO
AmN?C
AmQ,BP
An error/warning message cannot be saved in the file.
An unclassifiable error occurred
An>uCv?
ApL<
ApO;
ApQ8{
Aq9<
AqY9\n
Arv;r
AsD9
Asg<0gk
Assigning DPAR(1)=%e
Assigning DPAR(2)=%e
Assigning IPAR(8)=IPAR(9)=1. This means that DFGMRES routine will do the
At least one of parameters IPAR(8), IPAR(9), or IPAR(10) must be equal to 1.
At least one of the parameters IPAR(8), IPAR(9), or
At;i
Attempted to create SOFA HRTF without either a file name or a data buffer.
Au\r<i
Auu:L:
Av=jl
Avm<
AwN;
AwS:
AwY:
Awb<b
Awj;:m
Awo>=
Ax:.x
AxK;
AxR<
Ay<xeV
Ayd8
A|=T2P>
A}9D
A~c;Z
B j9
B!;Ac
B"B&B*B.B2B6B:B>BBBFBJ(8
B#;3J
B&L:R
B'8CQ
B(<t5A<
B);yR
B)l9
B+<9X
B+N>ZaS>
B,9g
B-;KR
B-H<WP
B0;0=k;
B0D;
B1!:J
B1<J
B1=t
B1G:(
B1\v:z
B2d=
B3R:^
B4:2
B4<p\
B5y:
B6OZ
B80I
B8;\n4
B8gUC
B914}:
B931
B95:
B9;a
B9<ybl
B9Efq
B9Nv
B9Sb
B9U9
B9Z?
B9b2
B9i-
B:60
B:BbZ:R
B:Xd
B:YP
B:\tD1
B:p?I
B:yF
B; rs9
B;"3J;g
B;0JH;
B;2[1
B;6s{
B;9M
B;B:c
B;Hc
B;Me
B;Mr
B;NY
B;TBc
B;XNN;$9J;6
B;Y)Y;2N
B;ZwH;
B;\naF
B;fAC
B;fj
B;jOH;
B;n9:
B;peL
B;y8#
B<&kR
B<;YV1
B<K,6
B<OP\v
B<QH~
B<TL
B<W9
B<X0
B<\rAe
B<^3P
B<^eb
B<cK`
B<hs
B<jy
B<pW#
B<qk
B<rp
B<tS
B<xym<[\nM
B=Jk8>
B=MP-
B=R67?
B>7K
B>Bh9
B>Bh9?
B>NO
B>QX
BA;H
BA;w
BA<1
BA>o
BAA9<
BAA9j
BAy;{
BB<.m
BBF;
BBk-
BC5;
BC>t
BCL<
BCU;
BD9;
BD9X
BD;!N
BD>L
BDq;
BE;[C
BENCHMARK_BUILD 
BF8<pjM
BF<0
BF>XoT>
BFD87
BFs;
BG2<9
BG9E{
BGW;
BH8&
BH:w
BH;R
BI:H
BJ8=R
BK;/K
BK;1K
BK<i
BKO9
BL0<:;H
BLy<B
BM<mcW
BMA;
BMI1 
BMI2 
BMU:L
BMY;
BM];Ha
BMa=!9
BMm=
BMn;
BN8<
BNK:!
BNe<\v@P
BNt;
BO:#Cl
BO:5
BO:N=
BP<K
BQ0>7
BQ19F
BQZ:K:G
BRANCH=
BRl;
BS9;
BSp<fm0;
BT89.
BT=M
BU:n
BU<4|
BUD>
BUY:P
BUd;}
BUg<
BUo;
BV4<i
BV>8x
BVZ;
BW6;e
BW:i
BW;!i
BX1:
BXM:\v
BXm:|v"
BY88
BYI;
BYf=]
BZ=Z,
B[o9|
B\S;N
B\fu:C
B\n<PH
B\nZ8
B\r;oN9
B]\n>wZU
Ba<lb
BaC3
BaF>
Bad facility code
Bad severity number
BbC.
Bc4;
Bc:x
Bcf:
Bd#<miE
Bd8o
Bd?D
Bf<a)B
Bf<b
Bg6=
Bg; T7
BgH<
Bh6;
Bh9?
Bh;?f
Bh>3e
BhI=
BhM9
BhX;
Bi'LCN
Bi<U
BitHistogram
Bj:\vB
Bj:\vB5
Bk(#B
Bk(#B3
Bk9;_
Bk>A"
Blj;
Bm9p
Bm;e
BmP;
Bm^<C
Bn8;
Bn;VK
Bn<pZ_
Bn>5
BnE;UN~
Bo ;J
Bp7>
Bp~;i
Bq6;F
Bqo<
Bqt;B
Br!<35
Br:8N
Br<d
Br=/y
Bs;2
Bs;_x
Bt9Ko
Bt:a\n
Bt;QJ
BtH;`
Build cancelled
BuildHierarchy
BuilderFastSpatialPresplitSAH
BuilderFastSpatialSAH
BuilderMBlurSAH
BuilderSAH
BuilderTwoLevel
Bv9R
Bv;k
Bvh\n
Bw:<F
Bx;oK
By3;
ByR;B
Bz;S\v
B|nZB
B|nZB\r
B}N:v
B~0GB';
B~w<i
C!p;l
C'.9l
C(=F2
C(=HP
C(D;i2=
C):4Z
C);PNO
C);nnA;p
C*!3B0y
C*<S1
C,9a
C.;Fc
C.Q>l
C.c;8
C007
C0W;
C0q;
C1:$O
C1=O
C1K;
C23;}K
C2<oh
C2j:v
C3;O
C3E:G
C4=mwV
C4O<
C4l9
C5D<m
C6-<S
C6;g
C7+U
C7;5
C7<G
C7i;
C8;P&
C8KF
C8O:;
C8U*F
C8X<
C8s;
C9.x5
C90hD
C92,
C92NJ
C9KP\v
C9ON
C9_>t
C9_S8;
C9b\v
C9un
C:&Ip
C:/buildslave/phonon_main_win64/build/core/deps-build/mysofa/install/windows-x64/share/libmysofa/default.sofa
C:0-h
C:4B
C:4v
C:70W:
C:82
C:9K
C:=ze
C:B3$
C:CW\r
C:G1
C:GpK<
C:Gy}
C:LD
C:N66
C:O7
C:Q6
C:QI
C:Tv
C:Xj
C:Xk
C:\buildworker\phonon_main_win64\build\core\build\windows-vs2019-x64\src\core\Release\phonon.pdb
C:gN
C:o0
C:uR
C;,Ja
C;1O
C;24
C;8H
C;8Y
C;BL
C;Ib
C;Mub;
C;Pq
C;S4
C;SV
C;SY
C;TK
C;bH
C;bj
C;ee
C;gz}
C;hO
C;i,N;4
C;iC
C;rS
C;seo
C;u1
C;wL
C;xw
C;x|D
C< 4a
C<*1A
C<0G
C<1k
C<8E
C<8\vN
C<AG3
C<C7
C<CPX7
C<I\g
C<MN
C<Tl
C<Tzv<
C<ZIX
C<_3I
C<`tH
C<lZ
C<mut
C<pQ
C<|bC
C=&mO
C=EW
C=FP\t
C=M5)=7
C=N.K
C=Np
C=WM
C=gu
C=z"d9
C>*Ku
C>0L
C>7hk=
C>9^a6
C>MQy
C>pr
C@I=5P
CA9<
CA;C
CB:e
CB;y
CB<5q
CBE:\t
CBh;d
CC<L
CC<e
CCmQ,
CCo<
CD:\nE2
CE<u
CE];5
CF9dZ
CF:9
CG<UlX
CGZ;-
CGh;3
CGj:zK
CHEGST
CJ>9
CJA:
CKX<N
CKc=YC
CL interop not supported
CLASS
CLDEMOTE
CLWB
CM:TkJ
CMF}
CMF}A
CMN:
CMOV
CMPCCXADD
CN9<
CN@=!kC
CN@bo
CNs8
CO ;qd~
CO9`2):
CO;x
COMPATIBLE
CP:h
CP>D
CPU does not support SSE2
CPU does not support selected ISA
CPU frequency: %8.3f GHz
CR;s
CR<f
CT:<7
CT<hj
CTR<
CU;Z
CV8<
CV;M_
CV=O
CW&qB
CW8;
CX'9F
CX7V
CZ<6
CZ<Qf
CZl;
CZw:
C\,50J
C\v4;J
C]k>2
C`N3
C`N3A
CalcMortonCode
Calling r8write without FORTRAN_IO, iparam(9)=0
Cannot create file %s
Cannot create file MKL_Poisson_Library_Log.txt
Cannot proceed as the system failed to provide
Cannot proceed with calculations as
Cannot proceed with calculations as input
Cannot proceed with calculations as input matrix has
Cannot proceed with calculations as input maximum
Cannot proceed with calculations as input size
Cannot proceed with calculations as matrix has either
Cannot proceed with calculations as small diagonal
Cannot proceed with calculations as the system failed
Cannot proceed with computations.
Cannot read the contents of a file
Cannot run %s - not enough memory
Cb;M
Cbw;]
CcZ;
Cd;E
CdA<w
CdO<
Ce3\f
CeR;
Cf;4AC
Cf;CR
Ch B
Ch<h
CiK=>N
Ci\r?8
Ci^;XW
Cif:
Cj4;5
Cj:\vB
Cj:\vBs\t
Ck(#Bsx
Ck;s
Ck=5b
CkO;
Cki;
Cl;p
Class name: 
CloseThreadpoolTimer
CloseThreadpoolWait
Clv;`
Cm%;3
Cm:M
CmQ,
CmQ,B
CmT:
Cn;8
Cn<K
Co7"L
CoJ;
Column-replicated array -- copy in process column: %d 
Columnwise
Computational layer library for Cluster FFT not loaded.
Computations have stopped. The result may be incorrect.
Conditional numerical reproducibility mode is turned OFF
Conditional numerical reproducibility mode is turned ON
Conjugate
Conventions
Core
Core Broadwell
Core Cannon Lake
Core Comet Lake
Core Haswell
Core Ice Lake
Core Ivy Bridge
Core Kaby Lake
Core Sky Lake
Core Tiger Lake
Core2
Could not open file %s
Could not open file %s, aborted.
Cp:E:
Cq;m
Cr;Npl
Crb8"q
CreateEventExW
CreateEventW
CreateSemaphoreExW
CreateSemaphoreW
CreateThread failed
CreateThreadpoolTimer
CreateThreadpoolWait
Ct8K
Ct:I
Ct;ti
CuU=
Current date/time: %s
Cv9Z
CvZ;
Cw;CD
Cwd<
Cwp9
Cx:<v
Cx;G
CxC=
Cy9LH$9\r
CyR;y
Cya;
Cylinder test 
Cylinder { p0 = 
Cyo;
Cz,;\nfS
Cz:vZ
CzD9
C|nZB
C~0GB
D!A=V
D"D&n,n2
D"e9
D#M<M
D$n<od
D';kzT
D*:5r
D,<x2
D07<
D0<L
D0J<
D0z9\v
D14;
D1:d\v
D1;i
D1;l
D1R:
D2<&t
D3;I
D3q:
D49@
D4;I/
D4;y@
D4W<C
D4f<1
D59u>
D5X=[
D5o;
D6;x
D6M;
D6r:w`w:
D72[
D7<f
D7w;
D8k:
D8v=
D9(k
D91AO<zDy;
D92<a;
D9;U
D9L;
D9P[
D9R&
D9Yf
D9fY=
D:5R
D:6M
D:CQ
D:Ts
D:UT
D:kP
D:tk
D:vXh:Y6
D:vv
D;1e
D;2Q
D;9B
D;?nD
D;GyL
D;Mc
D;O6
D;QF
D;RN8=0r
D;Sn
D;T3
D;ZY
D;\f5O
D;aZ
D;b*V
D;bY
D;eY
D;eb'
D;jw
D;vP
D;yLj:Sj
D<*ll
D<3Lf
D<3g
D<9Y
D<<pA
D<B1
D<Co
D<E7,
D<HFe
D<eW
D<ed
D<m1
D<of
D<xV
D<~Sx
D=9z
D=>Pa
D=OD
D=ZP
D=k1
D=maQ>
D>J:H
D>SRM
D>xq
D?\f<fVO:5
DA9wX3
DAL_BLAS_COMPUTE_MODE
DAb<eE
DB$<2
DB5T
DB;q
DB<U
DBY^uB
DB]8Ta
DBl:
DC:N
DCh9js
DDd;
DDo;8
DE;k
DE\f;4
DF,<S
DF;G
DFGMRES routine.
DFGMRES routine. Otherwise, the maximal number of iterations is equal to
DFr;
DG9:N2
DGY;j
DHy:
DI;?mQ8
DI;BT
DI<a
DI<p
DIMENSION_LIST
DJ;-i
DJ;9
DJ{9
DKO;g\
DL;ll
DLB;y
DMA;
DMn;
DN>~6
DNnW'
DO:-F
DPAR(2)=%e should not be equal to 0.0 simultaneously. The FGMRES
DQ;C
DQC:
DQa<Ua
DR;97
DR<Q
DRB<b!
DS;S
DS<tl1
DSE=
DSYGST
DSs;
DT9u
DT:A
DT;8
DT?9
DTI<
DVx=P
DXx8
DYE;
DYk9
D\R;N
D\f;rb
D\n=OQK=
D\t<4W6<
D\tV:w
D\vb<N
D]V<E
D^F<n
D_FORWARD_TRIG_TRANSFORM/D_BACKWARD_TRIG_TRANSFORM routine.
Da:d
Da<ll
Da=b
Data.Delay
Data.IR
Data.SamplingRate
DataType
Db*;7
Dc:l
Dc<>U
Dd;K=
Dd;V
De;a
DeC;Y
Debug
Dee;5
Df<w
Dg5;
Dg;n
Dg;u\
Dg<z
Dh!;F
Dh:ZL
Distributed Matrix Input Format is used for CPARDISO (iparm(40) = %d)
Division by 0 occurred.
Division by zero occurred. Computations have stopped. The result may be incorrect.
Division by zero occurred. The D_COMMIT_TRIG_TRANSFORM routine was not called,
Division by zero occurred. The S_COMMIT_TRIG_TRANSFORM routine was not called,
Division by zero occurred. The d_commit_trig_transform routine was not called,
Division by zero occurred. The s_commit_trig_transform routine was not called,
Division by zero occurred: At iteration number %s, the rotated Hessenberg
Division by zero occurred: parameter DPAR(5)=%e should
Division by zero occurred: parameter DPAR(7)=%e should not be equal to 0.0.
Division by zero occurred: the new rotation for Hessenberg matrix is degenerate.
DjA9
Djk:
Dk;hYn
Dkt=
Dm4<x5-
Dmz<m
Dnc;
Do:!0
DoG;R
DoL9I~
Dp)92
Dp0:
DrH9
Ds;V
Dt8?
Du59<
Du;od
DuT<
Duj<
Dv.9
Dv.90
Dv3:
Dvz;N'
DwU;
Dy:7
DyH<B
DyR=
Dz5;
Dz>a
DzI;\f
DzJ;
D{6g
D|;qyf
E"<oG
E%9/q3
E(M:I
E)B:In
E+wS
E,C,I
E,C,M
E-73
E.:6Z
E.:lr
E0d:
E0s<
E1,=n
E19sM
E1<J
E1A8)
E1N>
E2S9>E
E2j:?z
E2w9
E4:a"
E4:mb
E4=r'
E4i;7
E5;:z
E6;Mm
E6<R
E6Q;
E6x<E
E7;ZQ
E7<B
E7<K
E7G;
E7K;
E8&s
E8g\
E9&S
E9N:5
E9Rm=;
E9fc
E9gR
E9l~
E9m<.
E9zb
E:5S
E:6QP;
E:8m
E:>St
E:BZ
E:Bc
E:Ku
E:KzT
E:PrP
E:TOL
E:YD
E:Zfl;
E:\t=680
E:dR
E:fv1
E:vMU
E:wYl
E:yu
E;$EJ
E;2Z
E;3r8
E;7s
E;Cg
E;Kw
E;N1
E;S9
E;VO
E;WP
E;Wk\t
E;Wtg;
E;X6
E;bS*
E;kW2;
E;o/R
E;on
E;t<W
E;tzS
E;wf
E;y4
E;zW
E;za
E<6W&
E<BA
E<Fp[
E<LW
E<O0
E<Oig
E<Q&3
E<Yo
E<aB
E<h&E
E<j1.
E<oaU
E<ri
E<sS
E<uZ*<z
E<us
E<xQv<
E=%43
E=0m
E=1l
E=2bl
E=<as
E=DX
E=W7
E=WIf
E=Ys
E=ZR5
E=kNu
E=sWM
E=x&9
E>9S
E>HT
E>aJ
E>dm
E>s.p
E?9x
E?tQ
EA5;
EA<wW
EB:9)
EBG;\r
EBN9[Bo
EBs<YV6
ED:z
ED;P
EE;O
EF9h
EG;b
EH<R
EHK;
EHP:
EI9<{
EJ;q7
EJj=9
EK;;V
EK;v
EK<Ns
EKI<
EKN;
EKa;q
EKr:+
EM9?
EN6;
ENQCMD
EO;5
EQJ;
ERD$
ERROR: 
ERV:8DN
ES:2k?
ET;#Pz;
ET;OB7<
EU:M
EU;Z
EU?;k
EUG;0c
EV;i
EVh<
EX"<f&9
EX6;RV
EX<6
EY<g
EY=p
EYAzb
EYT7
EZu;
E\;Rz
E\r<j e:Q&F<
E_<two
E_M:j
E_V=5
E`9a
EaL<
Eb>>Hu
Ec:ud
Ecr;
Ed;mj
Ed<+8G
Ed<E
Ee0;
EeC>
EeJ<
Eg1<rK
Eg7;
Eh;9=
Eh;VB
Ei8o9
Either parameter TT_TYPE in the D_INIT_TRIG_TRANSFORM routine
Either parameter TT_TYPE in the S_INIT_TRIG_TRANSFORM routine
Either parameter tt_type in the d_init_trig_transform routine
Either parameter tt_type in the s_init_trig_transform routine
Either the D_INIT_TRIG_TRANSFORM routine was not called,
Either the S_INIT_TRIG_TRANSFORM routine was not called,
Either the d_init_trig_transform routine was not called,
Either the parameters were altered by mistake outside of the DFGMRES
Either the s_init_trig_transform routine was not called,
Ej7=
Ej<c
EkZ;Q:,
ElR<
Em1>ap
Em9q
Em;a
EmM;,
Embree Ray Tracing Kernels 
Embree device is no SYCL device. Device pointer argument must not be valid, pass NULL instead
Embree: 
EmitterPosition
End of tests
Eo;Ki&
Eoh9
Ep(;G
EpS=#
Epsilon
Eq9=
EqH;
Er;db
Error (VML_STATUS_BADMEM) in %s: NULL pointer is passed.
Error (VML_STATUS_BADSIZE) in %s: array size %d is not positive.
Error (VML_STATUS_ERRDOM) in %s: argument is out of domain.
Error (VML_STATUS_OVERFLOW) in %s: argument caused overflow.
Error (VML_STATUS_SING) in %s: argument caused singularity.
Error (VML_STATUS_UNDERFLOW) in %s: argument caused underflow.
Error code=%s and/or %s.
Error code=%s and/or %s. Computations have stopped.
Error code=%s. Computations have stopped.
Error is not in the area of OOC I/O. Check it manually, error=%d, %s
Error is not in the area of OOC I/O. Check it manually, error=%lli, %s
Error message has been written in %s
Error: Intel oneMKL TT backward transform failed with status=%d in FFTW3 interface to Intel oneMKL.
Error: Intel oneMKL TT commit step failed with status=%d in FFTW3 interface to Intel oneMKL.
Error: Intel oneMKL TT forward transform failed with status=%d in FFTW3 interface to Intel oneMKL.
Error: Intel oneMKL TT initialization failed with status=%d in FFTW3 interface to Intel oneMKL.
Error: info returned=%i
Es3<
Es<m
Et2=
Et<]0M;
Et\v9
Etm;,M
Eu:Ov
Eu:Te
Eu;x
Eu<V%
Eut=
Ev8W>
EvD<l
Ew8<AF
Ew9%
Ew:1
EwE<h
Ewx:k
Ex!;S
Ex9cE
EyYDG
Eyq:
Ez=uB$>0
EzR;Oo
E}P9
E~=Fn
F 9F
F";kM
F#<2z|8r0
F'<nBJ
F(,:Ts3
F(D:9
F(i=/pc>1[\v
F):o4
F)<un
F)n;rW
F-N;ro
F/;r7
F0=6^
F0M;
F16C
F16C 
F19Be
F2;J
F2BlJ2HnL
F2R;
F3l;
F69<
F6:LUP:~so8
F6;W
F7;nz
F8(c
F8:GN
F8<f
F8HU
F9 D
F9!p
F90H
F96t
F97]
F9Sc
F9Z39:
F9\V
F9o<BwV
F:4G
F:4M
F:97
F:CVH:*
F:D9
F:OK
F:aS
F:bV
F:de
F:ef\r
F:i5
F:n3}
F:sQ
F:ur
F;'Aa
F;0c4
F;40
F;85
F;8;sG
F;8s\n
F;D6S:`
F;GY
F;IU
F;IZO
F;Iy(;De
F;Jw
F;NT
F;Og{9
F;Psb;j
F;Q\fL
F;]Te
F;aF
F;aP
F;bs
F;gS
F;ge
F;loQ
F;m$m
F;nL0;-g
F;nm
F;o{f
F;p2
F;qr
F;tZ
F<B1v<
F<D\tJ
F<H5"
F<Ja
F<M|i
F<WH
F<_5s
F<mx
F<ptO<
F<rn
F<z0
F<zt
F<~91
F=&3Q
F=9A
F=;AkV
F=Ul4
F=VQ
F=W9,
F=Y8,
F=jZ\r
F=qU
F>WO
F>c4
F>ec
F?b;yU
FA;$3
FA[;GW
FB=m6
FBHS
FCI:E
FCW<
FCa;@
FCm;
FCp;]
FCv:
FDG<
FDN<
FF;P
FF\n@asinf
FG9|
FG:A
FGMRES method has lost the orthogonality property, or the FGMRES method was
FGMRES method without restarts, set IPAR(15)=IPAR(5)-IPAR(4) which is equal to %s
FH8;xI
FH;;p
FH=7/
FH=Cg
FHD:]T
FHDB
FHIB
FHL<
FHT8>
FI<X
FIQ;
FJ:;X
FJ;D
FKx<
FL:v
FM>;D
FMA3 
FN;e
FN?;e
FNh<
FO%8
FO5<
FO;6
FOa;
FPi:
FQ;N
FR9.
FR93x
FRHP
FRU;
FRr=B
FSP;
FSR</
FSd<
FT;IXY
FT>qZ
FTQ:1
FTS>r
FTZ=
FU<u8
FUm;
FW;O
FW<SO
FWS;k
FX;mz
FX=rV?=0)
FXSAVE
FY:]5
FY<jY
FYM<
FYv<
FYy:u
FZ$:Ue9
F[9Vr
F\r:0i
F\t;RwN:
F\t;wc
F]E6
Fa;Q}p
Fa;o
Factorization step (100 (%%)):
Factorization step:
Fatal
Fatal error (error message=%s).
Fatal error: Division by zero occurred. Computations have stopped.
Fatal error: Failed to normalize the right-hand side.
Fatal error: Internal memory error. Computations have stopped.
Fatal error: Memory cannot be allocated/deallocated.
Fatal error: Memory cannot be allocated/deallocated. Computations have stopped.
Fatal error: Trigonometric Transform commit step failed to complete.
Fatal error: Trigonometric Transform forward/backward step failed to complete.
Fatal error: Trigonometric Transform has failed to release the memory.
Fatal error: Trigonometric Transform initialization failed to complete.
Fbw:
Fc*99;-
Fd<O
FdU</3
Fe;8
Fe\<Q
Ff7&
Ff;5
Ff;ivv
Ff<T
Ff<_s
Fgz;
Fh:O"c<-W*=
FhY<
FhY<\nKX
Fhr:>
Fj!;o5F
Fj9lmc
Fj<uR
Fk.9db
Fk4=
Fl:z&
FlM;
FlP;
FlushProcessWriteBuffers
Fm8=7
Fm;Z
Fn&<V
Fn0;
Fn;wY
Fnu;}
Fo:b
Fo;(Y
Fo;u
FoO;pb~
Fod=+
Foj;w?
Fp9S
Fr[:c
Fs6j
Fs:T
Fseek failed
FtO<
Fu<;0
Fu<l
Fu>_i
Full
Fv:u
Fw;eN
Fx98
Fz9d
Fz9uH
FzG9
FzU<
F|w;b
G'8Q
G+g;c
G0:9
G0>'q
G1;N
G1m:4I
G29:
G2:U
G3;L
G3<I
G3H:
G4Y<
G4l;9k
G4v:
G6Nfb
G7:B6
G7;S
G8(;r
G8/<e
G81;
G89p
G8BL
G8PU
G8\s
G9*X
G98y
G99g~
G9Z!
G9\nRt
G9\tc
G9j*)
G9jw
G9xuL
G9zn7<T
G:!\N5t
G:(5b
G:(6I
G:2d
G:DoM
G:KQ
G:MY\t
G:UL0;\
G:gA\v
G:ncG;
G:oT
G:t5k
G:yJ
G:zk
G:~mQ:U
G;0=x
G;0B
G;35g
G;3L
G;Ap
G;BF
G;C0
G;EWR
G;FB
G;HH
G;OGX
G;Rt
G;S)M
G;Shd<
G;WP[<f
G;\e4
G;ao
G;bV
G;brD
G;iJ
G;jA
G;nR
G;ob
G;q1
G;ti
G<)M0
G<3Y
G<69
G<AU
G<F5
G<Gd
G<IQ`
G<VO+<K
G<V\R
G<WNS
G<jc
G<l80
G<v?v
G=dI1
G=nU
G@M9
GA\t>a
GB:h38
GB?:m
GC:r?
GCOL
GCmQ,
GD<mM
GE;R
GEN;
GENERIC_IA32
GFF;
GFNI
GFY<
GFg:
GFw<5W
GG;z1
GG<X
GG=2{
GGHD3
GGR8|Q
GH4>
GH;l
GH;l7
GIC>
GIR=g
GIr;
GJ:F
GJB=
GJP>
GKQ={
GL2<
GL9\rX
GL;M
GMT;x
GM{8
GN:a
GNBf
GNf;&
GNp:W<#
GPUUtilities.dll
GQ;Q{
GQ;u
GTK:
GTx;
GU9`v
GVZ<
GV|9Q0
GW;E
GX-:5
GY;w
GYN9
GYd;em
GZM<{
G[I;y"g
G\n;VS
G]9;a
G_ rr
Gb9E
Gb;D
Gb<H
GbK:
GcA;
Gd :v
Gd9|
Gd;L
Ge-<P
Ges;
GetActiveProcessorCount
GetActiveProcessorGroupCount
GetFileInformationByHandleEx
GetThreadLocale
GetTickCount64
Gf?<9
Ggi=
Ghk<
Gi=H
Giy:S\
Gj;Wk0
Gjo=
Gk:c
Gk<D
Gl<=a
Gl=^j
Gll:
Gm9\v
GmM>
Gm[8
Gn%;r
GnC<O(
Go8:
Go;Hj
Go;t
Gp4<
Gq<A
GqD=
Gr;s
Gr@;vA
Gs9&8
Gs:97":
Gs;A
Gs;k~
Gt1<
Gtz;
Gv;|J1
Gv<3;N
Gw<f2
Gx7<
Gx9]uP
Gx;(s
GxH=q
GzAm
G}F92wu
G}G;S
H!<mE
H!a7
H%;tz
H':yf
H(e8
H);Du
H+r;pq
H-?jj
H.=f7
H0:!W
H0:~bV
H1<sF
H1=b
H1e:{
H2;V
H2a;
H30;t>
H39dYk
H4=m
H59/
H5<M
H5A=
H6;H
H7:2
H7;5
H7w;
H8:f
H8:i
H8DQ7;s
H8I(
H9 z
H9'w
H937h
H99h
H99x\n;1
H9:z
H9=c
H9W#
H9a}
H9c(8;
H9q;6
H:9P
H:CV
H:G1
H:RP
H:Re=
H:TSk;
H:{WB
H;-i5
H;0c4;
H;6x
H;7S
H;E\nK
H;HD
H;Pq\v
H;Vu
H;XR
H;XW
H;[Fs;M:B;6_
H;\fV4
H;eX
H;m9
H;ph
H;qiU
H;sh
H;tjy:
H;yNa;
H<1C
H<2Su
H<5A
H<6g
H<8La<
H<9&l
H<:ku
H<=wU9
H<L:9
H<Mr
H<OE
H<^hH
H<cmV
H<fi
H<fq
H<me
H<p9
H<qa
H<ri
H<se
H<t.S
H<uP
H=58
H=6M@
H=9B\
H=SC
H=VE
H=e<Ui
H=ua
H=uhM
H>5f
H>7T
H>Im
H>L7
H>rTD
H>rc
H?i<R
HB9'
HBF:2
HCA;(s
HCF;
HDF\r\n
HE;h
HFX=ej&;
HFh<
HG9o
HH:)Z
HI'5
HI:v
HIj;e
HIs:%
HK(9
HK2:
HK<L
HM;r
HM<*t
HMM:
HN9/
HN:a
HN;2
HN;A
HO<A!R
HOC<
HPX`
HPY;
HQC;
HR;xu
HRESET
HRTF
HSEQR
HSp;
HT9)
HT;k]
HTk:
HU>P@
HUUUU
HW9i
HW:m,
HW<j
HX;6
HX;w
HY:.G
HYy;
HZ,9
HZ;P
HZJ<
HZS<
HZd;B
HZh<s)
H\P9G
H\f2\nd
H\f;xz6<
H\fx:Y
H\n;9L
H\t9Q
H\v<S7
H^=NTm
H_D8f{
H`<8P
Ha=RjR
HaI:!
HaL;K
HairBuilderSAH
HairMBlurBuilderSAH
Hc7=
Hc=4$
Hd<BZ\n
Hd<g{7
He3<9^
He;(2
He=R<
Helmholtz coefficient ?PAR(4)=%e should be non-negative.
Helmholtz coefficient ?par[3]=%e should be non-negative.
Hf6:
Hf:1Q
Hf;0
Hgx;
Hi;[9
Hi>yT
Hk:y\f
Hk=k
Hkq;
Hkv=k_E
Hl;^k
Hm:u3
Hm;o
Hm<x\vw
HnA=
Hnd;n
Ho;lJ5
Ho@;i
HoK=eM
HpB;
HqP:
Hr/;2
Hr\9
Hr]9
Ht:;HA
Htu<
Hu:t9
Hu;`4F
HuA;
Hv<H
Hvj<'
Hx9hL
Hx;e
Hx;r
Hx<F
Hx=F
Hz4;
H{<no6
H|m;J
I!>HuR
I"9U/x;
I#<ILK<
I)<mI
I+3;c
I,9V
I.Q;<ZI9Q
I0D:4
I0T<UO
I37<
I3G;
I3s:
I6:r
I6<3b%<
I74;&
I7MD
I7\v;u
I7v9#rX=O
I87:F:G:s
I8G>
I8Ta
I8b2
I9!9
I9,a
I99C
I9BlV
I9\5
I9`g
I9hC#:
I9kj^;b
I:'kh
I:+Up
I:2T\r9
I:7l
I:9i
I:J;p
I:Jd:
I:JkI
I:c:3
I:hH
I:k\f69c)4;x
I:n8
I;#uo
I;6\nw;uL
I;7I
I;EU
I;I\fP
I;LR
I;Rh4
I;ZU
I;af
I;e{M
I;gu
I;pf7;
I;qc
I;vy
I<+5C
I<9U
I<BX(
I<Lhd
I<O=g
I<RR
I<Ss.
I<UGW
I<W7
I<j@x
I<za
I=AdX
I=Q6
I=XC.
I=x+7
I=y@Y
I=yP
I=zlJ
I>1V
I>KZ
I>Nj
I>Tt
I>[eL>G
I>u4A
I?F>I
I?crt
I@ H2
IAi<
IAl'
IB>3
IC:Ds
IC;Z{k;
IC<U
ICMF}A
ID<Od
IDq;
IE4<i
IE<E
IEc;
IGm:
IH9;MK\r
IH;G
IIv:
IK;9
IKD:fx
IK\t:a
IKg<k>
IL;8
IL>1
IM1:MT
IM;A
IN:7
IN<E1
INTEL oneMKL ERROR: %s.
INTEL_ISA_DISABLE
IO:j
IOD9
IP4=
IP7;s
IP<ga
IP<qN_
IPAR(10) must have the value 1.
IPAR(15)=%s. Parameters IPAR(14) and/or IPAR(15) were probably
IPAR(4) is greater than or equal to IPAR(5).
IPAR(5)-IPAR(4)=%s
IPAR(5)=%s is less or equal to the current value of the iteration
IPLAirAbsorptionModelType
IPLAmbisonicsType
IPLAudioEffectState
IPLBakedDataType
IPLBakedDataVariation
IPLDeviationModelType
IPLDirectEffectFlags
IPLDirectSimulationFlags
IPLDistanceAttenuationModelType
IPLHRTFInterpolation
IPLHRTFNormType
IPLHRTFType
IPLOcclusionType
IPLOpenCLDeviceType
IPLProbeGenerationType
IPLReflectionEffectType
IPLReflectionsBakeFlags
IPLSIMDLevel
IPLSceneType
IPLSimulationFlags
IPLSpeakerLayoutType
IPLTransmissionType
IPLbool
IPLbyte*
IPLfloat32
IPLint32
IPPCODE
IPPDATA
IQq:D
IR59
IR7;Y
IR92
IS8Lpn:\nb
IT;1
IU4<y
IUv;
IV;v
IVj:
IW;R/
IZ;gFE
I[;Xy
I\;a1
I\f@;z0u
I\fT=f
I\v<K6M<
I]82i
I_MPI_NUMBER_OF_MPI_PROCESSES_PER_NODE
I_MPI_PIN_MAPPING
I_MPI_THREAD_LEVEL
Ia:w
Ib&:0
Ib:2\vP
Ib<v
Ib\t<2
Ibs9F
Ic7=
IcO;W
Id7;9O
Id;5-
If you are sure that everything is correct, you may force the
If;C
Ifx;
IgE<
Igu;
Ii69s
Ii8b
Ii;E
IiI;!
Ij:n
Ij;#mD:K
Ij>=E
Iks:og
Ikz=
Il(;R
IlJ;
Iln:
Im;u
Ina:5
Index is out of bounds
Infinite loop.
Infinite loop. At least one of parameters IPAR(8), IPAR(9), or IPAR(10) must be equal to 1.
Info
InitOnceExecuteOnce
Initialization failed to complete, or the parameter IPAR(7)=%s
Initialization failed to complete, or the parameter ipar[6]=%s
Initialized AMD Advanced Media Framework v%d.%d.%d.%d.
Initialized Embree v%lld.%02lld.%02lld.
Initialized OpenCL device: %s %s (%s).
Initialized OpenCL platform: %s %s (%s).
Initialized Radeon Rays v%.2f.
Input absolute value of tolerance is greater than
Input data or print help ? Type [data]/help :
Input error is not equal to ZERO, error=%d
Input error is not equal to ZERO, error=%lli
Input value of DPAR(31) equals zero.
Instanced scene is not set. Use rtcSetGeometryInstancedScene to set the scene to instance.
Intel oneMKL BLACS fatal error: cannot allocate memory, aborted.
Intel oneMKL DCSRILU0 ERROR: 
Intel oneMKL DCSRILU0 WARNING: 
Intel oneMKL DCSRILUT ERROR: 
Intel oneMKL DCSRILUT WARNING: 
Intel oneMKL DFTI ERROR: Configuration parameter DFTI_NUMBER_OF_USER_THREADS is not set 
Intel oneMKL DFTI ERROR: Descriptor is uncommitted or corrupted
Intel oneMKL DFTI ERROR: Error in OpenMP
Intel oneMKL DFTI ERROR: Functionality is not implemented
Intel oneMKL DFTI ERROR: Inconsistent configuration parameters
Intel oneMKL DFTI ERROR: Incorrect status
Intel oneMKL DFTI ERROR: Internal error
Intel oneMKL DFTI ERROR: Invalid configuration parameters
Intel oneMKL DFTI ERROR: Not enough memory to allocate
Intel oneMKL DFTI ERROR: Transforms with number of points N of a non-unit stride dimension exceeding 2^(27-p) - 1 for N a power-of-two, or 2^(23-p) - 1 for N not a power-of-two, are currently not supported, where p=0 for single precision and p=1 for double precision
Intel oneMKL DFTI SUCCESS: No error
Intel oneMKL ERROR: CPU %d is not supported.
Intel oneMKL ERROR: Incompatible optional parameters on entry to %s.
Intel oneMKL ERROR: Parameter %d was incorrect on entry to %s.
Intel oneMKL Extended Eigensolvers ERROR: Problem from Inner Linear System Solver
Intel oneMKL Extended Eigensolvers ERROR: Problem with array parameters
Intel oneMKL Extended Eigensolvers ERROR: Problem with input parameters
Intel oneMKL Extended Eigensolvers ERROR: Problem with internal memory allocation
Intel oneMKL Extended Eigensolvers ERROR: Problem with reduced system
Intel oneMKL Extended Eigensolvers Error: Matrix B is not positive definite.
Intel oneMKL Extended Eigensolvers WARNING: No eigenvalue has been found in the proposed search interval.
Intel oneMKL Extended Eigensolvers WARNING: Only the subspace has been returned.
Intel oneMKL Extended Eigensolvers WARNING: Size subspace M0 too small.
Intel oneMKL Extended Eigensolvers WARNING: Solver did not converge (number of loops reached maximum allowed.
Intel oneMKL Extended Eigensolvers have successfully converged (to desired tolerance).
Intel oneMKL Extended Eigensolvers: List of input parameters fpm(1:64)-- if different from default
Intel oneMKL Extended Eigensolvers: Resize subspace %d
Intel oneMKL Extended Eigensolvers: Size subspace %d
Intel oneMKL Extended Eigensolvers: complex double precision driver
Intel oneMKL Extended Eigensolvers: complex single precision driver
Intel oneMKL Extended Eigensolvers: double precision driver
Intel oneMKL Extended Eigensolvers: fpm(%d)=%d
Intel oneMKL Extended Eigensolvers: single precision driver
Intel oneMKL FATAL ERROR: Cannot load %s or %s.
Intel oneMKL FATAL ERROR: Cannot load %s.
Intel oneMKL FATAL ERROR: Error on loading function %s.
Intel oneMKL FATAL ERROR: MKLMPI wrappers are NULL.
Intel oneMKL FATAL ERROR: This system does not meet the minimum requirements for use of the Intel(R) Math Kernel Library.
Intel oneMKL FATAL ERROR: cannot load %s or %s.
Intel oneMKL FATAL ERROR: cannot load %s.
Intel oneMKL FATAL ERROR: dynamic library %s is not convenient for this processor.
Intel oneMKL FATAL ERROR: memory allocation error.
Intel oneMKL INTERNAL ERROR: Condition %d detected in function %s.
Intel oneMKL INTERNAL ERROR: Insufficient workspace available in function %s.
Intel oneMKL INTERNAL ERROR: Issue accessing coprocessor %s.
Intel oneMKL INTERNAL ERROR: Not enough work memory in function %s
Intel oneMKL INTERNAL ERROR: Optimization cache's size limit exceeded.
Intel oneMKL POISSON SOLVER ERROR: 
Intel oneMKL POISSON SOLVER WARNING: 
Intel oneMKL RCI CG ERROR: 
Intel oneMKL RCI CG WARNING: 
Intel oneMKL RCI FGMRES ERROR: 
Intel oneMKL RCI FGMRES WARNING: 
Intel oneMKL ScaLAPACK fatal error: cannot allocate memory, aborted.
Intel oneMKL TRIG TRANSFORMS ERROR: 
Intel oneMKL TRIG TRANSFORMS WARNING: 
Intel oneMKL WARNING: %s function associated with Intel(R) Xeon Phi(TM) x100 Product Family has been deprecated. Intel(R) Parallel Studio XE 2017 is the last supported version for this function.
Intel oneMKL WARNING: CPU type %d is not suitable for this processor.
Intel oneMKL WARNING: Library %s (oneMKL type %d) is not suitable for this processor (oneMKL type %d).
Intel oneMKL WARNING: PGI support is deprecated and will be removed in the Intel oneAPI Math Kernel Library 2025.0 release.
Intel oneMKL WARNING: Support of Intel(R) Advanced Vector Extensions (Intel(R) AVX) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library will use Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) instructions instead.
Intel oneMKL WARNING: Support of Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library 2025.0 will require Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
Intel oneMKL WARNING: Support of Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) enabled only processors has been deprecated. Intel oneAPI Math Kernel Library will use Intel(R) Streaming SIMD 2 Extensions (Intel(R) SSE2) instructions instead.
Intel oneMKL WARNING: incorrect conditional numerical reproducibility mode, MKL_CBWR_AUTO is set
Intel oneMKL function load error: %s.
Intel oneMKL function load error: cpu specific dynamic library is not loaded.
Intel(R) 64 architecture
Intel(R) Advanced Vector Extensions (Intel(R) AVX) enabled processors
Intel(R) Advanced Vector Extensions (Intel(R) AVX) with F16C instructions support
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX-2) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost)
Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2) enabled processors
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) enabled processors
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, FP16 (limited) instructions, and Intel(R) Advanced Matrix Extensions (Intel(R) AMX) with INT8 and BF16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, FP16 (limited) instructions, and Intel(R) Advanced Matrix Extensions (Intel(R) AMX) with INT8, BF16, and FP16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support for INT8, BF16, and FP16 (limited) instructions
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost)
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost) and bfloat16
Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX-512) with support of Intel(R) Deep Learning Boost (Intel(R) DL Boost), EVEX-encoded AES and Carry-Less Multiplication Quadword instructions
Intel(R) Architecture processors
Intel(R) Streaming SIMD Extensions 2 (Intel(R) SSE2) enabled processors
Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) enabled processors
Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) enabled processors
Intel(R) oneAPI Math Kernel Library Version 
Internal error
Internal error in %s: memory leak
IntersectAny
IntersectAny2L
IntersectAnyRC
IntersectAnyRC2L
IntersectClosest
IntersectClosest2L
IntersectClosestRC
IntersectClosestRC2L
Invalid argument
Invalid call sequence
Invalid error code
Invalid error number
Invalid factor option
Invalid message argument descriptor
Invalid message level
Invalid message request. This should never happen in a normal situation.
Invalid message request. This should not happen under normal circumstances.
Invalid operation
Invalid option
Invalid reorder option
Invalid string descriptor
Invalid structure option
Invalid termination level
Io7<+
Io:7
IoT;C
Ip;"C
Iq!;a
Iq!;o
Iq~;Y
Isn8
It is also possible that parameter IPAR(1) was altered by mistake outside of the routine.
It is also possible that parameter ipar[0] was altered by mistake outside of the routine.
It is possible that future usage for replacement of small diagonal values
It may be an error in one of the parameters.
It may be an error in one of the parameters. The method may fail to proceed.
It was probably altered by mistake outside of DFGMRES routine. The solution may be wrong.
It was probably altered by mistake outside of the routine, or some characters in
It was probably altered by mistake outside of the routine, or the fifth character in the
It was probably altered by mistake outside of the routine, or the first character in the
It was probably altered by mistake outside of the routine, or the fourth character in the
It was probably altered by mistake outside of the routine, or the second character in the
It was probably altered by mistake outside of the routine, or the sixth character in the
It was probably altered by mistake outside of the routine, or the third character in the
It6"
ItE;<
Iu;R
Iuq=+
Iv*;zy
Iv9w
Iw;$7
Iy1:r
IyF;2\t
IyK;
Iz&94Z
Iz\t;OJ
Iz\v<8
Izj<
I{n<0
J <cL
J$;r1
J$td
J%=hO
J&J8
J'>P0
J'j;Z
J(8F
J(E9$
J):9X
J)\r;xhX
J*=Gt
J,88
J-;mh
J.m<Q
J09K
J0H:
J0I=
J0O<"
J0R=
J1:%M
J1:a
J27:
J2<2h"
J2O;
J2};S
J30;
J3:s
J3;8
J3;e
J49Z
J4;Q
J4;Y
J5;P=
J5;WN
J5<#h
J5<y
J6>V
J6R<
J6Z;
J7>]b
J7M}
J7S,
J7b:S
J7h;
J8dw
J93=
J94=
J9<G
J9Gc
J9Pc
J9Qn
J9UHF
J9\rB
J9\v3
J9pU
J:&F4
J:;5W;dw
J:@eR
J:I9
J:PEA
J:SZL::wl:#\v
J:TRH
J:U\vl
J:Vt\
J:Zs
J:f|j
J:i+O
J:r;j
J:wA
J;1e
J;2q
J;4R
J;76
J;EI
J;K[U9ly
J;M6
J;OI
J;OV
J;S#D
J;T1
J;Un#;J
J;_RY
J;aB
J;fs
J;g@G
J;hh
J;hs
J;kD
J;mDe
J;nL
J;nO
J;rT
J;vlY
J<"ac
J<23
J<6B
J<B1k
J<BzG
J<Cw
J<F3-
J<HZ
J<MTx
J<Q2F
J<RH
J<Uu
J<gx
J<mY
J<nu`
J<x#T
J<x|2
J=8F
J=8y
J=C8
J=Pu
J=f2
J=s!6
J>F*j=s
J>HCm
J>M9
J?8r
J@1;C
JAKgdB
JC:8B
JC;v
JC=B
JCmQ,B
JD90
JDJ:
JEO;K
JF;8S
JF<W^
JG1>jY
JG2>
JG<e
JIU<:O
JJ:2uQ;`
JJK;w
JJi;
JKM<^
JKi=
JL:St
JL?T
JL\v;C
JM:x
JM;IU
JM;h
JM>$u
JOB;t
JP;l
JP<u
JPN:
JPf;|
JQ;2
JR:D
JS5:
JS:R&
JS<a\r
JSJ:
JSv:J~
JT;w
JTF:
JTj<
JU/9F=3
JU:YU
JVC;fN
JW;p
JW=2
JW=Z
JWP:;
JWP:>
JX/>R
JX=$W
JX@=1
JXK:
JXo;
JY;.iF;\rl
JY;LC
JYk;\n
JZ;pm[
JZ<h
JZY;
JZz9
J\f=d3a
J]f=Dh
J^zW
J`8R%
Ja8N
Ja:v
JbT:;ZB:
Jc:"f
Jcq:
Jd0;b
Jd;LF
JdK;
Je]:4
Jez:
Jg<L
Jg<v
Jgv<p_&
Jh:U
Jhn=
Jl<MnA
JlB;
Jn&<S
Jn8;r
Jn?L
Jo;ZQK
JoL<5
Jog:
Joz:
Jp<nz
Jp=Y
Jq:o
Jr2:
Jr5<P`$
Jr7>
Jr;qn
Jr>uP
Jrr;
Js:yt
Js;B
Js;r
JtC=L#
Ju:G~
Ju=s2
JuV;
Jv,=H5
Jv:y
Jw:T
Jw=qX
Jx92
Jxd=
Jy:8k
Jy:eD
Jy;y
JzP<
J}:Mg
J~A<q\vi
J~o;C
K :Ox
K!WC
K%9Xk
K&9X3
K&<Lc
K'l:4
K*:dj
K*;1r
K*w;B
K+9sq
K+U<_jr
K,?Xt
K->SS
K.;kP
K/29
K07/
K0<EP
K1<#l
K29}
K2:7
K3:5Y
K3V;
K4Y<\n
K5+;L
K5<d
K6;on
K7:MD
K7;h`
K7s;
K8B(
K8Q=
K8[Hg
K96J2
K98!
K9<K
K9Y3u:
K9ZTO
K9b[
K9el#
K9fS
K9iK
K9k_(;mA4
K9lU.:
K9s\
K9v4%;Fu&:G
K9wS
K:(q4
K:15
K:T;r
K:WI
K:b8V
K:bJ
K:d8
K:lg
K:pB
K:q0
K; Na
K;&wF
K;,qa
K;3M"
K;3x#
K;4V
K;4d
K;9r
K;>2B
K;CI
K;GqY:"
K;L2
K;LV
K;N0
K;T3L:
K;VKN
K;YM<
K;YR
K;cb
K;f4
K;g\rd
K;gg
K;h5+
K;j2
K;vmA
K;ws
K;}cz
K<$Jr
K<E\4
K<Gv
K<H15
K<ID
K<Vw
K<aXG;0
K<dN]
K<nBb
K<nk
K<q2
K<rC5
K<tg
K<wgs
K=8A
K=9ev=
K=DD,
K=K9
K=OX
K={wl>r1
K><Vy
K>H(L>Sg
K>exU?3}
K>wc
KA0<
KA9I
KB:n-
KB:w
KB;1R\v;
KB;=f
KD:w
KD>H
KF<H
KFy:
KG;fK
KG<A
KHf9}rx9
KHi;\h
KHn:
KI;)hR;
KII;
KIJ<
KJ:9
KJj;Z~
KJn>EN
KK"8
KKn=s
KLq<
KM9R
KM:^C
KM;g
KMl<
KNCNI
KQ;kT
KQh;>
KR;%D
KS<m
KSX<
KSo8
KT4;
KT:Nr
KT:PI
KT:n
KT;r
KTW;Xr
KU2<
KU:J
KV=g
KV`;c
KW;wy%
KW?Vf
KWH<I
KY4<@
KYF=
KZI:5\t
KZ[:i!N
KZx=
K\r<GV
K\v\tr\r0n
K]F;^3O
K^S<W
KbP9v\
KbR;
Kc;A
Kc?d
KcM<
Kd %f %f %f\n
Kd#<y
Kd:>J
Kernel32
Kfa=
Kfl;
KgdB
Ki;r
KiA;\f
Kk;\S39
KkV9
KkV:T
Km|;jV7
Kn;UJ
Ko8<*
Koe;`
Kp7k
Kp;L
Kp=x
KpL<I
Kq\n9
Kr2<
Kr:m$
Ks %f %f %f\n
Kt:Sj
KtK:
Ku:9
KuM:
Ku\t;r
Kw8;M
Kw;j
KwR;$
KxE>
KxS:HQ^
Kxm9
Kxr:
KyS=E
KzD;
K{R9
K~Q9I
L <gt
L F"p&F
L!9To
L#;IN
L#r<u
L$:Tb
L&U for matrix number %d deleted
L&U for matrix number %lli deleted
L'f9
L*09
L.E<4
L0+;O
L0:n
L0;CV
L0;w
L0?9
L0x:b
L1<0I
L1W<*
L28LF
L2:xp
L38;<d
L3=,J
L3>l
L4;V
L4;q
L5#;48
L5;Wp<;
L5<4
L5a9
L6<v|Q
L7;a
L7K<>
L8<G
L8<wNb
L8Q;
L8S#
L8T9
L9:W#
L9;0
L9<d:
L9@JL;4w
L9C:
L9Lw!
L9M+
L9^h
L9ar
L9hc\n;
L9iR
L9pO
L9qs
L9x#
L:1SM
L:5v
L:?iN
L:JO
L:NX
L:T\tn
L:Zfc;
L:a7
L:bT
L:fc
L:g6
L:i2
L:kI
L:l8
L:qx
L:tl
L:up
L:{Lr9
L;5]n
L;6o\f
L;7i
L;8v
L;9Bl;.u
L;AF
L;BA
L;Ce
L;NR
L;Oc5
L;P6g
L;PPZ;
L;Tg
L;U\n2
L;VS
L;WZ
L;Yw}
L;bB
L;ba
L;eZ
L;iA
L;iW
L;sMi9
L;swg:
L;u5"
L;vfg
L<0i
L<;8A
L<EJ
L<Fv9
L<GH
L<Kj>
L<OHq
L<TE
L<\vL6
L<c6
L<iWj<
L<m8
L<pA
L=E7
L>aM
L>qa
L>ti%
L?9u
L?LU
L@:ii
LA;$H
LANG
LAPACKE_NANCHECK
LAPACKE_sgesvd
LAPACKE_sgesvd_work
LAQR
LBk9
LC*;rF
LC;W
LCW&qB(
LD9;[
LD:,j
LDB:
LD[:8
LD_LIBRARY_PATH
LDj:
LE&:g
LEi;
LF;\L
LFJY
LG<y
LH:Q
LIg=
LKS=
LL(;sd
LL:7
LL;d
LL<P5
LLS;D\n
LM;PS
LM=0
LM>:Gs
LMr;
LN9<*
LN:5
LN<s\r
LO=hb
LP8<:
LPd=
LPj:9
LQ9?
LQ::3F;U
LQ<\fm
LQE<
LQXC
LR;xP'<
LS99
LS9N
LS:x
LTU;
LU;3C
LUw:Z
LV{;z
LW%8
LW3;3
LX;q
LY<;Q
LZ6;Dc(
LZB;
LZCNT
LZCNT 
LZO=
L\n\;oPZ:rq>;
L\r<oK8
L\vN;Ye39
L];aa
L]<WR
L]c9
La9;F
Lb:v
Ld0:
LdD<
Ldy<x4
Left
Level Zero raytracing support missing
Lf:4
LgF;
Lh:a
Lh=x#
ListenerPosition
ListenerUp
ListenerView
Lj:U
Lj;Cw
Lj>m
LjN;S
Lj\t9j
Ljy=
Lka;
Lm;E]
Ln=8$
Lo;Z
LoC=
LoadLibraryExA
LoadLibraryW
LookupPrivilegeValueW
Lower
Lpq=
Lr*9
LrM;
LrO;
Ls=\v_ ?5]Q?
LsF<
Lt:R
Lt:b9
Lt;V
Lt<xU
Lu:/vR
Lu;4
Lu=K
Lv;7
Lv<A
LvBsk
Lvh:
Lw+<S
Lx!9
Lx<Jr
LxN9h
Ly;:x
Lyr=g
Lzj9
L{9%m
L{;JlA
L}7;R
L}:NS
L~Z<9
M Z7
M$9f
M$P8
M$P9
M$a;R
M&U9
M'9m
M)<2H
M)f=8
M*9r
M+2;5V
M,b<c
M.u;Z
M09cB
M0<rq
M119
M19uA*
M1:Y
M1;c
M2;A
M2;Q
M4;2
M4<2
M59G
M5:7|
M5;W
M5;k
M6%:V
M6;D
M6^<v
M7:t
M82G
M88S
M8J<^N
M8xy
M9*zL
M9,<o
M9Dm
M9N=q
M9yU
M:)mv
M:-W9
M:3t
M:4N
M:5D
M::\fR6=F0
M:FWC9
M:Jf
M:h&J
M:h9
M:mA
M:mZI;
M:st\r
M:u73
M:uI
M:vP
M:wl
M:yu
M;3k
M;7;B
M;7kW
M;<08
M;<ZY
M;Cis
M;Ge
M;Lq
M;PS
M;R+i
M;RS
M;Tc
M;U|S
M;Zc
M;a)Y:cWa;
M;d8
M;gz
M;i~o
M;jK
M;jx\t
M;uZ)9
M;vd
M;vi
M;yKL;
M;z^s
M;|xs
M<3t&
M<G\n8
M<LK
M<N18
M<OZP
M<Vs
M<\tvl
M<ej
M<iP
M<qR
M<v4S=dp+
M=Ur
M=ct
M=lU,
M=xZ
M=yR~
M>9rT>
M>Bh
M>H;l
M>N:hO
M>jYX>
MA!;b
MA4'
MA;7
MAM;
MAO;o
MB9;S
MB;y-
MB<S
MBEU
MBlur
MC:nE
ME<7
METIS algorithm at reorder step is turned ON
MF<C
MF=0
MFB`
MFBv
MH;r
MHV:
MHa<L
MHv;f
MI:H
MIC_LD_LIBRARY_PATH
MIX;
MJ;R'
MK;P
MKLROOT
MKL_CBWR
MKL_DISABLE_FAST_MM
MKL_DOMAIN_ALL
MKL_DOMAIN_BLAS
MKL_DOMAIN_FFT
MKL_DOMAIN_NUM_THREADS
MKL_DOMAIN_PARDISO
MKL_DOMAIN_VML
MKL_DYNAMIC
MKL_ENABLE_INSTRUCTIONS
MKL_FAST_MEMORY_LIMIT
MKL_MPI_PPN
MKL_NUM_STRIPES
MKL_NUM_THREADS
MKL_SOMATCOPY(%c, %c, %zu, %zu, %f, %p, %zu, %p, %zu)
MKL_VERBOSE
MKL_VERBOSE %s %s\n
MKL_VERBOSE WARNING: %s\n
MKL_VERBOSE oneMKL %d.%d
MKL_VERBOSE_OUTPUT_FILE
MN='l
MOVBE
MOVDIR64B
MOVDIRI
MOw;
MP9'/r
MP;4nf;
MP>9(4
MPI_LOCALNRANKS
MQO;AG
MRY<
MS:DP-
MSRLIST
MU:0
MVI;%
MW<U(
MW\;yP)
MWp=H
MX;xy
MY0;
MYF;
MZ;8
MZC;
M\;Vd
M\nB;i
M\vk9
M`=0h
Ma%=sQ
Making IPARM(16) comply with IPAR(1) and IPAR(15).
Making IPARM(17) comply with IPAR(1) and IPAR(15).
Making IPARM(18) comply with IPAR(1) and IPAR(15).
Making IPARM(19) comply with IPAR(1) and IPAR(15).
Making IPARM(20) comply with IPAR(1) and IPAR(15).
Making IPARM(21) comply with IPAR(1) and IPAR(15).
Matching is turned ON
Matrix checker is turned ON
Max split depth: 
Maximum fill-in input parameter is greater than or equals
Maximum memory requested that can be used=%llu, at the size=%u
Mc:4
Mc=z
Mc_;u
Md9;
MdU;\nV
MdZ= 
Me<F
Mf:\nVD:1
Mh7<
Mh<<l
Mi&:l
Mi9sq
Min node overlap: 
Minimal supported version of the memkind library is 1.1.0
Minimum degree algorithm at reorder step is turned ON
Mj;DX
Mj;Z
MjY:
Mjj<
Mkc9Z
Mkd;`8
Mkx:
Ml98
MlB<
MlC:5
MlC;
MlJ;DhE
Mle<%
Mlh<
Mm6<
Mn,<e
Mn;I
Mn<C
MnC|
MnY>g|&
Mo4>7
Mo:v
Mo<iA
Mp0:I
Mp>I
Mr0=
Mr8=1
MrO:
Ms59
Ms:0
MsD=
Mt<p
MtR:gTK9
MuE9
MuV;
Mw7<
Mw=1T
MwM:l
MwU;
Mx9;1
Mx=;81
Mz;A
MzY:\t
N!;y0
N$;u3
N':1f
N()8Ix
N(J=S
N*;eaL;A
N-<odm
N-q;q
N.9c\fu;
N0<H
N0?<E
N0B;<
N12:T\rz
N1;S
N1<C&
N2M>
N31<\n
N3;:qV
N3<k
N4':q
N4;2b
N4NNN
N5;q
N5e8
N5h:\t
N7(S
N7;<5
N83:
N86+
N8=?3w=
N8B:
N8o;9
N9%m
N96n
N9Rq
N9W@
N9oB
N9yk
N:"l9;H0
N:06
N:6h
N:9m
N:=s7
N:KT
N:Sx
N:TK
N:UP
N:X8
N:Z3
N:aV
N:a{R
N:b7
N:d$p9
N:gJ
N:h<c
N:m[4
N:xV 9lwm:L
N:yX
N;"Nv
N;0E
N;1D
N;7h
N;<LS
N;EN\f<Wm
N;H7c
N;J3)
N;Nj
N;Po
N;Rq\v
N;TU
N;TkL
N;Tw
N;Y6\f
N;gV
N;iF
N;kE
N;kS
N;kg
N;mt
N;qJ
N;wQ
N;x6
N;yk
N<03(
N<BNN
N<EQ
N<FVN
N<R*NbJ*HI
N<\v5m
N<b"V
N<bB
N<ea
N<fr
N<o;V
N<vB
N= L9
N=/tP
N=y u
N>9;X
N>AO
N>Ae?
N>OD
N>ct
N>pl
NA:o
NA;4*
NA;Re0
NA;i
NAME
NB;9*
NDf=
NE9)
NE:z
NEON
NEON 
NF-;FE
NF<ov
NFE9
NFj; 
NF}8
NG=l
NGH;
NGV:ps
NH;h
NHv<
NI2<
NIq;
NJ;0
NJY9
NK;9
NK=XiG
NK|;b
NLT;
NLb;
NM:d?
NM<D
NN6:
NN<o
NNR;J
NO#;R
NO+;p
NOM;N
NOj>x
NP:DJt:
NP=fW
NR;b
NT>g
NU:tv\
NU;OW
NU<I
NUK>
NVG<j
NW;Fn
NW;J
NX;t
NX;vm
NX<C
NY;O
NYl8
NZ<3
N\;n4
N\f<J8
N\ty<J
N\vk;d5
N^9Y
N`;qE
Na:M
Nct9,
Nd<K
Ne:K
Nehalem
Nev<
Nf0;
Nf2<
Nf8;
Nf;ve
Ng48
Ng;a7a
NgQ;
Nh;c
Nh;o
Nhv<
Ni%<5
Ni)9sW3
Ni<k
Nj7<h`]
Nj\:W
Nj`<f
Nk0;
Nkp=
Nl/7D
Nl9`
NlE=X
Nm,:p3
NmX:
Nmw:
Nn;x
No (P)CG iterations will be performed as parameter
No Error
No FGMRES iterations will be performed as the limit for the iteration counter
No such kernel in program
No transpose
Node overhead: 
Non-unit
Not a square matrix
Not enough memory for OOC mode
Not enough memory to allocate work array in %s\n
Not enough memory to transpose matrix in %s\n
Np9z
Nq<N
NqW;
Nr;N
Ns:W.
NsCP
Nt<b
NtV9
Nu=t
NuM:9B
NuW:
Number of CPUs: %i
Number of columns less than one
Number of cores: %i
Number of items read=%d
Number of items read=%lli
Number of nodes in corresponding non-split BVH: 
Number of nodes: 
Number of non-zeros greater than nRows*nCols
Number of non-zeros less than nRows
Number of rows less than one
Number of tests: %i
Number of threads: %i
Number of triangle refs: 
Number of triangles: 
Number of unknowns computed in backward solving step
Number of unknowns computed in forward solving step
Nuz>
Nv:Kn
Nv<v
Nw7<
Nw<ut
Nxr;z}C
Ny:b
Nz>c
NzJ<
NzL;R
Nzf;
Nzt<[
O <6q
O <qp
O!dx
O#J8
O$:yO
O%<bZ7
O%Y>Z
O(>wy
O)P8
O/M:Yj
O08Vo
O0S:#Q
O2;a
O3:R
O3=7
O44:
O4<wD
O4I=
O6f;
O7;CN
O7;R;
O7\r<]@q:K(.<
O7bO
O7m:
O82b
O8:v
O8Dq
O8eq
O95D
O9=D
O9>g+
O9DQ#
O9Z"
O9aU
O9g8
O:56
O:B'1
O:FJ
O:L`z;6G:
O:XRK
O:XZ0;
O:\fh
O:c8
O:j6
O:kr#
O:nj
O:np
O;)Kh97H
O;0JV<
O;1O
O;1j
O;5I
O;66
O;7B
O;94
O;;S6
O;C2
O;EMX:L1
O;F1I
O;JP
O;Je)
O;Lm
O;N%Y
O;PM
O;Rk
O;Rm
O;Si
O;a>D
O;dG
O;fW
O;in
O;jX2
O;nu
O;rY
O;wc
O;xY~:3
O;yD
O<1=t
O<3W
O<:hz
O<D;G
O<I8r<55
O<JX
O<LO
O<N?Y
O<PTS=
O<h8@
O<kC
O<oH
O<os
O<pGr
O<uO
O<w q
O<yq
O=1bA
O=:iT
O=CS
O=Lk
O=g4s
O=oU
O=pR
O=xW
O>BfL
O>a4
O>nm\r
O>pF(
O>tC
O@;w2
OA;J
OAO<<
OAS<U
OB9>&L
OB\f;F
OB{9N
OC;J
OC<m
OCB9
OCHK
OCQ=
OCw>
OD!<J
OD+9
OD<NL
OE:;Cm
OF(<O
OF:b
OF>8
OFL<u
OFM;
OG:MW
OH7<
OH:Kp
OHDR
OI<a
OIo=
OJd=
OK;)n
OKm:t
OL1;
OLg;
OM3:
OMPI_COMM_WORLD_LOCAL_SIZE
OMP_NUM_THREADS
OMU:
ON;1
OP4=q
OP9f
OQH;
OQV;
OT9IGU9
OTO;
OTa;
OU:x
OUx<
OV;q
OV>L
OVW<
OVu;
OXi<
OY4;
OY;;T
OY;MC
OZ:u
OZ;H
OZR;
O[19
O[x:T
O\n8g
O]3<W
O]T<6
O]g:d
O]y:u
O_9k
Ob;D
ObP;7
Obk:nz
Oc>n
OcE9H
Oci;60
Od:KF,;
Od>&c
Oe0<-
Oe:rq
Oe\n99
Oeb:
Oey7g
Oey<
Of:1
Oh6>I
Oh:t84;
Oh;1O<
OhT<
Ohq:
OiV;
Ojp=
Ok?O.
Ol;2
Om;Fq29"U`;
On;5
On;G
On>s
OnG<5
Oo1;
Oo<C`2
Ooy:G9c;
OpenCL compile failed:\n\n%s
OpenCL.dll
Oq;j
Oq<s
OqD>
Or;1
Orv:
Os:Db
OsV:
Osq<%
Oss;
Otherwise, set the 1st and the 2nd character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, set the 3rd and the 4th character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, set the 5th and the 6th character of parameter 'BCTYPE' equal to {P} during initialization
Otherwise, the Poisson solver may fail to proceed
Ou:|J
Ou=g[P>
OuD;
OuJ:
Out of Memory
Out of memory
Ov=y
Ow>S
Oy5;
Oy;6.
Oz;80
Oz;9
Oz\n<rg
Ozc;
O}'<soV
O}z<p
P h;1
P!;OW
P!<PZ
P!p;x
P"9T
P";UO
P%;7vy:
P%D9
P%Y<Z
P%w9
P&u:.Qs
P&x:h
P':Udo;
P)<7P
P*;0pz;
P+<TN
P,9E5#:
P.T:X
P08~
P0X=p
P0o;
P1/<l
P1;x
P1=h
P1L;`
P2 z
P29;
P2<C.s
P38:
P3:GG.
P3;p
P4;5
P5?V
P5?e^
P5q9
P5t;
P6<dx
P6>D
P6pay
P78;
P79s
P7g<hVB
P8,H
P85%
P88EB8j/
P8~m
P9.C
P90p
P9;L
P9;l
P9M<
P9W/
P9WL
P9ue!9
P9v_W:
P9xg
P:XJ
P:d;4
P:j4
P:kE
P:lb
P:mb
P:of
P:tWY
P;-sp;Q
P;1A
P;2p-:cY
P;6G
P;9G
P;;%z9P
P;Ed
P;GuF
P;Iy
P;Mz
P;NR
P;Qr
P;XG
P;Zw
P;\njO
P;iP
P;ia<
P;lY
P;nR
P;ro
P;tB
P;xd
P<"XV
P<;pVq;y
P<A)a
P<CaH
P<FAR
P<IZ
P<LSw
P<Nv
P<aK
P<aq(
P<at
P<dc
P<gh
P<qC
P<rh
P<ut&
P<vV
P<wm
P<zZ\t
P=9K
P=KU
P=X&a
P=id1=u>
P>9JJ
P>FDO=mJg=
P>lE
P>v#T
P?uZ
PA<0
PARDISO Internationalization error. Message %d is unknown.
PARDISO Internationalization error. Message %lli is unknown.
PARDISO_OOC_CLOSE_FILE_ERROR occurred: %s
PARDISO_OOC_DELETE_FILE_ERROR occurred: %s
PARDISO_OOC_NUMBER_OF_READ_EQUAL_ZERO occurred: %s
PARDISO_OOC_NUMBER_OF_READ_NOT_EQUAL_COUNT occurred: %s
PARDISO_OOC_NUMBER_OF_WRITE_EQUAL_ZERO occurred: %s
PARDISO_OOC_NUMBER_OF_WRITE_NOT_EQUAL_COUNT occurred: %s
PARDISO_OOC_OPEN_FILE_ERROR occurred: %s
PARDISO_OOC_OPEN_MODE_FILE_ERROR occurred: %s
PARDISO_OOC_READ_EOF_ERROR occurred: %s
PARDISO_OOC_READ_INPUT_PARAMETERS_INCORRECT occurred: %s
PARDISO_OOC_READ_SEEK_ERROR occurred: %s
PARDISO_OOC_WRITE_EOF_ERROR occurred: %s
PARDISO_OOC_WRITE_INPUT_PARAMETERS_INCORRECT occurred: %s
PARDISO_OOC_WRITE_SEEK_ERROR occurred: %s
PA\;4
PAr;/
PBNDKB
PC<C\r
PCLMULQDQ
PCONFIG
PCP8
PCZ;
PCs9P
PDD<
PE:WGO:
PEE<h
PF;7
PFd=V
PG;82-;
PG=t7
PH:6
PHX<
PH\t9|
PI:m
PJ;ug5;m
PJ<u
PK;F
PK;M
PKy:
PL2<
PL;E
PL;Z
PL<M
PLT:
PM<H
PME<NT
PO;.c
PO<E
PO>O
POPCNT
POPCNT 
POg;
PP=8
PPu=
PQ81
PQA;^
PQN;3
PR;J
PR;r
PREFETCHI
PS;@l
PS;RG]
PS;U
PS;m
PS<6
PS<l
PS<m
PS=f
PS~;ok]
PTO:
PTWRITE
PTs7g
PUB;
PUR=
PV:R3\f;
PVX:
PWd9
PX2?q\v
PX:I
PX;"0
PX\fD
PZ:v
P\f<Ps
P\fk9
P\n;ae
P\vT8D5
P^h:z
P`m8
Pa:#5
PaS<
Parallel Direct Factorization is running on %d MPI and %d OpenMP per MPI process
Parallel Direct Factorization is running on %d OpenMP
Parallel Direct Factorization is running on %lli OpenMP
Parallel METIS algorithm at reorder step is turned ON
Parameter ?PAR(1)=%e (the size of the domain along x-direction)
Parameter ?PAR(2) was probably altered by mistake outside of the routine.
Parameter ?PAR(2)=%e (the size of the domain along y-direction)
Parameter ?PAR(3)=%e (the size of the domain along phi-direction)
Parameter ?PAR(3)=%e (the size of the domain along z-direction)
Parameter ?PAR(4)=%e (the size of the domain along theta-direction)
Parameter ?par[0]=%e (the size of the domain along phi-direction)
Parameter ?par[0]=%e (the size of the domain along x-direction)
Parameter ?par[1] was probably altered by mistake outside of the routine.
Parameter ?par[1]=%e (the size of the domain along theta-direction)
Parameter ?par[1]=%e (the size of the domain along y-direction)
Parameter ?par[2]=%e (the size of the domain along z-direction)
Parameter DPAR(5)=%e should be positive.
Parameter DPAR(7) was probably altered by mistake outside of the DFGMRES
Parameter DPAR(7) was probably altered by mistake outside of the DFGMRES routine.
Parameter DPAR(7)=%e should not be negative.
Parameter IPAR(1) is not equal to the parameter N.
Parameter IPAR(1) must be a positive integer.
Parameter IPAR(1) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(1)=%s is not equal to the parameter N=%s.
Parameter IPAR(1)=%s must be a positive integer.
Parameter IPAR(10)=%s is not in the admissible range {0,1,2}.
Parameter IPAR(11)=%s (the number of intervals in phi-direction)
Parameter IPAR(11)=%s (the number of intervals in x-direction)
Parameter IPAR(12)=%s (the number of intervals in theta-direction)
Parameter IPAR(12)=%s (the number of intervals in y-direction)
Parameter IPAR(13)=%s (the number of intervals in z-direction)
Parameter IPAR(14)=%s is not in the admissible range from 1 to
Parameter IPAR(14)=%s should be equal to 0 before the first call to
Parameter IPAR(15)=%s should be positive.
Parameter IPAR(15)=%s should be positive. If you wish to run the
Parameter IPAR(16) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(16)=%s must be a positive integer.
Parameter IPAR(17) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(17)=%s must be a positive integer.
Parameter IPAR(18) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(18)=%s must be a positive integer.
Parameter IPAR(19) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(19)=%s must be a positive integer.
Parameter IPAR(20) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(20)=%s must be a positive integer.
Parameter IPAR(21) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(21)=%s must be a positive integer.
Parameter IPAR(23) was probably altered by mistake outside of DFGMRES routine.
Parameter IPAR(23)=%s must be a positive integer.
Parameter IPAR(3) must be equal to 1 before the first
Parameter IPAR(3)=%s is not in the admissible range {0,1,2}.
Parameter IPAR(3)=%s should be equal to 1 before the first call to
Parameter IPAR(4) must be equal to 0 before the first
Parameter IPAR(4)=%s is not in the admissible range {0,...,15}.
Parameter IPAR(4)=%s is not in the admissible range {0,...,63}.
Parameter IPAR(4)=%s should be equal to 0 before the first call to
Parameter IPAR(4)=%s was altered outside of the routine or commit
Parameter IPAR(5) must be greater than or equal to 0 before
Parameter IPAR(5)=%s is not in the admissible range {0,1,2}.
Parameter IPAR(5)=%s should be greater than or equal to 0 before the first
Parameter IPAR(6)=%s is not in the admissible range {0,1,2}.
Parameter IPAR(7)=%s is not in the admissible range {0,1,2}.
Parameter IPAR(8)=%s is not in the admissible range {0,1,2}.
Parameter IPAR(9)=%s is not in the admissible range {0,1,2}.
Parameter ipar[10]=%s (the number of intervals in phi-direction)
Parameter ipar[10]=%s (the number of intervals in x-direction)
Parameter ipar[11]=%s (the number of intervals in the y-direction)
Parameter ipar[11]=%s (the number of intervals in theta-direction)
Parameter ipar[12]=%s (the number of intervals in z-direction)
Parameter ipar[2]=%s is not in the admissible range {0,1,2}.
Parameter ipar[3]=%s is not in the admissible range {0,...,15}.
Parameter ipar[3]=%s is not in the admissible range {0,...,63}.
Parameter ipar[3]=%s was altered outside of the routine or commit
Parameter ipar[4]=%s is not in the admissible range {0,1,2}.
Parameter ipar[5]=%s is not in the admissible range {0,1,2}.
Parameter ipar[6]=%s is not in the admissible range {0,1,2}.
Parameter ipar[7]=%s is not in the admissible range {0,1,2}.
Parameter ipar[8]=%s is not in the admissible range {0,1,2}.
Parameter ipar[9]=%s is not in the admissible range {0,1,2}.
Parameters IPAR(1), IPAR(15) and IPAR(16) have incompatible values.
Parameters IPAR(1), IPAR(15) and IPAR(17) have incompatible values.
Parameters IPAR(1), IPAR(15) and IPAR(18) have incompatible values.
Parameters IPAR(1), IPAR(15) and IPAR(19) have incompatible values.
Parameters IPAR(1), IPAR(15) and IPAR(20) have incompatible values.
Parameters IPAR(1), IPAR(15) and IPAR(21) have incompatible values.
Parameters IPAR(4)=%s and from IPAR(5) to IPAR(10) equal %s, %s, %s, %s, %s, %s do not agree.
Parameters IPAR(4)=%s and from IPAR(5) to IPAR(8) equal %s, %s, %s, %s do not agree.
Parameters IPAR(5)=%s and IPAR(6)=%s do not correspond to each other.
Parameters IPAR(7)=%s and IPAR(8)=%s do not correspond to each other.
Parameters IPAR(9)=%s and IPAR(10)=%s do not correspond to each other.
Parameters are set to:
Parameters ipar[3]=%s and from ipar[4] to ipar[7] equal %s, %s, %s, %s do not agree.
Parameters ipar[3]=%s and from ipar[4] to ipar[9] equal %s, %s, %s, %s, %s, %s do not agree.
Parameters ipar[4]=%s and ipar[5]=%s do not correspond to each other.
Parameters ipar[6]=%s and ipar[7]=%s do not correspond to each other.
Parameters ipar[8]=%s and ipar[9]=%s do not correspond to each other.
Pc<mf\t;
Pcb;
Pcs<m
Pdj<
Pe?9
Percentage of computed non-zeros for LL^T factorization
Performance Summary (GFlops)
Periodic boundary conditions can be used only for a pair of boundaries simultaneously.
Permutation contains %d multiple element pairs (first: %d -> %d)
Permutation contains %d multiple element pairs (first: %d -> %ld)
Permutation contains %d out-of-range elements (first:  %d -> %d)
Permutation contains %d out-of-range elements (first:  %d -> %ld)
Permutation contains %lli multiple element pairs (first: %lli -> %lli)
Permutation contains %lli out-of-range elements (first:  %lli -> %lli)
Permutation is inconsistent.
Pf=:F
PgG;
Ph:d
Ph=\tcw
Pi:f
Pi;.P
Pj:Bq
Pj<w
PjO:=
Pk:1$
Pkj<
Pl<l
Pl>FE
PlI9$
Please contact Intel oneMKL Technical Support and provide as many details as possible.
Ply<
Pm.c
Pm;J
Pn2;
Pn:g
Pn;8
PnQ<
Po;4\f
Po;j
PoA<
Pp+;i
Pp;Wt
Pp<1
PpB;f
Pq8;
Pq;YK
Pr<c
Precision
Probably the data were altered by mistake outside of DCG routine.
Probe clustering complete. (%lld probes, %lld clusters)
Proceed with (-value) if IPAR(7)>0, aborting otherwise.
Product
Pt<h
PtG:
Pu-9
Pu.:U
Pu;j
Pv;p
Pv\f;n
Pvq:`
Pw;D
Px:1
Px:o
Pxm=b}
Py:I
Py:k
Pya<
P{;tiO;
Q g;#a39e,\:
Q$:JE
Q&=Ug
Q(X;v
Q*;9f
Q,9mv
Q,9{1
Q-5;x
Q-;EF
Q-;L2
Q0:WH
Q0<I
Q1<Z
Q1=n
Q1n;
Q2<x
Q2D<
Q3;E
Q3<[K
Q3};I
Q5N;
Q5V:
Q6<A
Q6<Gv
Q759
Q7;d
Q7F;
Q7^z
Q8:@uZ9
Q8=S
Q8g#
Q9-LM:
Q9;N
Q9C(L
Q9F3
Q9N:
Q9W:
Q9k@
Q9w{
Q:1g
Q:41
Q:5R
Q:IA
Q:SL
Q:Xji;
Q:gTH
Q:nDa;"
Q:th
Q:vk
Q:yn
Q:|mH9}
Q;0u
Q;4to
Q;CS
Q;Ht
Q;Iz
Q;M"F
Q;Me
Q;Pf
Q;Qk
Q;S;W
Q;TK.
Q;V>e
Q;aS
Q;fQ
Q;hA
Q;i\t4;8
Q;l4f
Q;qO\f
Q;rP,;9
Q;v#N
Q;v4
Q<5R7
Q<7q
Q<9v\f
Q<F+P
Q<Fj
Q<LL
Q<QY>
Q<Wu
Q<km
Q<l5
Q<l9
Q<n2
Q<q8
Q<tX
Q<ya
Q=?ai
Q=V7
Q=cQ
Q=iTL
Q=j3
Q=jN
Q=|dA
Q>6-N
Q>6e
Q>Y3
Q>hH
Q?:dL
Q?:xC
Q@:Av
QA;ll
QA<]R
QAx<
QC?l
QD3;
QD:i
QD;Q"*;tnt
QDI:w
QE<C
QEA>
QEm;)
QF1<
QF<k\n
QF<o
QG;m
QG<O
QG=e4
QGS:W
QH6;
QI);mF
QJ>I
QJr<h$4
QK;p
QKE=
QK[;pe
QL;c
QLV<
QLv;l
QM:&WJ
QMU<\r
QN:Q
QN;no
QO<^UC
QP;Y1
QP;g
QQ5>
QQ;q
QQP;}
QQ\r7
QR;a
QR<h
QR<y
QRU=$m
QS"9
QS";l
QS:o|2
QSA<
QT1<
QT;%B
QT;3RB=:?
QT;p
QTt;
QUT9
QV9n
QV:E
QV;j
QW1<|K
QW;'K
QW>p6
QWA<m
QX,9
QXz<%V
QY;4
QYa<
Q[=gc
Q\t:T6
Q\tB<a
Q`1<l3;
Qa;\rE
Qb:M8
QbC<
Qc<1
Qc<rGP
Qdg>
Qe<I
Qf'<u
Qf6=
QfF9
Qg/;b
Qg;]b
Qh9i
Qh=R
Qi9<`N
Qi;w
Qi<;q
QiE=
QiJ<
Qj2<2,
Qj\r:W
Qkj<<
Ql=R
Qlp9iF
Qn9,6
QnU7
Qnn:
Qo:j
QoA<
QoF9vG
Qp:P3W
Qp;4^B
Qp?AT
Qq7]
Qq<t
Qrt;
Qs;F
Qsd;
Qu;H
Qui=
Qv4<
Qv:g
Qv:i
QvC:
Qw6;
Qw:K
Qx$=nE
Qx15
Qx8q
Qx9a
Qx:+BF
Qy:8
Qy:r
Qy<u
QyC;
Qz2<-
Qz9'
Qz;Q
Q|K8
Q}H9
R#59
R(;fJ
R+;9v
R+;bk
R,C,I
R,C,M
R0<H
R0L;=
R1Y;
R1q;
R2<S1r
R2>O
R3#;q
R3<0
R3<\vm
R3F;
R4\f9
R5/;B
R6;M
R6;S+O
R6;g
R6<LO
R7<g
R7S;
R8"N
R8?Bh9?
R8N$
R8bX
R8sjz9
R9+Au
R9.v
R94-
R9;P
R9=Io9<}D5=
R9C>
R9NPh
R9N^
R9PH=;
R9Wd9;
R9Y<
R9ig
R9l.
R9l0
R9m;
R9m>,P
R:+gh
R:0R
R:>r2
R:N1
R:fg
R;4K
R;4b
R;5Qt
R;6Ab
R;Fr7
R;JIG;
R;Jo 
R;LO
R;O9
R;Tm-
R;UU
R;eJ
R;in
R;kf
R;kx
R;ly
R;nU
R;uf
R;zY
R<06B
R<4Z
R<5^N
R<;sM
R<<nA
R<IA
R<Nx
R<ek
R<gy]
R<je
R<l6y=E`0=
R<nz
R<om
R<rB
R<wF
R=2U
R=6S
R=HzP
R=O`R
R=Wn
R=of
R=uK
R=xRl=
R>RW
R>SnR
R>hD
R>ya{
RA4;9
RA6<[
RA9<
RAA;z
RAO_INT
RB,<y
RBd<
RCF;Z<
RD;y
RD=6>k
RDPID
RDRAND 
RDRND
RDSEED
RE=g_
REY<
RE]:g
REtL
RF:9RL
RF=in[;
RG=2
RG=7s
RG>JJ
RH<PX
RH<R
RIQ:az
RIR>
RJ9<
RJ><G
RK>VWI=N
RMk<
RN;3\f
RN<Y9
RNP=eN?
RN\v9
RN]<e
RO9=
RO:n
RO;U
RO;Uk
ROT;
RP;m?
RP<h
RRG<F0
RRX8Cv
RS:T/
RSDS
RT;l
RTC_GEOMETRY_TYPE_GRID is not supported
RTC_GEOMETRY_TYPE_POINT is not supported
RTC_GEOMETRY_TYPE_USER is not supported
RU;J
RV;;6
RVk:
RW:iw
RW;{n
RWC=
RX;u1n
RX<N
RY3:y
RYo:
RZ9)
RZ;5
RZT;
R[<bRl<v`p=4
R\n0\f0
R\nK9r#M
R\r4:BF:
R\t:f3
R^P9
Rb)9
Rb;N
Rb=ib>>s
Rd<n
Re1;(
Read failed
Read type=%d
Read type=%lli
Reb;,9
ReceiverPosition
Ref duplication: 
RefitBounds
Release 
Replicated array -- copy in process (%d,%d) 
Requested options conflict
ResetEvent failed
Residual checks FAILED
Residual checks PASSED
Rf;%U
RgD:
Rh:l
Rh]7P
Ri;\tc
Ri;q
RiF7B4
Rif=s
Right
Rjb<
Rk/<r
Rl:Z
RlQ;
RluC0
Rl{D
RmI:
Rn9k
Rn;i$
Rnn;R
Row-replicated array -- copy in process row: %d 
Rowwise
Rp$j
Rp;M
Rpf<j
Rqf;
Rr;L
Rr;X
Rs:u
Rt=z
RtE9
RtlGetVersion
Ru;3
Ruw;
Rw0:
Rw96
Rx4<p
Rx;8
Ry;R
Rz=9
RzC:
Rzh;~
R{G=8
S$9p
S$;Qm
S%R;1mi
S(f9,
S)9ed
S)<:GO;4W
S,f<Ma
S0:VU
S0<CwS=
S0<ok
S10:
S17;
S19=-o
S1<H6Y
S2<!fE
S2<DE
S4<x
S5;L
S5=5
S5E;
S6:b
S6;R
S6P;v
S73<
S7;b
S7<v
S8-p
S838-
S89|k
S8;k
S8<W
S8WK
S8l:N
S9#hp
S9)w
S918
S9:c
S9@l
S9B9
S9US}9Do
S9b,T:G
S9bmD:M
S9c^
S9iY0;0
S9qP
S9tT
S9|u
S:-`\r;uzp:D
S:17
S:7y
S:9q
S:RR
S:VX(
S:YP
S:a5B:
S:hn
S:jg.;O
S:k1
S:orA:'
S:t+0
S:tEz
S; uo
S;$EX
S;(yS
S;1b
S;7x
S;AT5
S;Gz
S;ThM:
S;XU
S;Yn
S;Z5y
S;]vb
S;dBP
S;ev+
S;fD
S;hL
S;hY
S;ih
S;lq
S;ne
S;p5
S;uju
S;x[Y
S;yX
S<'vo
S<0M
S<@iN
S<DQ
S<F1$
S<Lw
S<M+W
S<Nr
S<R_y
S<XC
S<YA
S<Yq
S<\tc2
S<a\nn
S<k5
S<lL
S<pe
S<rx
S<w0
S=2Z
S=88,
S=Md
S=Qc
S=j^v
S=jz
S=te
S=zC
S>E8
S>P[y
S>eK9
SA2:
SA:V
SAH: 
SAXPY(%d,%p,%p,%d,%p,%d)
SB,=z
SB7*
SB=Ru
SB>gv
SBDSQR
SBx;L
SC?l
SCx:
SD<\fs6
SE%:d
SEg< 
SF1=
SFk8
SG;t'
SG=j
SGBBRD
SGBBRDM
SGEBRD
SGELQF
SGEMM
SGEMMT
SGEMQR
SGEMV
SGEMV 
SGEMV(%c,%d,%d,%p,%p,%d,%p,%d,%p,%p,%d)
SGEQR 
SGEQRF
SGESVD
SGESVD(%c,%c,%d,%d,%p,%d,%p,%p,%d,%p,%d,%p,%d,%d)
SGETSQR
SH;Wh
SH<=5
SHA512
SHARED TESSELLATION CACHE
SHSTK
SHX;$
SHX?
SI)<m
SI9?
SI:d
SJ<U
SL:o\vu:
SLAQRF
SLARFT
SLASCL
SLASQ1
SLASQ2
SLASR 
SLASRT
SLD<;d.
SMD<
SN:H/
SNB;
SNB;2
SO9h
SO;M
SO>z
SOFA
SOFA file %s contains non-zero values for Data.Delay; this is not currently supported.
SOFAConventions
SORGBR
SORGLQ
SORGQR
SORM2R
SORMBR
SORML2
SORMLQ
SORMQR
SPt;
SQ';w
SQ>b
SRD<
SS==6
SSE2
SSE3
SSE3 
SSE4.1
SSE4.2
SSE4_1
SSE4_2
SSSE3
SSSE3 
SSYGST
SSYMM
SSYR2K
SSYRK
STRICT
STRMM
STRSM
SU<E
SU<S
SUZ;
SV|;Th!
SX:9
SX<M
SX<eTk
SX=fmZ
SY;r
SZ;3
SZN;}
S\f;r5
S_FORWARD_TRIG_TRANSFORM/S_BACKWARD_TRIG_TRANSFORM routine.
S`Q;Udc
Sa<a
Sa<s;
SaT:k
SaT=
Sa[9l
Safe minimum
Sandy Bridge
Saq:
Sb:h)
Sb<DPL
Sc-<y
Sc;f
Sc<3
Sc\9Y
Scaling is turned ON
ScatterKeysAndValues
Scene is empty.
Sck9
Se:~M
SeV;
Search interval [%.15e;%.15e]
Search interval [%.7e;%.7e]
SetEvent failed
SetFileInformationByHandle
SetThreadAffinityMask failed
SetThreadGroupAffinity failed
SetThreadIdealProcessor
SetThreadIdealProcessor failed
SetThreadIdealProcessorEx
SetThreadIdealProcessorEx failed
SetThreadpoolTimer
SetThreadpoolWait
SfT<H
Sga<G
Sgp;=
ShI=s
SimpleFreeFieldHRIR
Simulating reflections for %d sources, which is more than the max (%d). Some sources will be ignored.
Single-level factorization algorithm is turned ON
Siw=T
Size   LDA    Align.  Average  Maximal
Size   LDA    Align. Time(s)    GFlops   Residual     Residual(norm)
Size   LDA    Align. Time(s)    GFlops   Residual     Residual(norm) Check
Sj:b
Sj<#1
Sj=X;
Sju:
Sk0;1Z
Sk9~
Sk;|2M
Sls<69-
SmN:
SmO;Y
Sn8:
SoK<
Solution step (100 (%%)):
Solution step:
Some of the parameters were probably altered by mistake outside of the routine.
Some of these parameters were probably altered after DFGMRES init routine.
Some parameters were probably altered by mistake outside of the DFGMRES routine,
Some values from IPAR(11) to IPAR(21) were probably altered by mistake outside of the routine.
Some values from ipar[10] to ipar[20] were probably altered by mistake outside of the routine.
Sorry, no statistics for %s in case of a diagonal matrix
Sos<U
SourcePosition
SplitBvh\n
Sq8JV
Squ<
Sr::G
SrY<%
St;c|B<
StJ:z7
Statistics:
Stopping parameters DPAR(1) and DPAR(2) should not be
Stw=
Su;U
Su;wk
Su<,K
SubGridQBVH4
SubGridQBVH8
SubdivPatch1BuilderSAH
SubdivPatch1MBlurBuilderSAH
Success
Summary PARDISO: (
Summary: ( cleaning phase )
Summary: ( factorization phase )
Summary: ( reordering phase )
Summary: ( solution phase )
Summary: ( starting phase is factorization, ending phase is solution )
Summary: ( starting phase is reordering, ending phase is factorization )
Summary: ( starting phase is reordering, ending phase is solution )
Svw:
Sw<d
Sx?m
SyQ=:
Sys;
System error in PARDISO
Szt=
S~n90
T ;Lz
T!<nw
T"9xh
T%9z
T&;VB
T*O9
T,7#1T:g
T,{<|b6;Zk%
T-9F<
T.;WLY
T.<dl
T/;ivJ
T0<I
T0c:F
T0z9~
T1;0
T1X;2\v
T1\;kO
T25=
T2;9
T2</g
T2J;
T3:.a19@
T3A=z
T49(
T4;r~c<v2
T4>m[
T6:N
T7$B
T7'D
T7G;
T8#H
T8*NR:5
T81C
T89:
T8:G!
T8e;!RT
T9)y
T9:N
T9Dm
T9E)y; 9o;
T9ZB
T9}k
T: 0o
T:4mc
T:J4
T:WI
T:ZXW;10
T:eu
T:i<y
T:nj
T:r~s8
T:v2
T:~Gw
T;%uD
T;5R
T;7w
T;8Xn
T;Cx
T;OM\n
T;YS
T;cI
T;eY
T;f%g;An ;6^
T;fO
T;hD
T;nd
T;s4
T;zN
T;~nc
T<1 p
T<4c
T<51s
T<Hov
T<Rt
T<Ye
T<\tzR
T<`Ts
T<gLk:F\fX<
T<kj
T<s~o
T<u8\v
T<x6|
T==gM
T=Pms
T=X0:
T=zA
T>Lu(
T>tZ
T?:Pq
TANCreateContext
TANCreateConvolution
TAQ;
TAz<)o
TB*=h
TBg<
TBgvlC~0GB
TC:i5)
TCg:G
TD9FO
TD<7#
TF+9
TF;Lq
TFRY
TFa:J
TG;Q
TH0<
TH;2"
TH<d
THo<
TIf:'X
TIg;4
TJ;2
TJ<b
TK2;
TK;xf
TK<L
TKS;X;
TLE;
TMd;g>#
TN:r
TN<h7
TNp;i
TN|?g
TQ\v;K
TREE
TRH;
TS;0C
TS;Y(
TU):6
TU9A
TUV;
TV:w
TV;l>n9
TW1<
TX:4-
TY0:j
TY5<
TY=o
TZ;E
TZn<y
T[9d%D
T\fC9
T\nM90A
T\vl;H
T];Hb
T^9;qA
TaR=+
Task does not fit RAM, OOC LU factorization algorithm is turned ON
Task does not fit RAM, OOC NLL factorization algorithm is turned ON
Task fits RAM, OOC NLL factorization algorithm is turned ON
Tb87
Tb8a
Tco;
Tdp:
Te:H,
Te;hQG
Tf %f %f %f\n\n
Tf6;
Tf;3[
Tf;o
Tf<r
Tg9@
Th:vv
Th>Q_
The CPU is not supported in this Intel oneMKL version.
The absolute and relative stopping parameters DPAR(1)=%e and
The absolute stopping parameter (zero norm tolerance) DPAR(8)=%e
The absolute stopping parameter DPAR(2) is out of
The absolute stopping parameter DPAR(2)=%e is out of admissible interval [0,infinity).
The computations may fail to proceed and/or The result may be incorrect.
The computations may fail to proceed and/or the result may be incorrect.
The data in parameter DPAR were probably altered by mistake before
The data in parameter SPAR were probably altered by mistake before
The data in parameter dpar were probably altered by mistake before
The data in parameter spar were probably altered by mistake before
The dimension of the trigonometric transform %s should be
The file %s was not opened
The file was not closed
The input vector value |F(1)|=%s is bigger than the tolerance
The input vector value |F(IPAR(1)+1)|=%s is bigger than the tolerance
The input vector value |f[0]|=%s is bigger than the tolerance
The input vector value |f[ipar[0]]|=%s is bigger than the tolerance
The local (internal) PARDISO version is                          : %d
The local (internal) PARDISO version is                          : %lli
The matrix is probably (almost) non-positive definite
The maximum number of elements for scan exceeded\n
The mesh size in the direction theta, ?PAR(2)=%e, must be positive.
The mesh size in the direction theta, ?par[1]=%e, must be positive.
The mesh size in the direction y, ?PAR(2)=%e, must be positive.
The mesh size in the direction y, ?par[1]=%e, must be positive.
The method may fail to converge.
The method may fail to proceed.
The number of OMP threads defined by parameter IPAR(10)=%s should be
The number of OMP threads defined by parameter ipar[9]=%s should be
The parameter IPAR(15) was probably altered by mistake outside of DFGMRES routine.
The parameters were probably altered by mistake outside of the routine.
The previous call to a Intel oneMKL Trigonometric Transform routine produced an error
The previous call to a Poisson solver routine has failed or has not been made.
The previous call to a Trigonometric Transform routine produced an error
The problem is degenerate due to rounding errors. The approximate solution
The processor must support the Intel(R) Advanced Vector Extensions (Intel(R) AVX) instructions.
The processor must support the Intel(R) Streaming SIMD 2 Extensions (Intel(R) SSE2) instructions.
The processor must support the Intel(R) Streaming SIMD 3 Extensions (Intel(R) SSE3) instructions.
The processor must support the Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) instructions.
The processor must support the Intel(R) Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) instructions.
The relative stopping parameter DPAR(1) is out of
The relative stopping parameter DPAR(1)=%e is out of admissible interval [0,1].
The result may be inaccurate.
The result may be incorrect.
The solution may be wrong.
The solvers_ee interval generator has failed to find the requested number of eigenvalues. Try\n increasing the number of requested eigenvalues, as this can increase likelihood of success.
The tolerance parameter DPAR(1)=%e is not in the admissible range [0,infinity).
The tolerance parameter SPAR(1)=%e is not in the admissible range [0,infinity).
The tolerance parameter dpar[0]=%e is not in the admissible range [0,infinity).
The tolerance parameter spar[0]=%e is not in the admissible range [0,infinity).
The type of the trigonometric transform %s is not in the admissible range {0,...,5}.
The value of input tolerance parameter is negative.
This binary version of the SMP LINPACK benchmark is optimized for and runs on only genuine Intel processors
This device does not support HLBVH construction\n
This is a netCDF dimension but not a netCDF variable.
This message reserved for future use and should not be displayed
Thx=6
Ti;o
Time spent in additional calculations                            :
Time spent in additional calculations                            : %f s
Time spent in additional calculations                            : %f s total - sum: %f s
Time spent in allocation of internal data structures (malloc)    :
Time spent in allocation of internal data structures (malloc)    : %f s
Time spent in allocation of internal data structures (malloc)    : %f s total - sum: %f s
Time spent in calculations of symmetric matrix portrait (fulladj):
Time spent in calculations of symmetric matrix portrait (fulladj): %f s
Time spent in calculations of symmetric matrix portrait (fulladj): %f s total - sum: %f s
Time spent in copying matrix to internal data structure (A to LU):
Time spent in copying matrix to internal data structure (A to LU): %f s
Time spent in copying matrix to internal data structure (A to LU): %f s total - sum: %f s
Time spent in data preparations for factorization (parlist)      :
Time spent in data preparations for factorization (parlist)      : %f s
Time spent in data preparations for factorization (parlist)      : %f s total - sum: %f s
Time spent in direct solver at solve step (solve)                :
Time spent in direct solver at solve step (solve)                : %f s
Time spent in direct solver at solve step (solve)                : %f s total - sum: %f s
Time spent in factorization step (numfct)                        :
Time spent in factorization step (numfct)                        : %f s
Time spent in factorization step (numfct)                        : %f s total - sum: %f s
Time spent in iterative solver at solve step (cgs)               :
Time spent in iterative solver at solve step (cgs)               : %f s
Time spent in iterative solver at solve step (cgs)               : %f s total - sum: %f s
Time spent in matching/scaling                                   :
Time spent in matching/scaling                                   : %f s
Time spent in matching/scaling                                   : %f s total - sum: %f s
Time spent in reordering of the initial matrix (reorder)         :
Time spent in reordering of the initial matrix (reorder)         : %f s
Time spent in reordering of the initial matrix (reorder)         : %f s total - sum: %f s
Time spent in symbolic factorization (symbfct)                   :
Time spent in symbolic factorization (symbfct)                   : %f s
Time spent in symbolic factorization (symbfct)                   : %f s total - sum: %f s
Times:
Tit;
Tj(<1Q@
TjD=d
TjO;]eD;W
Tl4;
Tl<W*G
Tls;
Tm:E
TmR=
Tn1;
Tn`z
To9(
To:'C
Tolerance
Total size of data transferred:
Total time (100 (%%)):
Total time spent                                                 :
Total time spent                                                 : %f s
Total time spent                                                 : %f s total - sum: %f s
Tq"<k
Tq;W
TrP>
TrQ:
Transpose
Traversable is NULL. The scene has to be committed first.
Tree height: 
TrueAudioNext.dll
Trying to free NULL matrix.
Ts3;
TsE;
Tt0<
Tu;S{A
Tv;b
Tw2<
Tw:e
Two-level factorization algorithm is turned ON
Txr9
Ty:A
Ty:m
Ty<J
T}1<r
T}z;9
U";<1dP
U$6=P
U%;kI
U+9u+
U+h9!
U,9Sn:
U.2<TNM
U.;nr
U/C;I
U0;2V
U2<2
U3?O
U3T<Z
U4i=
U5; i
U5;3
U5=V
U5p:
U6:U
U6:g
U6:o
U6;k
U6<F4
U7>\nt
U8.6
U816,
U85W
U8:`F
U8>4
U8LOR9Y
U9:a
U9;W
U9R;
U9a;
U9b\t
U9i"y
U9iN'
U9oN
U:$I=9ZLo:
U:(9P
U:,VO9
U:3Of;:
U:93w:
U:BY
U:IT
U:Vu
U:oF,;i
U:qo
U:qs
U:t1
U:wl
U;1r
U;2S
U;6I
U;703
U;8P3
U;Bu=;7o
U;Cd
U;ES-9b
U;Ex:
U;I\rx
U;Ps
U;Qu
U;aO
U;gH
U;j)7
U;mRj;
U;pp
U;sQ
U;tK
U;yWS
U;yz&
U;z&d
U<&e0
U<0]G
U<1p=
U<Dbr
U<FJ
U<Os
U<R~J
U<Uh
U<Xr
U<Y6
U<YN
U<Yw
U<\fEy
U<dS,
U<kkz
U<tM
U<wM
U=FeS
U=Qp
U=dQ
U=qTP
U>B8
U>C7X
U>IK
U>ZL
U>^Cr
U>nK
U>s82?
U?q:dq
UAH:dxe
UB8#
UB;5
UBG 
UBdn~C
UC#<p
UC;OH
UC;V
UC<K8
UD\f9
UDm;h
UDx;
UE;Y
UF,:fAG
UF<!I
UG<e%
UH;W;
UINTR
UK96'':
UK;I
UK<Y#
UKL;
UKT:
UKz;9
UMb;
UNS<
UO);P
UO8j\t
UO94
UOg<
UP>q
UP>y
UQ9:(
UQ;L
UQ<b
UQp8
URn<t>
US'=n
USER_MSR
USM allocation cannot be combined with OS allocation.
UT0=
UT>x
UTV<
UTu;HX\n;L
UTz<
UW<j
UW<m
UX:LL
UXJ<
UY:f
UZ=6G
UZ>O
UZ?5t,?G
UZ?G
U\:s&c9e
U\t<Gd
U_0=1
U_d:Fd!;q
UaK<N36
Uat<
Ub:f
UbN<
UcK9
UcQ:
UcY:(3
UdF;F
Ue1<
UeT:R
Uf9Q
UfA<>
Ufj:0!
Uft;]a
Ug)<pD
Ug/;9
Ug:;A
Ug;B"a
Uh2:
Uh9`
Uh=Z
Uie;l
Ujn;Lr
Ul;uN\8
Unable to create OpenCL kernel %s. [%d]
Unable to load SOFA data. [%d]
Unable to load SOFA file: %s. [%d]
Unable to open verbose output file.
Unit
Units
Unknown CPU
Unknown CPU (error)
Unknown error
Unknown error in %s.
Unsupported CPU
Uo;L
UoW<
Up:kK
Up;LG\t
Upper
Ur5;
Ur;v
Urp;kv6
Us1:z
Us1<
User provided fill-in reducing permutation is turned ON
Using %d CUs for convolution, %d CUs for IR update.
Using OpenCL device: %s %s (%s).
Using OpenCL platform: %s %s (%s).
UuL;Cb
Uux:
Uw:r
Uxe:
Uy;.E
Uz9>
U{4;p
U{5<t
U~<bx
V 9C5
V ;pZ
V Z>O
V py
V#9L
V';mE
V'Z<_2P
V(=JQ
V+;ik
V,g:K
V-s=Qj_
V.9\v9
V.;Yw
V/9B
V0<a
V0};ur
V1A;o
V2:Q
V2<q
V2=s
V2h;\n
V3y:
V4;t
V4>gH
V4M:
V4~9
V5<u
V5>pj
V6'?C
V6;2
V6G<~
V6U=
V6s<
V6t<
V7Pi~
V86]
V8<J
V8dF.
V9&U
V9=R
V9DB
V9NJ]
V9T.
V9j.
V9or
V9qc
V9z{
V:2Z
V:3vb
V:4y
V:<kv:i
V:F(2
V:Lj\v:9
V:Si
V:bsr;
V:fg
V:kk
V:lb
V:nfP:{&z
V:w1f=
V;):E;VLg;S'
V;,n2
V;-IM:Z
V;0Lq;!
V;4P
V;7'u
V;7BP
V;7M
V;9wS
V;;ij
V;Aq
V;Bq^
V;Bx\r;w
V;C6;
V;E0R
V;G\vN
V;Hs
V;Kk
V;LwR<0
V;NV
V;PU
V;Q8
V;UB
V;VE
V;WU3;N(
V;b1
V;fG
V;fm
V;hV
V;mD*
V;ou
V;pg
V;ry
V;sT\n
V;wR
V;wu
V;zC
V<7H7
V<<f06;
V<A4;
V<GZs=
V<P3\r
V<PVj
V<UA
V<UkG
V<^06
V<l;Bk
V<scP
V=1Z
V=2KN=
V=2z
V=95
V=Ba
V=Fb
V=Ie
V=Qh
V=Y7p
V=lH
V=oT
V=t<7
V>9o
V>:OS
V>TS
V>bzq
V>fU
V>o6A>
V?&pW?SHX?j
VA';e
VA70d
VA7<5#
VA9h
VA;Z
VAES
VAl<X
VBE<
VC8I
VCr<
VD >0
VD:E
VD\6
VDo;b
VE]9
VEa9Sk
VFB;
VG1:
VH<L
VH=v
VI:t9
VJ8B'
VJ;4
VJ;Zq
VJ;i
VJf>
VK;5
VKV:E
VL;B?3;
VM:Y'
VM;0
VMW9@
VOD;Q
VOs;
VP<A
VPCLMULQDQ
VPDy
VPqy
VQ%z
VQ8vg
VQ;f
VQ[;Ba
VS9L
VS9_
VS:0\r
VS:f
VS<kS)>
VSg;y
VT98"
VT;S
VUUUU
VY:tj
VZ9dN
VZ;E@
VZn=
VZv:
V[A9
V\%9p
V\8S`
V\:SUn
V\;6W
V\S;5
V\n;gt
V\rO8M\n
V\t;PW
V\t;aFe
V]8iM
V^E<t
V^U:R
V_9\nf
Va:P
Va<b
Vam;9lE
Vc:y
VcA=
Vd0=
VdZ:
Vdo:R
Ve<$7
VeO<Qm
VeU:Z
Veh<#
Vf;1
Vf;vJ
VfE;
Vg9v
Vg}9OE
Vh:p
Vh;,e
Vh>6Q&?f
Vi:t
Vi;J
Visual C++ Compiler 
Vj2:
Vj7k
Vj;8
VjR=
Vk9;
Vk;Td
Vk=1X
VkX:
Vke:
Vn,9
Vn9YZ
Vn<IW
Vn=WD
Vn>\fb
Von<
Vpd=
Vql:=
Vqp;
Vr<Nf
Vr<V
Vs<B
Vs^<WV-
Vt8;
Vt:L
Vt:U
Vt;5
Vul<
Vv1<
Vv;JQf
Vv;LL4
VvB?p
Vw;M
Vwi<
Vxe<
Vy;#b
V{N;jyr
V|3<K\f9
V|;6fb
V}C9
W 9w
W"n9
W&b<O3
W(s<0
W*9df
W*;or
W+A>zgD
W,;Sm
W,<fr
W,n=X
W.<mo
W.s;j
W/S9
W0;7
W0;e7
W0^9
W12<
W1=YL
W1M=
W1k7
W2;.R
W2;\Q
W2r<=
W35;|p
W4(9
W496}`
W4;6
W4;e
W59\n
W5x;
W6;s6];
W6>B
W8;F?
W8<UW><
W8<i
W8Cn
W8P(
W8q<
W9:4D
W9<CF
W9>58l
W9c<
W9fS]
W9hT
W9w\v
W9}0Y
W:#7Z
W:'Bl;A
W:1VR
W:7eO95[
W:<h2
W:Jp'
W:Jr
W:Kt@
W:Kw
W:L~V9
W:OE7
W:QI
W:`3d
W:d1
W:fD
W:j)b;N
W:m V
W:uls:
W:wK
W:xs`9
W:{lW
W;(Zx
W;0N
W;JJD;?
W;K9
W;NU
W;Nh
W;Pa1
W;Z?0
W;\fVA;av
W;faj
W;fe
W;iv
W;j\vl;A
W;lQ
W;lm\
W;nB
W;nN
W;ne
W;pe
W;tS
W;tV
W;us
W;zu
W<:cq
W<Bm
W<UG
W<nV
W<qJ
W<uV%
W<u|9
W=*zd=z
W=L Z
W=P,P
W=gt
W=tv
W>CHl
W>eD
W?=Kp
W?L;Y
WAITPKG
WARNING: AdjustTokenPrivileges failed to enable SeLockMemoryPrivilege: Add SeLockMemoryPrivilege for current user and run process in elevated mode (Run as administrator).
WARNING: AdjustTokenPrivileges failed while trying to enable SeLockMemoryPrivilege
WARNING: LookupPrivilegeValue failed while trying to enable SeLockMemoryPrivilege: 
WARNING: OpenProcessToken failed while trying to enable SeLockMemoryPrivilege: 
WB8;
WB:j
WB;5
WB;J
WBNOINVD
WC:Br
WCQ;
WD2:o
WD;N 
WD;q
WD<Ig
WF<D
WF<j
WG$85d 
WG<p
WG=`z
WH2<[Q0
WH;h
WH=i
WIDE-KL
WJ:<Yh
WJ;b
WJ=Q$a
WK<4
WL9"]
WM=+5
WN9<\
WN=4
WN=e
WP9e
WPB:YQ,
WPW=
WQ ;6
WR2;D
WR;RmA
WRMSRNS
WSV=
WSz9
WTC;
WU;t9d:
WUH;6
WU\;3
WV>H
WW7<
WW:S
WWl9#*|
WX2=
WYU:
WZ:9
WZ:|m
W\f;Qt
W\ro9
W^;7n
W_2;1
Wa:wvf:
Wa=0
Wa\v;m
WaitForSingleObjects failed
WaitForThreadpoolTimerCallbacks
Warning message has been written in %s
Warning: 
Warning: Consider use of MKL_RODFT00 instead of FFTW_RODFT00 in planning r2r transforms with FFTW3 interface to Intel oneMKL (see Intel oneMKL Reference Manual).
Warning: incorrect parameter %s (%i),
Was:
Wb9d
Wc;!42
WcB;
WcS;j
We appreciate your assistance and apologize for any inconvenience
We appreciate your assistance and apologize for any inconvenience resulting from
We7=
We89
Wg:{X
Wg;b
WgB;
Wg~;R
Wh9<.WC
Wi1<
Wi;m
Windows (64bit)
Wj:n
Wj;Z;x9
WjG>4
Wk$;V
Wk8+&
Wk<M
Wl#9!L
Wl*<0`w
Wl8j
Wl9<
Wl;eEH
Wl<r\n
Wlh;
Wn<n
Wnv9
Wnz9
Wo<0
WoB;Z
Woy:\v
Wp>;vi=
WpG;
Wpp;
WqCf
WqE;f
Wr9.f
WrM<dr
Write type=%d
Write type=%lli
Wrong number of vertices per face
Wrong parameter %d in %s\n
Wrote %d items
Wrote %lli items
Ws,<WrQ
Wt5=
Wu;g
WuR;
Wv:u5B;
WvQ;:Mj
Ww:w\f
WwN<&yx
Ww~9U
Wx;GoI
Wzy9r
W}U:8h
X"<Ikd
X"c9
X#:J2
X$G91
X*?Ph
X+z8
X,;dJ
X,;s 5;xA
X2;3
X2;8
X2;U!
X3=I
X4:[447)9
X4=5
X5E<:
X69}%r
X6;H3
X7f:
X7y;
X8"C5
X8=A
X8D=
X8b;(
X99;
X9<G
X9=NO
X9M! 
X9Q#
X9iAy:g}
X:5E
X:AuI<WBV
X:Cz'
X:HI
X:Ia
X:YM
X:l3
X:oX/
X:qvJ
X;!HE
X;.aS
X;3WL
X;3m
X;7v
X;>uI
X;@yq
X;A>s
X;FS\n
X;FW
X;JL=
X;PM
X;PXx
X;Pd
X;XL
X;ZG
X;fa
X;oU
X;ow\t
X;t/2
X;w1
X;xL
X;yb!<v
X;z9
X;}TD
X< cr
X<9=3
X<9e
X<Hp
X<Jr6
X<K6;
X<U1
X<\f6w
X<]EO
X<iLV
X<ok
X=Gx6
X=Rq\r
X=[g8>t
X=^XA
X=db
X=o(%?tUO<R
X=pp
X=uE
X>7iad8
X>UL
X>ri
X?I9
XA7=
XB=U
XC;l$
XD9^
XE<d
XEA>K
XEJ;
XE\<t
XEd;b
XF:g.A
XF<V
XFm;
XG:D
XG;u
XH:n
XIm< A
XJ9:
XJ9NQ
XJ:'g
XJ<c
XJ>8
XK);S
XK9\r
XKD<
XKo:
XM:D
XMM 
XMQ;7
XN9<
XN;m
XOK;gL
XP9\
XP<z
XPC9]
XQ:q
XQ:v
XR;1
XR?9Dz
XRA<
XS0<
XSB>
XSGBBRDM
XT;d
XUm<
XV27U?
XV6;
XV;cf
XVK:
XY9f
XZV;
X\nO<d
X\v>cH
X]:Zi
X^W;8
X_<1x
X`O=Z
Xa:ZP
XbS;~Y
XcC?
Xe39
XeA;
XeL;'2)
Xeon Broadwell
Xeon Haswell
Xeon Ice Lake
Xeon Ivy Bridge
Xeon Phi Knights Landing
Xeon Phi Knights Mill
Xeon Sky Lake
Xf5;
XfB:
Xf`iy
Xg@;v
XgR<
Xgl=J
Xhl:(D
Xhz<
Xi8<
Xi:u
XiP;
Xj:Gnw:
Xkp:
Xl8l
Xl:n")9
Xl;Q
Xl;T
Xlt<
Xm.=o9R>
Xn,<t
Xn9<
Xn;N
Xnr<`
Xo0<
Xob:
Xof;^
Xp:IH*
Xp;8<
Xr:f
Xr;m
XrR<
Xs.<(1V
Xs;X
Xs=B:
Xs=n
Xt3<
Xt;Z
Xto<$
Xu\n;e
Xv3<
Xwj:
Xx;F
Xx;Ym
XxJ;
Xz:6
XzN:
X{9f
X{<bS
X|:LD
X~L<a
Y F;R
Y a:j
Y"-9K
Y$:7l
Y$p<p
Y%:nFh
Y&<b2B
Y&w;u
Y'<KH
Y)0:f
Y*90
Y-w;W\rA
Y/o<Ww
Y01:
Y08f
Y0=Oo
Y0v;C
Y0w:
Y1:to
Y2=0
Y2K=
Y3=S
Y3=j
Y3|;N
Y4:}k
Y4J;
Y5K:\r
Y6<`2
Y7E7
Y7P:
Y8%;R
Y8(iA
Y83h
Y86h
Y8:VZ
Y8;k)
Y8\f
Y8l<
Y90O
Y91_
Y9;5
Y9;H&E
Y9<\n2
Y9Bt\t
Y9D;
Y9NC
Y9Qi
Y9\rHN9
Y9tp
Y9v<
Y:,Wy
Y:Ee
Y:QU
Y:T3
Y:ZhJ;*X
Y:dKb<
Y:vg~9D
Y:xk
Y;4R
Y;5s
Y;<bC
Y;D=G
Y;GE
Y;Jt
Y;P4F
Y;PH
Y;VP
Y;gk2>xQ
Y;kj
Y;p9f;
Y;uh0
Y;xbV;
Y<#Qk
Y<%sV
Y<0s6
Y<2A
Y<Qf 
Y<VI
Y<Xx
Y<ZT)
Y<\v8X<Vh(
Y<dS;
Y<fy
Y<jT
Y<mj;
Y<qn\v
Y<sF%
Y<uo"
Y<x3C
Y=4(6
Y=6C
Y=<VR
Y=>qv
Y=FU
Y=Rz
Y=Tad
Y=Uf
Y=d9
Y=ht1=M\f.
Y=u:2
Y>AG+
Y>eu>>S
Y?K:y
Y@9'H
YA;F\n
YB:O
YC5;\
YC:2G
YE9-
YF0<
YF9g
YF;U:
YFf<
YG:#u
YG:w
YH:o]
YH<M
YHS;rM
YI5<
YI>9
YII:
YIa<I
YIm<
YJ1:u'/
YJ;R
YK:yR
YL!<h5
YL;Sw.
YLP<
YM;L
YMM 
YNS8
YNb=#uA=
YO8;
YO9(
YO9m
YP;2
YP;E7
YPs;
YQ9\no
YQF=;
YR<U
YSB<
YSJ:
YT;7]A
YTK<
YU9w\f
YU;5Z
YU;Z
YU<u
YUF;
YV;H]
YV;y]j;LkZ
YV<A
YVn=
YW;0
YW>7U
YWw;j'w
YX:YC
Y\r1<G
Y\r6<j
Y\t;gd
Y_9n;
Ybo;`Ox
Yc;,6f:
Yd>az
YdB:
Yec<
Ye~:5
Yf;O!
Yf<j
Yf>EZ
YgK:
Ygy;
Yhs:
Yi;I
Yid;
Yj<c
Yle8
Ym\v9
Yn\v<fD
Yo2:?
Yom=
Yq=x
Yr@;7
Ys5;
Ys;Zw
Ys<l
Yt;Q
Yt=CF
Yu9l]A:5
Yu<z
YuU<
YvI=\f
Yvz:f
Yw;n
YwA;
Yx7<
Yy;X
Yyq;
Yz2;
Yz2<
YzA<
Y{59
Y|:TT
Y|H<1
Z#;Go8
Z(8;H
Z)8E/W9
Z.98
Z/8xP
Z/DX
Z0;<r
Z0U>
Z1<yF
Z24<
Z29=
Z2b:
Z2b:y Y9
Z2p:
Z37<
Z3:.5
Z3;Mv
Z3m=o
Z44<\t
Z4=l
Z4B;
Z5;G
Z5;S
Z5=d'
Z6=r^9
Z6u:
Z7=E
Z7s:9
Z84:
Z8;m
Z8GL$
Z8aJ
Z9 d
Z91;
Z95~j:
Z96m
Z9T]
Z9x@~
Z:0M
Z:39
Z::Mt:t
Z:>M5
Z:Glj8
Z:K2*
Z:N2*
Z:Oe
Z:T4c:J
Z:U9
Z:_Lo
Z:d?p9
Z:kZ
Z:l-C
Z;!2p
Z;#AI
Z;+l6
Z;/aC;M
Z;46
Z;58
Z;7QK
Z;Cr$
Z;KP
Z;Li\f
Z;M i
Z;MUh:
Z;Mp
Z;Ys
Z;]Ei
Z;e3
Z;fO,
Z;gv#
Z;jz
Z;lw
Z;mI
Z;oC
Z;y3
Z<#3x
Z<7N
Z<Km
Z<Ox
Z<UIX
Z<cD
Z<g,D
Z<g`Q
Z<riw<
Z<u9g
Z<y<t
Z=qT
Z=qh\n>5
Z=w<E
Z>Py
Z>Zt
Z?<Gsg
Z?ua
ZA!9 
ZA9;
ZC:a
ZC<1
ZDXI
ZE:Ik1
ZEH;
ZF:A
ZGC;$
ZGj\tt
ZHEGST
ZHb<
ZI{;Ct
ZJ6;9
ZJ6;q
ZJ;E
ZL;2
ZL=6
ZLH:
ZM:9
ZM:iR
ZMM 
ZN:K]
ZN<3\v
ZNj;.
ZR<)dl
ZR<D\v
ZRU=3e
ZS0;
ZSB7`
ZT83
ZT;k
ZT<I
ZTz=N
ZU=r
ZUd<
ZV98
ZV:P
ZV]9
ZW49
ZW:P
ZW<{c
ZWg<
ZX<x
ZXXPHP\
ZXk:
ZY;V
ZYU;
ZZS:
ZZU;
Z\nZ\fT
Za<2
Zak;
Zam=e
Zb(<N\vG
Zb;p
Zb;w
Zb<8
Zci:eF
Zd>NV
ZdN=Y
Ze+:g
Ze4=m
Ze;0
Zero pivot detected
Zf<T
Zfb=
Zg:\tr
Zg;G
Zg<D
ZhF<
ZhJ6
Zj2<S
Zj9dtK
ZjJ<
Zk:,W
Zk;k
Zk<O
ZkN95
Zl29
Zl6<
Zm>+t
Zp91
Zp=x
Zq0;
Zq=g^
Zrd;"
Zrk;D\
Zs>U
Zt=J
Zu3;
Zu;-R
Zu<cp
ZuQ>
Zw:3>f
Zw<7
ZwL;G
Zx[:r
Zy;R
Zyw;
Zzu9
Zzx;
Z{L:J
Z}90
Z}F7Q;l
Z~@Mn
Z~@f#aCW
[2;xn
[3X:D
[6<2wN
[7=Xc
[7JT
[94D
[9UrM
[9zU
[:B1Z8
[:dfN
[;5Z5
[;eIi
[?Z8q
[C9N}
[Co=y
[DK;n5
[END]
[F9X,
[G8r
[It<r
[MKL] [MIC %02d] [AO %s %s Time] %f seconds
[MKL] [MIC %02d] [AO %s %s->%s Data] %llu bytes
[MKL] [MIC --]   [AO %s Workdivision] %s
[MKL] [MIC --]   [AO Function] %s
[QC<CL
[QF<wt9
[T;jN
[UE:P
[V=d4
[WN8
[XG:c
[XZ;K
[Z:1K
[a;W9
[a<bi
[c5<1
[dT:d
[dk;0
[e;rs
[qe;w
[r9=gD2
[r:s6
[u;5tg;
[xs;6y
[z<ky
[zi<g)C
\-4<X8A
\2<K0
\7"8d
\8;pa
\8Jc
\8Mb
\8\f9j
\8eP
\9K2c:
\9S2
\9aO
\9fk
\9mOJ
\:mGt
\;97J
\;PFV
\<Esw
\=1Z0
\=z:bIm
\B;#\nn;;{H:.
\B;3u
\B;WO5;
\D-92
\D9a
\E<tdp;
\EZ;Y
\Gy;F
\I7<S
\I=xvW=
\IF<D
\Ka8
\LJ<v
\O:pK
\OQ:p
\P.<dcm
\Q7K(
\Rm<z
\U7y;O
\V9N
\VM<s
\W9u#3:
\X>gO
\Z:Rk
\a9f!
\b;CU
\c1;f
\f(k:0dR
\f5\f0W
\f5o:0
\f6M9
\f71;j
\f7Ea
\f8>1x:N
\f8z]K
\f9;Bq
\f9GGd9
\f9zx
\f;8PN
\f;L+S;&MN;4\
\f;muJ
\f;zbM
\f<OY8
\f<ow0
\f=P82
\f>"Q->eLm=q
\f>0dj
\f>JfJ>MM
\fAj;i
\fB0W
\fB58
\fF<Muq
\fGU;1
\fI;tJ
\fL<FG
\fM7<Io
\fML<u
\fN>hp
\fP;jV
\fT9T
\fUq9p
\fWG<o
\fWo:Js
\fZD>L
\fZK;r
\fZy=kJA
\f\tf9U
\fd:Yz
\fg:yQ
\fg;N6
\fgY;U
\fj:mgA
\flr9
\fq<dm
\fu:xe
\fvCsk
\g<bs
\i;ouJ
\j9D#
\l=c3
\lU9)
\m;Bo
\n       Lenght: %d   Buffer size: %d\n
\n/97vO
\n1#<OP8
\n29B
\n2d=E
\n48x
\n5\n0W
\n7;XPF
\n8=Ly
\n913
\n9GJ
\n9]MC
\n9ms
\n9ofi96
\n9zw
\n:FyA
\n:S4o
\n;Ebf
\n;MlX
\n;Tvy
\n;i6S
\n;lvT8\fgM;
\n;uo0
\n;x7X
\n<29q
\n<ZO4
\n<bYN
\n<dm1
\n=T0H
\n=e21
\n?ECy
\nBq;b
\nEK;B
\nEl:c3
\nH;bw
\nK7:v8
\nMKL INTERNAL ERROR: message buffer overflow.
\nNAN
\nNq:RuY:
\nO;HbK
\nP<ni
\nPr9
\nR;SdH
\nT9Aq
\nU8&h
\nUU<K
\nUp<J
\n]s9P
\ndN9^5
\nda:h
\ned;4
\nfA>MI\f
\nfe;h
\ng:2p5;
\ngN;1
\ngf>ZL
\nj;\rIe9
\nlG=a
\nq:bk
\nr48
\nr93@
\nre;X,K
\nvtg
\nw1=jj\t
\nyd9H
\nye<v
\nzW;soi
\r1;d2
\r38n
\r42:n2F
\r5:zp58z\ff
\r7ag
\r8>7E
\r8Tn
\r9N8y9
\r9Y\tl
\r9ob
\r:dRn
\r;Brv
\r;I,w:GoQ:W
\r<Dhs
\r<bFE
\r<jhI
\r=9Fe
\r>3;caN
\r>7a7
\rAf;d
\rAt;F
\rF 9d
\rF;ju
\rHR=w
\rI;Pw
\rI>cz
\rPA<7
\rZ2;nv
\rZM:r
\r\t92c
\rb9M
\rc79
\rcalculating laplacian: %.2f%%
\rd:nt
\rd;la
\rg95
\rh8;A
\riP<d3
\rmarking potentially diffracting voxels: %.2f%%
\ro:xPG:
\ro=KW
\rocT@
\rqa+j
\rsM7
\rt8l
\rv;Ovg>
\rzl;g
\r|9wy
\r}R9N,N
\t,9Jq
\t099\t
\t0u9
\t2:z9
\t2;z5
\t4;ExF
\t5\t0W
\t6p7M
\t6p7MOf
\t7t9]9m
\t8;2v
\t8Fb
\t8M<TTs
\t8d<xvt
\t8u5
\t8w:L
\t9Jt
\t;27G
\t;Nv5
\t;TXQ9
\t;ZH5
\t;je5
\t;qpo
\t<1s9
\t<3lj
\t<b8o9Hu
\t<r5H
\t<wTj
\t=6'/=c$\f=#
\t=iSG
\t>sAd
\t?NBu
\t?Xke
\t?xXb
\tA0f
\tAT=s
\tAl1"B
\tF*<ZIj
\tH696d
\tH:0e
\tJ:4zs:
\tKI=dXW
\tOy8
\tQX:R
\tXF:OP
\tZ;LY
\tZ<eGv<
\t\rH99
\t\te9W
\t]9Ng
\ta97zX:
\tb95
\tb9T&
\tc7=P
\tdm;O1h
\tf<KN
\tg8T
\tkZ9/
\tmL;w
\tr:b51
\ts8c
\ttd;l
\tx38
\tz9a
\v49b
\v5 er
\v589C
\v5B3
\v5\v0W
\v8eQ
\v8zi
\v9Vn
\v:XOa
\v:kaH:l|@:[
\v;509;4
\v;6o2
\v;Hfl
\v;Us3;G
\v;l1E
\v;reO
\v<aV9
\v<dLK
\v>0Iy
\v>1a7
\v>wPH
\v?PDt?a
\vDcC`
\vFb9!
\vG=v2
\vI93
\vJr8p
\vL38
\vL9u O
\vNr:oU
\vO9F\t
\vO<lCF
\vOv8C
\vS9e
\vSc<bA
\vVJ9#
\vX67
\vZ9K
\vaX;1
\vc:ut
\vde;x
\ve=Ok
\vf;2yt
\vf<7
\vg>Cm
\vh;Am
\vhI<k
\vl;1b
\vn9]c
\vpq;6
\w84
\|96X
]"A=cT9
]/29T
]0S;BF
]2;7i
]4G;Z
]68tGS
]7:qZ9
]7;LC
]7K9g
]8?Z7
]8Yp
]8tN
]9g5X
]9mR
]9z1
]:BT5
]:MyH
]:gmo
]:y9.9W
];:bZ<tq3
];q3Z
]<6Lc;R
]<Pr3<1
]<p6O
]=X23
]?TM7
]B9!k
]Cpg
]D<O7
]Ef;i
]G;Se
]Gc;oq
]Hl;f
]JG<zf
]L;QG
]P;HSr=P65=
]Q09
]T\f9l
]U0;9iS:\K
]VW<C
]Wr9L
]Yh;q
]a;7w
]a;HJ\n9
]b9Z
]b\f9s
]dK;qSH
]ew:ki6
]k;32
]lg<Y
]me;9*7
]x4:sS
]xF8
]}39.6v
^,c9Np
^4k9k
^69U
^796
^82cE
^89U
^8;u0
^8<bH
^8\v03
^9$7H
^95x
^9Ab
^9Ji
^9S7]d
^9b\rQ
^9kEM;v9
^:3Pn9|
^;OZy
^;ciM;D
^<Sk5
^@d2^2\HJ2H2<:f
^G8;XW
^G:LL
^H9v
^IB;h
^K67
^M;mM
^Mw<f
^P0:Y
^S;nN
^TW9
^W8WAD:
^Xe=kme<
^Yi;PC
^aX;W
^as:L
^dw<2
^f;8m
^m;9R
^mg:9
^nZ<vSk
^o<De
^oT<cQ
^qV;Z
^|9itt
_.59z
_0L<D
_1F9D
_4M<D\nL
_59#d
_5=r1
_76;k
_8Z0
_94U
_9Kc
_9R<t
_9Zc
_9xJ 
_;4mW
_;bSj
_;p8H:d
_;z3h
_<EXa
_<yoh
_=0VA
_=0g6
_D8;w
_E:2dB
_F%:Xy0
_F;wr\6
_F<TE
_I%9i
_I9j
_SJ;uK0
_U<qY
_XY<Dm
_Z8n
_\r;FtN;Q\v.<`P(
_^=8cWt
_c<tQ
_j9!I4
_m9O
_nF;Z
_oB<P
_pv<gX
_rf;2P
_vM;n
_wl;2
_xB;d
`$9Q5n
`0_tL
`1<Egd;"m
`20W
`2>cx
`5L9S
`5u=K
`6@by
`7;XZ
`7<RLK
`7xz
`9=QT
`9fW
`:&zz9y
`;Ygi
`;hV0
`;mv0
`;w8n
`;wsG
`;zRB:5
`<DUc
`=ziS<D
`>wKV
`AS;J
`Ds;J
`E9n
`E<kX
`GN<U
`Gd;Y
`L9s.
`O29
`P9A
`Q9I
`T95
`UV;ab
`XG;r
`Y9<r
`b0W
`d:Cva;z
`f<Ol4
`fP`y
`g5<u
`hr0W
`hrT
`hr`V
`j0W
`j:QW
`k;ZM
`kD;f
`n;b92
`n<Dr
`p;Rc
`q94
`q99
`r2:m
`rj9
`u9k
`w:JL
`zD=8
a :ud
a non-negative integer. Assigning to the parameter IPAR(10) the default value
a non-negative integer. Assigning to the parameter ipar[9] the default value
a!i=i
a$;sF
a';m2
a)J<r
a-2<H8
a-:k5
a/1<MX
a0g:
a1\t9(f
a29:
a2P;
a3-9
a32:1
a3;\nY
a3;i)
a3<C
a49A
a4<N\f
a4c;
a5<t
a6:E
a7-14
a7vL
a9)a
a99iC
a9<A
a9=2
a9=r
a9?[F
a9H&
a9Nx&
a9m:
a9y7":
a:DX
a:EM
a:EV
a:IrQ:q~
a:Ln
a:OGu
a:Sl
a:Tu
a:YT'
a:c2
a:pF
a:rC
a:t3
a;0ip
a;BX
a;RT
a;SB
a;Tm
a;YJ
a;\vc1
a;djE;AXO
a;f1
a;hzx;
a;k5
a;ri
a;tt7
a;xF
a;xwY
a<2MJ
a<6V
a<7R`
a<9i
a<NE
a<OAQ
a<SX
a<UB
a<f2
a<hO
a<kV\r
a<np
a<ye
a=33
a=9d
a=FA8
a=fiJ>
a=lHe>z
a=rn
a=|qj
a>2MR>
a>qZ
a>st
a?cH
aB4<
aB<UZ
aBW;
aC=z
aC>6:
aC>T
aD<n
aEV:
aF>S
aFv;
aG'9
aH:W
aI=:Q
aIH<U
aIP<
aJ1<
aJY;
aJt:
aK:F@
aK;G
aK;V
aKa;
aKi;E
aL=H
aL=T
aM0;
aM< K
aMq:
aN>I
aNZ=
aO1;
aP5<L1Q
aP~;l
aR:x\t
aR=b)
aS;%N
aSr<
aT4;#L
aT9q`
aU<J
aVI;
aVf:
aW<Z
aWG<
aWd;z
aX;c
aY:W
aY>7%Z
aYH<
aYw;e
aZ;v0
aZ;y
a[;R8
a\9y
a\P<3
a\fB0W
a\n<ps
a\r9l}M:
a\rB0W
a^9m:
a_=pT
a`h;ziV
aaT=
ab5;a
abB8
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 _.,+-=:/*\
ac;y\f
acc.type
accel
accel_mb
accels[
acosf
adC:
addProbe
addProbeArray
addProbeBatch
adl:e
admissible interval [0,1]. Assigning DPAR(1) to
admissible interval [0,infinity). Assigning DPAR(2) to
ae;9_
ae;M
aeG<L
aeM<
aed;
af=G)
affinity
ag=<zM
ah5;
ah6<
ah;g
ai;P
ai=2
aiM=z
ai\n;qGV
aik;
air9
airAbsorption
airAbsorption[iArray]
aj;P\vB;L
ajA:
ajv;
ak<O
ak=Mg
ak=Y
al;j
al<o
alT:
alloc_main_block_size
alloc_num_main_slots
alloc_single_thread_alloc
alloc_thread_block_size
allocate enough memory for TMP array.
allocateAudioBuffer
allocation exceeds size of tessellation cache segment
allocation is too large
altered by mistake outside of the DFGMRES routine. The solution may be wrong.
am;<9
am\nv
amx-bf16
amx-complex
amx-fp16
amx-int8
amx-tile
an integer number greater than or equal to 2.
an6;
an9~
an<N
and/or The result may be incorrect.
and/or the result may be incorrect.
anx;[I
ao;v
ao<%b
aoa=
ap;D0
apply
applyIIRFilter
apxf
apy<S@n
aq;m
aq='q
aq`;F
ar6;L
at least one topology has to exist
at8*
au:z
audioBuffer
audioSettings
audioSettings->frameSize
audioSettings->samplingRate
aul;
av:-l
av<)p
av\v=H7\
avx10.1-256
avx10.1-512
avx2
avx2::BVH4ColliderUserGeom
avx2::BVH4InstanceArrayIntersector1
avx2::BVH4InstanceArrayIntersector4Chunk
avx2::BVH4InstanceArrayIntersector8Chunk
avx2::BVH4InstanceArrayMBIntersector1
avx2::BVH4InstanceArrayMBIntersector4Chunk
avx2::BVH4InstanceArrayMBIntersector8Chunk
avx2::BVH4InstanceIntersector1
avx2::BVH4InstanceIntersector4Chunk
avx2::BVH4InstanceIntersector8Chunk
avx2::BVH4InstanceMBIntersector1
avx2::BVH4InstanceMBIntersector4Chunk
avx2::BVH4InstanceMBIntersector8Chunk
avx2::BVH4OBBVirtualCurveIntersector1
avx2::BVH4OBBVirtualCurveIntersector1MB
avx2::BVH4OBBVirtualCurveIntersector4Hybrid
avx2::BVH4OBBVirtualCurveIntersector4HybridMB
avx2::BVH4OBBVirtualCurveIntersector8Hybrid
avx2::BVH4OBBVirtualCurveIntersector8HybridMB
avx2::BVH4OBBVirtualCurveIntersectorRobust1
avx2::BVH4OBBVirtualCurveIntersectorRobust1MB
avx2::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
avx2::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
avx2::BVH4OBBVirtualCurveIntersectorRobust8Hybrid
avx2::BVH4OBBVirtualCurveIntersectorRobust8HybridMB
avx2::BVH4Quad4iIntersector1Moeller
avx2::BVH4Quad4iIntersector1Pluecker
avx2::BVH4Quad4iIntersector4HybridMoeller
avx2::BVH4Quad4iIntersector4HybridPluecker
avx2::BVH4Quad4iIntersector8HybridMoeller
avx2::BVH4Quad4iIntersector8HybridPluecker
avx2::BVH4Quad4iMBIntersector1Moeller
avx2::BVH4Quad4iMBIntersector1Pluecker
avx2::BVH4Quad4iMBIntersector4HybridMoeller
avx2::BVH4Quad4iMBIntersector4HybridPluecker
avx2::BVH4Quad4iMBIntersector8HybridMoeller
avx2::BVH4Quad4iMBIntersector8HybridPluecker
avx2::BVH4Quad4vIntersector1Moeller
avx2::BVH4Quad4vIntersector1Pluecker
avx2::BVH4Quad4vIntersector4HybridMoeller
avx2::BVH4Quad4vIntersector4HybridMoellerNoFilter
avx2::BVH4Quad4vIntersector4HybridPluecker
avx2::BVH4Quad4vIntersector8HybridMoeller
avx2::BVH4Quad4vIntersector8HybridMoellerNoFilter
avx2::BVH4Quad4vIntersector8HybridPluecker
avx2::BVH4SubdivPatch1Intersector1
avx2::BVH4SubdivPatch1Intersector4
avx2::BVH4SubdivPatch1Intersector8
avx2::BVH4SubdivPatch1MBIntersector1
avx2::BVH4SubdivPatch1MBIntersector4
avx2::BVH4SubdivPatch1MBIntersector8
avx2::BVH4Triangle4Intersector1Moeller
avx2::BVH4Triangle4Intersector4HybridMoeller
avx2::BVH4Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH4Triangle4Intersector8HybridMoeller
avx2::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH4Triangle4iIntersector1Moeller
avx2::BVH4Triangle4iIntersector1Pluecker
avx2::BVH4Triangle4iIntersector4HybridMoeller
avx2::BVH4Triangle4iIntersector4HybridPluecker
avx2::BVH4Triangle4iIntersector8HybridMoeller
avx2::BVH4Triangle4iIntersector8HybridPluecker
avx2::BVH4Triangle4iMBIntersector1Moeller
avx2::BVH4Triangle4iMBIntersector1Pluecker
avx2::BVH4Triangle4iMBIntersector4HybridMoeller
avx2::BVH4Triangle4iMBIntersector4HybridPluecker
avx2::BVH4Triangle4iMBIntersector8HybridMoeller
avx2::BVH4Triangle4iMBIntersector8HybridPluecker
avx2::BVH4Triangle4vIntersector1Pluecker
avx2::BVH4Triangle4vIntersector4HybridPluecker
avx2::BVH4Triangle4vIntersector8HybridPluecker
avx2::BVH4Triangle4vMBIntersector1Moeller
avx2::BVH4Triangle4vMBIntersector1Pluecker
avx2::BVH4Triangle4vMBIntersector4HybridMoeller
avx2::BVH4Triangle4vMBIntersector4HybridPluecker
avx2::BVH4Triangle4vMBIntersector8HybridMoeller
avx2::BVH4Triangle4vMBIntersector8HybridPluecker
avx2::BVH8ColliderUserGeom
avx2::BVH8InstanceArrayIntersector1
avx2::BVH8InstanceArrayIntersector4Chunk
avx2::BVH8InstanceArrayIntersector8Chunk
avx2::BVH8InstanceArrayMBIntersector1
avx2::BVH8InstanceArrayMBIntersector4Chunk
avx2::BVH8InstanceArrayMBIntersector8Chunk
avx2::BVH8InstanceIntersector1
avx2::BVH8InstanceIntersector4Chunk
avx2::BVH8InstanceIntersector8Chunk
avx2::BVH8InstanceMBIntersector1
avx2::BVH8InstanceMBIntersector4Chunk
avx2::BVH8InstanceMBIntersector8Chunk
avx2::BVH8OBBVirtualCurveIntersector1
avx2::BVH8OBBVirtualCurveIntersector1MB
avx2::BVH8OBBVirtualCurveIntersector4Hybrid
avx2::BVH8OBBVirtualCurveIntersector4HybridMB
avx2::BVH8OBBVirtualCurveIntersector8Hybrid
avx2::BVH8OBBVirtualCurveIntersector8HybridMB
avx2::BVH8OBBVirtualCurveIntersectorRobust1
avx2::BVH8OBBVirtualCurveIntersectorRobust1MB
avx2::BVH8OBBVirtualCurveIntersectorRobust4Hybrid
avx2::BVH8OBBVirtualCurveIntersectorRobust4HybridMB
avx2::BVH8OBBVirtualCurveIntersectorRobust8Hybrid
avx2::BVH8OBBVirtualCurveIntersectorRobust8HybridMB
avx2::BVH8Quad4iIntersector1Moeller
avx2::BVH8Quad4iIntersector1Pluecker
avx2::BVH8Quad4iIntersector4HybridMoeller
avx2::BVH8Quad4iIntersector4HybridPluecker
avx2::BVH8Quad4iIntersector8HybridMoeller
avx2::BVH8Quad4iIntersector8HybridPluecker
avx2::BVH8Quad4iMBIntersector1Moeller
avx2::BVH8Quad4iMBIntersector1Pluecker
avx2::BVH8Quad4iMBIntersector4HybridMoeller
avx2::BVH8Quad4iMBIntersector4HybridPluecker
avx2::BVH8Quad4iMBIntersector8HybridMoeller
avx2::BVH8Quad4iMBIntersector8HybridPluecker
avx2::BVH8Quad4vIntersector1Moeller
avx2::BVH8Quad4vIntersector1Pluecker
avx2::BVH8Quad4vIntersector4HybridMoeller
avx2::BVH8Quad4vIntersector4HybridMoellerNoFilter
avx2::BVH8Quad4vIntersector4HybridPluecker
avx2::BVH8Quad4vIntersector8HybridMoeller
avx2::BVH8Quad4vIntersector8HybridMoellerNoFilter
avx2::BVH8Quad4vIntersector8HybridPluecker
avx2::BVH8Triangle4Intersector1Moeller
avx2::BVH8Triangle4Intersector4HybridMoeller
avx2::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx2::BVH8Triangle4Intersector8HybridMoeller
avx2::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx2::BVH8Triangle4iIntersector1Moeller
avx2::BVH8Triangle4iIntersector1Pluecker
avx2::BVH8Triangle4iIntersector4HybridMoeller
avx2::BVH8Triangle4iIntersector4HybridPluecker
avx2::BVH8Triangle4iIntersector8HybridMoeller
avx2::BVH8Triangle4iIntersector8HybridPluecker
avx2::BVH8Triangle4iMBIntersector1Moeller
avx2::BVH8Triangle4iMBIntersector1Pluecker
avx2::BVH8Triangle4iMBIntersector4HybridMoeller
avx2::BVH8Triangle4iMBIntersector4HybridPluecker
avx2::BVH8Triangle4iMBIntersector8HybridMoeller
avx2::BVH8Triangle4iMBIntersector8HybridPluecker
avx2::BVH8Triangle4vIntersector1Pluecker
avx2::BVH8Triangle4vIntersector1Woop
avx2::BVH8Triangle4vIntersector4HybridPluecker
avx2::BVH8Triangle4vIntersector8HybridPluecker
avx2::BVH8Triangle4vMBIntersector1Moeller
avx2::BVH8Triangle4vMBIntersector1Pluecker
avx2::BVH8Triangle4vMBIntersector4HybridMoeller
avx2::BVH8Triangle4vMBIntersector4HybridPluecker
avx2::BVH8Triangle4vMBIntersector8HybridMoeller
avx2::BVH8Triangle4vMBIntersector8HybridPluecker
avx2::QBVH4Quad4iIntersector1Pluecker
avx2::QBVH4Triangle4iIntersector1Pluecker
avx2::QBVH8Quad4iIntersector1Pluecker
avx2::QBVH8Triangle4Intersector1Moeller
avx2::QBVH8Triangle4iIntersector1Pluecker
avx512
avx5124fmaps
avx5124vnniw
avx512bf16
avx512bitalg
avx512bw
avx512cd
avx512dq
avx512er
avx512f
avx512fp16
avx512ifma
avx512pf
avx512vbmi
avx512vbmi2
avx512vl
avx512vnni
avx512vp2intersect
avx512vpopcntdq
avx::BVH
avx::BVH4ColliderUserGeom
avx::BVH4InstanceArrayIntersector1
avx::BVH4InstanceArrayIntersector4Chunk
avx::BVH4InstanceArrayIntersector8Chunk
avx::BVH4InstanceArrayMBIntersector1
avx::BVH4InstanceArrayMBIntersector4Chunk
avx::BVH4InstanceArrayMBIntersector8Chunk
avx::BVH4InstanceIntersector1
avx::BVH4InstanceIntersector4Chunk
avx::BVH4InstanceIntersector8Chunk
avx::BVH4InstanceMBIntersector1
avx::BVH4InstanceMBIntersector4Chunk
avx::BVH4InstanceMBIntersector8Chunk
avx::BVH4OBBVirtualCurveIntersector1
avx::BVH4OBBVirtualCurveIntersector1MB
avx::BVH4OBBVirtualCurveIntersector4Hybrid
avx::BVH4OBBVirtualCurveIntersector4HybridMB
avx::BVH4OBBVirtualCurveIntersector8Hybrid
avx::BVH4OBBVirtualCurveIntersector8HybridMB
avx::BVH4OBBVirtualCurveIntersectorRobust1
avx::BVH4OBBVirtualCurveIntersectorRobust1MB
avx::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
avx::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
avx::BVH4OBBVirtualCurveIntersectorRobust8Hybrid
avx::BVH4OBBVirtualCurveIntersectorRobust8HybridMB
avx::BVH4Quad4iIntersector1Moeller
avx::BVH4Quad4iIntersector1Pluecker
avx::BVH4Quad4iIntersector4HybridMoeller
avx::BVH4Quad4iIntersector4HybridPluecker
avx::BVH4Quad4iIntersector8HybridMoeller
avx::BVH4Quad4iIntersector8HybridPluecker
avx::BVH4Quad4iMBIntersector1Moeller
avx::BVH4Quad4iMBIntersector1Pluecker
avx::BVH4Quad4iMBIntersector4HybridMoeller
avx::BVH4Quad4iMBIntersector4HybridPluecker
avx::BVH4Quad4iMBIntersector8HybridMoeller
avx::BVH4Quad4iMBIntersector8HybridPluecker
avx::BVH4Quad4vIntersector1Moeller
avx::BVH4Quad4vIntersector1Pluecker
avx::BVH4Quad4vIntersector4HybridMoeller
avx::BVH4Quad4vIntersector4HybridMoellerNoFilter
avx::BVH4Quad4vIntersector4HybridPluecker
avx::BVH4Quad4vIntersector8HybridMoeller
avx::BVH4Quad4vIntersector8HybridPluecker
avx::BVH4SubdivPatch1Intersector1
avx::BVH4SubdivPatch1Intersector4
avx::BVH4SubdivPatch1Intersector8
avx::BVH4SubdivPatch1MBIntersector1
avx::BVH4SubdivPatch1MBIntersector4
avx::BVH4SubdivPatch1MBIntersector8
avx::BVH4Triangle4Intersector1Moeller
avx::BVH4Triangle4Intersector4HybridMoeller
avx::BVH4Triangle4Intersector8HybridMoeller
avx::BVH4Triangle4Intersector8HybridMoellerNoFilter
avx::BVH4Triangle4iIntersector1Moeller
avx::BVH4Triangle4iIntersector1Pluecker
avx::BVH4Triangle4iIntersector4HybridMoeller
avx::BVH4Triangle4iIntersector4HybridPluecker
avx::BVH4Triangle4iIntersector8HybridMoeller
avx::BVH4Triangle4iIntersector8HybridPluecker
avx::BVH4Triangle4iMBIntersector1Moeller
avx::BVH4Triangle4iMBIntersector1Pluecker
avx::BVH4Triangle4iMBIntersector4HybridMoeller
avx::BVH4Triangle4iMBIntersector4HybridPluecker
avx::BVH4Triangle4iMBIntersector8HybridMoeller
avx::BVH4Triangle4iMBIntersector8HybridPluecker
avx::BVH4Triangle4vIntersector1Pluecker
avx::BVH4Triangle4vIntersector4HybridPluecker
avx::BVH4Triangle4vIntersector8HybridPluecker
avx::BVH4Triangle4vMBIntersector1Moeller
avx::BVH4Triangle4vMBIntersector1Pluecker
avx::BVH4Triangle4vMBIntersector4HybridMoeller
avx::BVH4Triangle4vMBIntersector4HybridPluecker
avx::BVH4Triangle4vMBIntersector8HybridMoeller
avx::BVH4Triangle4vMBIntersector8HybridPluecker
avx::BVH8ColliderUserGeom
avx::BVH8InstanceArrayIntersector1
avx::BVH8InstanceArrayIntersector4Chunk
avx::BVH8InstanceArrayIntersector8Chunk
avx::BVH8InstanceArrayMBIntersector1
avx::BVH8InstanceArrayMBIntersector4Chunk
avx::BVH8InstanceArrayMBIntersector8Chunk
avx::BVH8InstanceIntersector1
avx::BVH8InstanceIntersector4Chunk
avx::BVH8InstanceIntersector8Chunk
avx::BVH8InstanceMBIntersector1
avx::BVH8InstanceMBIntersector4Chunk
avx::BVH8InstanceMBIntersector8Chunk
avx::BVH8OBBVirtualCurveIntersector1
avx::BVH8OBBVirtualCurveIntersector1MB
avx::BVH8OBBVirtualCurveIntersector4Hybrid
avx::BVH8OBBVirtualCurveIntersector4HybridMB
avx::BVH8OBBVirtualCurveIntersector8Hybrid
avx::BVH8OBBVirtualCurveIntersector8HybridMB
avx::BVH8OBBVirtualCurveIntersectorRobust1
avx::BVH8OBBVirtualCurveIntersectorRobust1MB
avx::BVH8OBBVirtualCurveIntersectorRobust4Hybrid
avx::BVH8OBBVirtualCurveIntersectorRobust4HybridMB
avx::BVH8OBBVirtualCurveIntersectorRobust8Hybrid
avx::BVH8OBBVirtualCurveIntersectorRobust8HybridMB
avx::BVH8Quad4iIntersector1Moeller
avx::BVH8Quad4iIntersector1Pluecker
avx::BVH8Quad4iIntersector4HybridMoeller
avx::BVH8Quad4iIntersector4HybridPluecker
avx::BVH8Quad4iIntersector8HybridMoeller
avx::BVH8Quad4iIntersector8HybridPluecker
avx::BVH8Quad4iMBIntersector1Moeller
avx::BVH8Quad4iMBIntersector1Pluecker
avx::BVH8Quad4iMBIntersector4HybridMoeller
avx::BVH8Quad4iMBIntersector4HybridPluecker
avx::BVH8Quad4iMBIntersector8HybridMoeller
avx::BVH8Quad4iMBIntersector8HybridPluecker
avx::BVH8Quad4vIntersector1Moeller
avx::BVH8Quad4vIntersector1Pluecker
avx::BVH8Quad4vIntersector4HybridMoeller
avx::BVH8Quad4vIntersector4HybridMoellerNoFilter
avx::BVH8Quad4vIntersector4HybridPluecker
avx::BVH8Quad4vIntersector8HybridMoeller
avx::BVH8Quad4vIntersector8HybridMoellerNoFilter
avx::BVH8Quad4vIntersector8HybridPluecker
avx::BVH8Triangle4Intersector1Moeller
avx::BVH8Triangle4Intersector4HybridMoeller
avx::BVH8Triangle4Intersector4HybridMoellerNoFilter
avx::BVH8Triangle4Intersector8HybridMoeller
avx::BVH8Triangle4Intersector8HybridMoellerNoFilter
avx::BVH8Triangle4iIntersector1Moeller
avx::BVH8Triangle4iIntersector1Pluecker
avx::BVH8Triangle4iIntersector4HybridMoeller
avx::BVH8Triangle4iIntersector4HybridPluecker
avx::BVH8Triangle4iIntersector8HybridMoeller
avx::BVH8Triangle4iIntersector8HybridPluecker
avx::BVH8Triangle4iMBIntersector1Moeller
avx::BVH8Triangle4iMBIntersector1Pluecker
avx::BVH8Triangle4iMBIntersector4HybridMoeller
avx::BVH8Triangle4iMBIntersector4HybridPluecker
avx::BVH8Triangle4iMBIntersector8HybridMoeller
avx::BVH8Triangle4iMBIntersector8HybridPluecker
avx::BVH8Triangle4vIntersector1Pluecker
avx::BVH8Triangle4vIntersector1Woop
avx::BVH8Triangle4vIntersector4HybridPluecker
avx::BVH8Triangle4vIntersector8HybridPluecker
avx::BVH8Triangle4vMBIntersector1Moeller
avx::BVH8Triangle4vMBIntersector1Pluecker
avx::BVH8Triangle4vMBIntersector4HybridMoeller
avx::BVH8Triangle4vMBIntersector4HybridPluecker
avx::BVH8Triangle4vMBIntersector8HybridMoeller
avx::BVH8Triangle4vMBIntersector8HybridPluecker
avx::QBVH
avx::QBVH4Quad4iIntersector1Pluecker
avx::QBVH4Triangle4iIntersector1Pluecker
avx::QBVH8Quad4iIntersector1Pluecker
avx::QBVH8Triangle4Intersector1Moeller
avx::QBVH8Triangle4iIntersector1Pluecker
avxi
avxifma
avxneconvert
avxvnni
avxvnniint16
avxvnniint8
aw0<
aw:R)z8f0
ay:3
ayP<
az=\t4d
azE:Ty
a{6u
a};xX
a~9b
a~C<7P;
b#a=TO
b%8w
b%F:x
b'9A
b-u9
b0<J
b1!;j
b1;:wM<
b1;JF
b1i:
b2&:q
b2f=
b2k;
b3:/n
b3D<B\t
b3G;
b3U<
b4r;
b5:i
b5<x
b5K;n
b69;
b6m9
b7;b
b7<i7a
b89Y
b8:X*r:
b8;m
b8I)B
b8v{
b9/l
b989d
b9:A>
b9kI
b: Vw:M
b:!3D
b:4@i
b:AR
b:WlH:l
b:f8~
b:iF
b:k5
b:sM
b:su
b:t4
b;#\ru9q\k;n
b;0j
b;15
b;48
b;56*
b;6F
b;6o
b;8i
b;9P
b;Bs
b;Bv
b;Cp
b;ML
b;QuJ
b;Uk
b;V3
b;Wt
b;aD
b;eB
b;iZ
b;lh'
b;qr
b;u3
b;vZ
b;wr
b;z9
b;zU
b<6Y
b<Af@
b<AiK
b<JIL
b<Lg
b<O<y
b<PZ
b<SR
b<]zy
b<hM
b<o|T
b<tS
b<vE
b<z3?9
b<za
b=Jz
b=k!U
b=zd1?
b=zv#
b>0e
b>1f
b>9<mI
b>H4
b>x8?
b>x<r
b?Z<c?s
b@>ca
bB:b^
bB<;0
bC 9,o
bC3<
bC6:
bCP=
bCZ;=O\n
bCn=
bD;g
bE=y
bED;
bE\v;e
bEu:VQ
bF>e
bF@9
bG;9
bG<K
bH7I4
bH}=X
bI;W
bJ$9
bK+9
bK;G
bKL;
bKh;
bM89
bM;R]
bM;x\rx
bN<5
bNI<,
bO:Y
bON;
bQ;mRA;T\n
bQ=<s
bR;Q
bS:i
bSv:
bU1<
bU;R
bU>:W
bUb<;
bV;p
bVE;
bW:C
bWo<
bZ\t9
b\<LXJ
b\fB7s
b\fBn
b\n;11
b]:Cf
b]p:k
b]x;I
b`?<0HH
ba;E
baJ<
bad conversion
bad_weak_ptr
bakePaths
bakeReflections
barrier_sys_regression_test
bb%:H
bb9<
bb;H
bb\v<D[c
bd;vK3
be ;2
before the call to the DFGMRES_CHECK routine. Make sure to
benchmark
bf-;L
bf:If
bf:mL
bf=y
bg1;
bg5;_
bg;r
bh;?L
bh;n
bh<YR
bhP:sQ
bhk;D{
bi9n1
biE<j%
biX>
bij:@
biz:
bj;m
bj>F
bjE8]
bjH<
bjW;
bk;S8N
bk]9
bl;d
bm<j
bm=Z{
bn;o
bn;y
bn=0
bnE;
bnb;
bn~<xk
bp*<SZ
bq:C
bqY:
br;5 
brR;$j@
brf;
brh:\
bs<v
bsk;
bt<B
btS;-
bu:r
bue9B
buffer range out of bounds
buffer too large
bug;M
builder
builder_mb
building BVH
bv84
bv:C/A
bvD;
bvh.builder
bvh.force2level
bvh.forceflat
bvh.sah.extra_node_budget
bvh.sah.max_split_depth
bvh.sah.min_overlap
bvh.sah.traversal_cost
bvh.sah.use_splits
bvh.usesplits
bvh2l
bvh4.grid.eager
bvh4.quad4i
bvh4.quad4imb
bvh4.quad4v
bvh4.subdivpatch1eager
bvh4.triangle4
bvh4.triangle4i
bvh4.triangle4imb
bvh4.triangle4v
bvh4.triangle4vmb
bvh4.virtualcurve4imb
bvh4.virtualcurve8imb
bvh4obb.virtualcurve4i
bvh4obb.virtualcurve4v
bvh4obb.virtualcurve8i
bvh8.quad4i
bvh8.quad4imb
bvh8.quad4v
bvh8.triangle4
bvh8.triangle4i
bvh8.triangle4imb
bvh8.triangle4v
bvh8.triangle4vmb
bvh8.virtualcurve8imb
bvh8obb.virtualcurve8v
bvh_builder: branching factor too large
bw ;2
bw0;
bw0<(
bw;*j
bwX<
bwk=
by8\n
byU7
c 8@V
c"<5S
c#C<d
c$:5i
c%;j51:l
c&<pn
c':HR
c'G9\n
c*2;s
c*6:2
c-;aB
c/u:s
c0;i
c0=y\
c0S<I2#
c0w=
c10>
c1:i
c1;GN
c2=o
c2H<
c39f
c4:|Wz
c4;A
c4C=
c4N=
c5<x
c6<8
c6>N
c73<h
c7;j
c7=9
c8-"j
c8YxT9hJA
c8]vo:1
c8hxs;
c8vx
c8z;)D
c93UT
c9:y
c9D3
c9PK
c9Rl
c9^X
c9cK
c9f=
c9i^
c9m!
c9zx
c:)p2
c:4o
c:7s
c:?e5
c:Bht
c:EC
c:QoM
c:fy4
c:lw
c:w8
c:w9
c:zA
c;1c
c;4v
c;5N
c;7wR;
c;8k
c;9i
c;EI
c;Fu
c;LL6;N
c;Oh!
c;SkW
c;Stz;
c;UUUUUU
c;Wa
c;Y[n;C
c;Zm
c;b3s;
c;bd
c;e?g
c;kh
c;lD-
c;nS
c;y@2
c;z?L
c<1k
c<9cY
c<Gz
c<HR
c<Wx\v
c<d,8
c<uwv
c=*HZ
c=G$t
c=Q53=
c=RY
c=j9
c=s9!
c=ut
c>2\nx
c>48
c>;R4
c>BS
c>SDp
c>Vh
c?i9
cA;o|q:VC
cAQ;
cB<x
cBk<
cC6<
cC<G
cC<g
cC}=Hu
cD;[D
cD;l
cE<D
cE<J~
cEK<
cEm;
cF2;
cF;8
cG95_E
cG<AE\f
cG<y
cGN;n
cH;3x
cI5<
cI5<u
cJS<s
cK;b=U;
cK=v
cKW:
cL;&1
cLk>M\r
cM;k
cMN;
cN!:3
cN<a
cN<ti
cP>4R
cP`<U
cQ4;
cQ;CQ
cQ<H
cR=flT
cRH;4FQ;
cS"9
cS<HD
cSQ:
cU>an
cV[6
cVj9
cW:p
cX9*
cX<8yQ
cXY;
cY<A
cZ8m
cZ=3
cZM;
cZ\n;6
c\=3S
c\r;hF
c\tC=t
ca:X
ca>:C
cache_accesses
cache_flushes
cache_hits
cache_misses
cache_num_patches
cache_regression_test
cache_size
calculateAirAbsorption
calculateDirectivity
calculateDistanceAttenuation
calculateRelativeDirection
call to DCG routine.
call to DCG routine. Otherwise, the maximal number
call to DFGMRES routine. Otherwise, the maximal number of iterations is equal to
cannot unget that many items
cartesian
cb;q
cb<C
cbQ;
cbi9
cblas_sgemv
cc7;
cc;w
ccV:
cd4;]
cd>,DZ>
cdV;
cdecl
ce*9
ce:w
ce\n;K
cf;U@
cfx<i
cg>y
cgf=
ch;C
ch;I
chq;c
ci5<A
ci8:!
ciQ<
cjP9
ck:Ug,
ckA;;
ck\n?s
cl;[6
clBuildProgram
clCompileProgram
clCreateBuffer
clCreateBuffer failed
clCreateCommandQueue
clCreateCommandQueue failed
clCreateContext
clCreateContext failed
clCreateKernel
clCreateKernelsInProgram
clCreateKernelsInProgram failed
clCreateKernelsInProgram return 0 kernels
clCreateProgramWithSource
clCreateProgramWithSource failed
clCreateSubBuffer
clEnqueueCopyBuffer
clEnqueueFillBuffer
clEnqueueMapBuffer
clEnqueueMapBuffer failed
clEnqueueNDRangeKernel
clEnqueueNDRangeKernel failed
clEnqueueReadBuffer
clEnqueueReadBuffer failed
clEnqueueUnmapMemObject
clEnqueueUnmapMemObject failed
clEnqueueWriteBuffer
clEnqueueWriteBuffer failed
clFinish
clFinish failed
clFlush
clFlush failed
clGetCommandQueueInfo
clGetDeviceIDs
clGetDeviceIDs failed
clGetDeviceInfo
clGetDeviceInfo failed
clGetEventInfo
clGetEventInfo failed
clGetKernelInfo
clGetKernelInfo failed
clGetMemObjectInfo
clGetMemObjectInfo failed
clGetPlatformIDs
clGetPlatformIDs failed
clGetPlatformInfo
clGetPlatformInfo failed
clGetProgramBuildInfo
clReleaseCommandQueue
clReleaseContext
clReleaseDevice
clReleaseEvent
clReleaseKernel
clReleaseMemObject
clReleaseProgram
clRetainCommandQueue
clRetainContext
clRetainDevice
clRetainEvent
clRetainKernel
clRetainMemObject
clRetainProgram
clSetKernelArg
clSetKernelArg failed
clWaitForEvents
clWaitForEvents failed
cl_amd_media_ops2
cldemote
clean
cleaned memory, deleted number of L&U-factorizations: %d
cleaned memory, deleted number of L&U-factorizations: %lli
closure stack overflow
clwb
cm;w
cmL;
cmpccxadd
cmq>
cnP:
cnR<
co%;hx
code, or the parameter IPAR(7)=%s was altered by mistake outside of the routine.
code, or the parameter ipar[6]=%s was altered by mistake outside of the routine.
collider  = 
collision_regression_test
combineBandpassedImpulseResponse
compact
computeAlignedSpace not implemented for this geometry
computeDirection not implemented for this geometry
converged, or parameter DPAR(5) was altered by mistake outside of the DFGMRES routine.
convertAmbisonicAudioBuffer
convertToDeviceRepresentation not implemented for this geometry
convolutionQueue
copy
counter IPAR(4)=%s
cp<P
cpw;
cq;<v
createAmbisonicsBinauralEffect
createAmbisonicsDecodeEffect
createAmbisonicsEncodeEffect
createAmbisonicsPanningEffect
createAmbisonicsRotationEffect
createBinauralEffect
createContext
createDirectEffect
createEmbreeDevice
createEnergyField
createHRTF
createImpulseResponse
createInstancedMesh
createOpenCLDevice
createOpenCLDeviceFromExisting
createOpenCLDeviceList
createPanningEffect
createPathEffect
createPrimRefArray not implemented for this geometry
createPrimRefMBArray not implemented for this geometry
createProbeArray
createProbeBatch
createRadeonRaysDevice
createReconstructor
createReflectionEffect
createReflectionMixer
createScene
createSerializedObject
createSimulator
createSource
createStaticMesh
createTrueAudioNextDevice
createVirtualSurroundEffect
created scene intersector
criterion, but it cannot be replaced as IPAR(31)=0.
cs>Ao
cu*:Q
cu9M
cu:'r
curve4i
curve4imb
curve4v
curve8i
curve8imb
curve8v
cv8<
cx9;
cx;E
cx<P
cy$tP
cy:1V
cy<3
cz:^C
cz;6
c{O<h
d"9c
d"9d l:
d$;iY
d$;j7
d$<gn
d&:0A
d&;DU
d'9n
d';aV@9
d(u8
d)v<H
d+;ox
d.M9
d0\r6
d1;J
d1;s
d1=Qg
d1>C
d2;4
d2>\vX
d2a;
d30=
d3;G
d3;H*k
d3;Lb
d3;n
d3<s
d3K;:[B
d46;,
d4S:
d4X;
d5;Y
d5<>i
d6:d
d6:yi
d6>w
d79Y\r-8
d7;R
d84<5k
d88O
d8s;i
d9-o
d9/Y
d93PM:
d93e
d9<Q
d9Eq2
d9\tz
d9p&G
d:6Z
d:75S:
d:7c
d:7v&
d:Bfk
d:Ei
d:M~g
d:Q3b
d:_dO
d:bEB
d:o1g<W
d:s+Z
d:vba
d:x5
d:|Gm
d;$2x
d;6z
d;8t
d;;Td
d;@Q8
d;Jv
d;MT
d;V9
d;W9
d;_}T9eq2;yX
d;b3
d;jD:
d;l)o
d;nJ
d;qs5;
d;wsj<
d;x8
d<0F\f
d<35
d<9W
d<Pn1
d<Tm\f
d<Ua
d<WN
d<\7c
d<dDM
d<fF
d<fF&
d<hu8
d<rj
d<sHf
d<soF
d<wo
d<xo
d=0i\r
d=5K
d=7j
d=TT
d=e2
d=jf
d=m:r
d>1W~
d>2P
d>U"D=z
d>tP
d>tv
d?;2x
dA;5/
dA;q
dAq;
dC<R
dC<n
dC<wz
dD&;r
dD:Ckl
dE;iyn;
dG%9
dG;t
dH:U
dI:*b
dI;So
dI=s.
dJ9v
dK:d\f
dK=D
dKY;
dKe:
dL3;
dL:f
dM8C
dM<7R
dN0:
dN]9
dNx=
dO;O
dO;th
dP9Z
dP;4e<;
dP?=MQ?
dP\r<u
dPb;
dPz;
dQ0;
dQ7:
dQH;fdo; #
dR5;
dRD;X)
dS;Jo3;
dSB<
dS\r<nT
dTD:
dTV:'
dTq<*A[
dU;H5
dU<F
dV;8
dV<lL
dVM<
dW:\rH
dW:z
dX3;
dX89
dX<<k
dXN:)
dXT9
dX\f<Uy
dXb;
dXp=
dY<4%
dZ<6i
d\W?G
d\W?d\W?d\W?d\W?
d\W?d\W?d\W?d\W?G
d\W?d\W?d\W?d\W?d\W?d\W?d\W?d\W?G
d\fm;I
d\n9<[yP
d\v;W1*9
d\vO=o
d];OO
d_&8G
d_O;.Cz;Z
d_forward_trig_transform/d_backward_trig_transform routine.
d`k:7
da:K
da;Z4
dat;
data must be 4 bytes aligned
db5=
db:;9P;H
dbf:CK\t
db};c$v
dc;Ak
dci9
dck;<
dd$;z
ddt<
de5:e
de8;L9\n;U
de<2f<
de\r;P
deinterleaveAudioBuffer
depth limit reached
deque<T> too long
device
deviceDesc
deviceList
df;qye;
dg27\f%8
dg;ly
dg;~q
dge=*
dgx='
dh4<
di.<GZ
diagonal matrix problem
disabled\n
disc
distribute_part_sum_int4
division by a small diagonal value will happen.
dj9xf
dk:l]k<
dk;q
dkU<U|
dkv>
dlO=
dlci
dm9sW
dm|9xu"
do,9
do;P-X
do<9y
do<c
downmixAudioBuffer
dqU;o
dsj<
dst->data
dst->data[iChannel][dst->numSamples - 1]
dst->numChannels
dst->numSamples
dst[iArray]
duR;
during initialization stage. Computations have stopped.
during the initialization stage. Computations have stopped.
dw:K
dw;i
dwl<
dynamic
dyt<
dz=G
dz=q
d{;lt
d|T<d
e 9ht
e =pKH
e"2<Z
e#;fV
e%c<S1
e';YKY:
e(<Pz
e*E<y
e*q9c
e.5;+oB
e/;Q5
e01<}
e1:/R
e1;2\v
e1=l
e1A;'
e28E
e2:g
e389
e3;;R
e3J;
e4<5
e4=t
e4B:
e4`;3\6
e5y<_
e7.? bz
e7<p
e7t;@n3
e8%H
e8V;
e8gl
e9:pn
e9;N^J
e9Pl(
e9[x
e9\tL
e9e,%
e9k'O
e9m)
e9s3C
e9zc
e:9i
e:;Uc
e:@q7
e:An
e:EF
e:L3L
e:MBI
e:Rfx:
e:bKt
e:lYF;
e:l{l
e:oZ
e:vCw;
e;!oW
e;0an;
e;8A
e;8E
e;8k
e;<zk
e;CG
e;ES
e;FH
e;JH
e;Ox
e;Q0
e;R7
e;W4
e;W5
e;eA
e;eO
e;fzp;^
e;p5
e;r8
e;sI
e;szf
e;t6
e;tH
e;wg
e<&xF
e<Rc
e<Rf
e<XT
e<i3
e<ii
e<rT
e<rg
e<sC
e=LQ
e=PM
e=oy
e=rAe>U:f
e>N>d
e>os.
e?5t,?d
e?:qI
e?AoZ
eA:wo
eB=R
eC:F
eC:X
eC<$o
eDj;
eE;Y
eE=rs
eF<b
eF{;l
eH\t=ME
eIq;
eI};giW
eJ:W
eJ;B
eJ;X
eJ=p
eKS=
eL9L
eL;1
eL<<g8G
eL<H
eLR;
eM;l
eN9=3W
eN;\re
eO;z
eO<U
eO<dH(
eO\v8
eP8RG
ePw:1)
eR;t
eS;{HA;
eT>1
eTE<e
eTX;+
eTq<X
eU<Dh
eVW=z?
eW9h>>:
eW=88z
eW>M
eX;!7I:
eX=i
eXd;fs
eZ<1G
eZN;i
e[;4OV
e\t;OW
e`;Zd
ebN<
ecj;2
ed<9i2
eeu<M
ef$;TE
effect
effectSettings
effectSettings->hrtf
effectSettings->irSize
effectSettings->maxOrder
effectSettings->numChannels
effectSettings->spatialize
effectSettings->speakerLayout.numSpeakers
effectSettings->speakerLayout.speakers
effectSettings->speakerLayout.speakers[iSpeaker].x
effectSettings->speakerLayout.speakers[iSpeaker].y
effectSettings->speakerLayout.speakers[iSpeaker].z
effectSettings->speakerLayout.type
effectSettings->type
egf;
eh';8
eh3<
eh;x
eh>N
ej:g
ejk<
ekz;
el:l
el=V
elO;
em0<
em;h+
emd>&
en2;
en8/
en;G
en<e
enable_compressed_reverb_lookup
enable_dc_correction_for_phase_interpolation
enable_hybrid_eq_from_ir
enable_iir_order_8
enable_iir_order_switching
enable_paths_from_all_source_probes
enable_reverb_probe_caching_for_missing_probes
enable_selockmemoryprivilege
enabled (forced)\n
enabled\n
energyField
enqcmd
eq8:
eq:x
eqD<
equal to 0 simultaneously.
er);p
ero;.
error: more roots than expected\n
es;9
eu;j
ev%8
ev2;
ev8;
evN;
evl;
exL=8
expf
eyX<Y
eyu9
ez37
ez\n<S
e}4=Z
e}<LN3<
f %d %d %d\n
f!y<7
f"<dZ
f#aC.
f':6J
f';KjX:
f)p9
f+:qdA;
f,9D\t
f-;ytZ;
f.8J
f.:Ju
f0<\R
f16c
f1=E
f1L<
f3:2
f3;I
f3<x
f3X=
f3Z)
f4D<
f59I
f5:4
f5B<
f65;
f6;3f
f7\v8#
f82rB
f8?ls7
f8I:
f94748
f99X
f99u
f9P}
f9aM~:
f9l#
f9w=`p
f9wZ~9
f:NG
f:Sw$9
f:WV*;Td
f:YXn9
f:iby:
f:itd:\t
f:yb
f;!Ss
f;1x
f;5X
f;8\rH9W
f;<Wm
f;<lZ
f;EqK
f;H9n:
f;J;c
f;JJ
f;Tm7
f;U9
f;Yt
f;\r2o
f;\rXx
f;\vKF
f;ds
f;jU
f;k9
f;k\nF:j
f;m7
f;s0
f;t'4<u
f;uxs
f;xN
f<C%t
f<RG
f<Wt
f<Y4
f<cF?
f<dT
f<f'f<I
f<he
f<oE
f<pn
f<rj
f<sT
f<y$X
f=04
f=2K
f=Y{Q
f=tf
f>0Q
f>0Wy=
f>>>L>T>X>\(
f@Z;X
fAK;Q
fB;d
fDdA
fE:k
fE>9.
fES:
fF;M
fF`8
fFq9t
fFs;
fG9A
fG:HZ
fG<D
fG=J
fHM;3
fI8:
fI;X
fK\n<n
fM3<#
fNK;
fO:xK
fP;?C";UI
fQn=;
fR <4c\f
fR-;p
fRs=|
fT;H
fT<X
fT=9X
fTS;|
fT\r<Zf2
fTc;
fTk:O
fU;0
fUJ<X
fW5:
fW:o
fW;-I
fX=s
fY;k
fYd;
fYf;!
fZ:K
fZ;6=u
f[#9a'g
f\f=MO
f\n9Q
f]R=r/X
f^P:G
f`;N#O9aU
fa>ac
factorize
fast
fast_allocator_regression_test
fatbvh
fatbvh accelerator can cause stack overflow for this scene, try using bvh instead
fatbvh accelerator can't allocate enough stack memory, try using bvh instead
fb1:\r
fb7;O
fb=S]
fc:G
fe:9
fe<M
ff9381774dc99fea81a932ad276677aad6a3d4dd
ff;P
fg;s
fg>5Xu
fho;c
fi;r
fiG;I
fi^;I
fileBaseName
fill-in parameter is negative.
filter functions not supported for this geometry
finished BVH
fj:i
fj;m
fj>c
fk9p
fkU:^o
fl3=
fl;9c<
flat_bezier_curve
flat_bspline_curve
flat_catmull_rom_curve
flat_hermite_curve
flat_linear_curve
float_exceptions
fm<Vy
fn19
fn9"}
fn9ll
fn@;Q
fnp<
format or the matrix is degenerate with zero row.
fp09*$u:\tS
fp;M
fq1<&JF
fq;N
fqp;E
fr:0
free = 
freeAudioBuffer
frequency_level
fs0<
fsv<?c
ft;C
ft;u
ftR>l
fu>6
function BVH4Curve8iBuilder_OBB_New not supported by your CPU
function BVH4OBBCurve8iMBBuilder_OBB not supported by your CPU
function BVH8BuilderTwoLevelInstanceArraySAH not supported by your CPU
function BVH8BuilderTwoLevelInstanceSAH not supported by your CPU
function BVH8BuilderTwoLevelQuadMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelTriangle4MeshSAH not supported by your CPU
function BVH8BuilderTwoLevelTriangle4iMeshSAH not supported by your CPU
function BVH8BuilderTwoLevelTriangle4vMeshSAH not supported by your CPU
function BVH8Curve8vBuilder_OBB_New not supported by your CPU
function BVH8InstanceArrayMBSceneBuilderSAH not supported by your CPU
function BVH8InstanceArraySceneBuilderSAH not supported by your CPU
function BVH8InstanceMBSceneBuilderSAH not supported by your CPU
function BVH8InstanceSceneBuilderSAH not supported by your CPU
function BVH8OBBCurve8iMBBuilder_OBB not supported by your CPU
function BVH8Quad4iMBSceneBuilderSAH not supported by your CPU
function BVH8Quad4iSceneBuilderSAH not supported by your CPU
function BVH8Quad4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Quad4vSceneBuilderSAH not supported by your CPU
function BVH8QuantizedQuad4iSceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4SceneBuilderSAH not supported by your CPU
function BVH8QuantizedTriangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4SceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4SceneBuilderSAH not supported by your CPU
function BVH8Triangle4iMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4iSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vMBSceneBuilderSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderFastSpatialSAH not supported by your CPU
function BVH8Triangle4vSceneBuilderSAH not supported by your CPU
function VirtualCurveIntersector8i not supported by your CPU
function VirtualCurveIntersector8iMB not supported by your CPU
function VirtualCurveIntersector8v not supported by your CPU
fvA;
fwZ9:
fx;1?
fy=p:5
fz;|g
fzK=
g!3;Rn8
g!T9"d
g"I=J
g'L;kd
g*;s31
g+m;sO
g,;wa 9c
g-;w1
g14:
g2;H
g2{:Rn
g3;v
g3='L
g3>:2w
g5;I
g5C=
g5K;
g5w<
g7g<
g837
g88ew
g8;r
g8>G
g8B~0GBf
g8F+
g8T9
g9(,q
g9P0
g9P[T<Q
g9P|
g9\fu
g9\nB
g9xP
g9z5
g9|3
g9|A[
g: kP;O
g:BQ
g:PF
g:PZP:
g:WM%
g:go
g:qmU;
g:u1
g:wc
g:y7Y
g:ya
g;2zI;
g;5"8
g;6;S
g;9"5
g;G7p;
g;G;kyW
g;H|U
g;IY(
g;MM
g;QXf
g;Ur
g;Vv
g;aSx
g;hD&;E
g;ia
g;jGB
g;u0
g;x?0
g;yb
g<4F
g<C'z
g<Eb
g<G`V
g<\nE1
g<ir_
g<i{F
g<k/K
g<kH
g<vm2<
g=9t
g=Fj
g=N~l
g=QI`
g>0H6
g>2R
g>DP
g?59
g@2:9
gAff
gB2<
gB;k
gB<S
gC8U
gC9UQ
gC<W
gC<j
gC>L
gDk<
gE<uT
gG(;L
gG=o
gGV=pD'=
gHD9
gI3\v>
gI9&
gI;F
gI;]R
gI;u0
gIF;
gK:'9
gK:B
gL<3
gLV;I3
gNh;N
gO6;
gO;uIg
gOV:
gOu:
gP:3J
gP:i
gP;\nP
gP>9
gR9>W8
gR<7
gRC:h+
gS;chc;rx
gS<nC
gT\;QYI
gU(:;47
gU9*q
gU9z
gU:P
gUD;ZU
gUUU
gVg;^
gWW;
gX;w
gXH;
gY(<d
gY:q
gY;,h
gY;F[
gY<F~
gY^8
gZ:LI
gZG<X
gZK=
gZt=
gZy:2
g\t<$\t;;m9r:
g\v;KZa:6
g\z>RD
g^9z
g^x=i
g_N=j
g_j<H_w
ga;p
ga<l
gatherEnergyField
gatherImage
gb6=Md
gb<4
gc:7
gc:oF
gd3<
gd:X
gdB:
gdI:u
ge8>
ge9eS
general:
generateCameraRays
generateListenerRays
generateProbes
geomID does not return correct type
geometry not committed
getDataSize
getDeviceDesc
getEnergyField
getGeometryDataDeviceByteSize not implemented for this geometry
getNumBins
getNumChannels
getNumDevices
getNumProbes
getNumSamples
getOutputs
getProbe
getReverb
gf=n
gfni
gg:C\r4<t`
ggd:
gi;u
gj;n
gjZ>
gjx:M
gk3:G
gk:c
glK< 
gm9S
gm;ZD
gnT;
go6]
go7H=_;K
go>~T
gp;:nJ
gpH=@
gq0:
gqS<_
gr9D
grid
grid_accel
grid_accel_mb
grids:
gsS:&
gsm;
gt9rm
gt:<h
gtv;
guo:
gv<b
gw?nR
gx19
gxb;t
gy7=
gy=C
gzZ>
h#:KB
h&2;2r
h(92
h)M;s
h*89A
h+G;0I
h+p8
h-;0d
h-t=e
h0D:
h1F96(6
h1R9
h2<Mp
h2=Q
h2p<
h32;
h4:IgZ
h4L;
h4a2
h5:x
h5<%k
h5U:L
h60;kG
h6D;2t;<6
h6Q<P
h6g<
h8n:
h9 20
h9*yx:UQ
h95[$
h96;'
h96H
h9:0
h9<qah
h9=R
h9>0
h9>1
h9Cv
h9EC"
h9OE.;
h9^c89
h9d7):$
h9fM
h9g~
h9j"A
h9wq
h9{SR
h:2hH;z
h:62=
h:;pa
h:D;b
h:LCp
h:S0
h:Ta
h:b,T
h:ny
h:o\8
h:or^9
h;0F\
h;8T
h;Adi;rr:
h;Av
h;Bn
h;Dp\f
h;DtG
h;GX
h;Hv
h;NDn:
h;UBa
h;Xt
h;Y&1
h;YJ
h;\fZV;7e
h;bU
h;cH
h;eK
h;fKn;06r;
h;lE
h;nD
h;tr
h;yjo;K=
h<+8U
h<26
h<<WDD
h<A<w
h<Ax
h<Nr
h<OC6
h<V)m
h<V@z
h<]eM
h=$mU
h='si
h=:"OV9
h=:tM
h=;kSp
h=EZ
h=Ma
h=YD
h=ZK
h=c(5
h=f2H
h=qI%
h=zg
h>YR
h>^ht>0
h?5u
h?=vxX
h?tF
hB)9
hB.<C6F
hB0;#
hB:QN49
hB>J
hBDW
hB^T{C;
hBc;y
hBp9
hC<D
hCR;
hE<4
hF=2o
hG<=0
hG<g
hH:s
hHB:
hI;v
hI;z;
hJ<F
hKH;
hL<.P
hM:"v
hM;U
hM<F
hMK</u
hMK<sJs
hN<a
hN=@j
hOx;
hP8<
hP:qk
hQ7;
hQ;U
hR>\fpm
hS;4P
hTy>
hU9{|
hU:q=
hUK;
hU\;CJ
hV0<e
hVC;Lo
hVk;
hW;w
hW<J
hW=m
hX:3jG;F
hX=>y
hX=^y
hXH<w
hXf<H
hYC<
h\fd9-
h\rm<hz
h\t<oi
h\vA<N
h_:~xr9b
ha<a
haH;
haI:
had the wrong value or the parameter IPAR(6) was altered by mistake outside of
had the wrong value or the parameter ipar[5] was altered by mistake outside of
hair:
hair_accel
hair_accel_mb
hair_builder
hair_builder_mb
hair_traverser
hair_traverser_mb
half edge generation = 
hbw_free
hbw_posix_memalign_psize
hc;!UR;8
hc;M
hc;d
hcL<8
hdG<
hdO;
hdp9
he8=
he:I2
hec<
hef;-
hfW;
hf\t;9
hg;L
hhj;
hi:Qa
hiK<
hj0;
hj;;6
hj;nj
hj;o
hjg;
hjz:
hk<;n
hk<n`
hl(<2xz
hl<N
hlbvh
hlbvh accelerator max batch size exceeded
hls:PW4
hm;d
hmE<
hmd:\v
hnD=
hnI:i
ho8#A
ho84
hp8<V
hp;P
hp<B
hpT;U
hpxb
hq<4U
hql=
hr;_1
hr>8x
hrd<O
hreset
hrtf
hrtfSettings
hrtfSettings->normType
hrtfSettings->sofaData
hrtfSettings->sofaDataSize
hrtfSettings->type
hrtfSettings->volume
hs5;
hs89r!
hs;X
hs>I
hsc<
hsz<e
ht:I
ht:y?
ht;%n
htk;j
hu<Y
hu=?lq
hugepages
hv<:6
hv=:W
hwQ;
hx6:
hxc=
hyz8^7B
i B=w5
i!"4i!"4i!"4i!"4
i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4
i#9u
i#F;y
i%4<j
i%L;2
i';ecu
i(N:t
i(i;u
i+S<c
i+i<U
i/7a
i058
i0:o
i0<0
i0<v
i0>E
i0X;
i1\n;fV8
i39;
i3H:#
i4<qD
i5:3
i6=\vs
i6w<
i7<B
i8;9
i8<U+
i8E3{
i8F=
i8U,';n
i8Z;I
i8m8@A
i93,0
i9@Z;
i9S~
i9Zl
i9\f9
i9f9C
i9lzM9
i:4v
i:5Z_
i:6B
i:Af
i:Bx
i:E(W
i:NO
i:OJ
i:PH
i:Q0
i:R5
i:RC
i:SC
i:Yoa:\t
i:\vzO
i:c6
i:ik
i:kJW
i:mr
i:pNt
i:vWh
i:wJ\t
i:ye
i;$Io
i;4oG
i;5M
i;Gy
i;Hz
i;Ku
i;LE
i;RlI
i;Un'
i;Vo
i;Vv3:
i;Z\j
i;fZ:
i;gV
i;ku4;iN9
i;m8
i;oi|:SnO
i;tu*
i<4;8
i<4x
i<7PX
i<8Q
i<8g
i<H5@
i<YP\n
i<ts
i<tyZ
i=5G
i=:tV
i=;yz
i=Cj
i=l9
i=uN\f
i>Bsa>
i>Uc
i>Vl
i>XGG
i?9A
i?<Bu-8
iA<p5?
iA=OQ
iAU;v
iBV1
iBo<
iC;i
iCZ;
iD2;v
iD:Rr
iDV=2
iE=0
iEI=
iFL;
iFf;<
iG=LF
iH;y
iH<QsO
iH|8
iI:bq
iK;7
iK;V
iK;i?
iK;n~];qe
iKW<
iM:_R
iM;$LQ
iMD<8
iMV<
iNd<
iOA9\t
iP495
iP;j
iR;r
iRN=
iS(<R
iS;1
iS;]n
iT;O
iTJ<
iTa;S1\t
iU;p
iUR:
iV8;
iV:4
iVr9*bn8
iW<W
iX9t
iXY;
iY:uM
iY<S
iZL;
i\BB
i\nA=C
i\r<e3R
ias<~
icG;
icO=
id8J
idH=
identifier
ie <GG,
ie:;w
ie<I
iesx
if scene index buffer is set, it has to have the same size as the transform buffer.
iface%x
ifx;
ig<Yh
iiD<
iia<
iix;T
ij>7
ikn=
il0<Yl;
il5;
il;0
ilj;S
ilp64
imZ=
impulseResponse
in instability of calculations.
in->data
in->data[iChannel][in->numSamples - 1]
in->numChannels
in->numSamples
inType
ina;
incorrect output filename: too long or empty
index
input matrix size is negative or zero.
input value set in DPAR(31) which might result
inputs
inputs are from different devices
inputs->baked
inputs->bakedDataIdentifier.endpointInfluence.center.x
inputs->bakedDataIdentifier.endpointInfluence.center.y
inputs->bakedDataIdentifier.endpointInfluence.center.z
inputs->bakedDataIdentifier.endpointInfluence.radius
inputs->bakedDataIdentifier.type
inputs->bakedDataIdentifier.variation
inputs->directFlags
inputs->enableValidation
inputs->findAlternatePaths
inputs->flags
inputs->hybridReverbOverlapPercent
inputs->hybridReverbTransitionTime
inputs->numOcclusionSamples
inputs->numTransmissionRays
inputs->occlusionRadius
inputs->occlusionType
inputs->pathingOrder
inputs->pathingProbes
inputs->reverbScale[iBand]
inputs->source.ahead.x
inputs->source.ahead.y
inputs->source.ahead.z
inputs->source.origin.x
inputs->source.origin.y
inputs->source.origin.z
inputs->source.right.x
inputs->source.right.y
inputs->source.right.z
inputs->source.up.x
inputs->source.up.y
inputs->source.up.z
inputs->visRadius
inputs->visRange
inputs->visThreshold
instance has only primitive 0.
instance_array
instance_cheap
instance_expensive
instanced scene or scene buffer not set.
instancedMesh
instancing_block_size
instancing_open_factor
instancing_open_max
instancing_open_max_depth
instancing_open_min
interleaveAudioBuffer
internal error in ISA selection for BVH4ColliderUserGeom
internal error in ISA selection for BVH4GridIntersector16HybridMoeller
internal error in ISA selection for BVH4GridIntersector16HybridPluecker
internal error in ISA selection for BVH4GridIntersector1Moeller
internal error in ISA selection for BVH4GridIntersector1Pluecker
internal error in ISA selection for BVH4GridIntersector4HybridMoeller
internal error in ISA selection for BVH4GridIntersector4HybridPluecker
internal error in ISA selection for BVH4GridIntersector8HybridMoeller
internal error in ISA selection for BVH4GridIntersector8HybridPluecker
internal error in ISA selection for BVH4GridMBIntersector16HybridMoeller
internal error in ISA selection for BVH4GridMBIntersector1Moeller
internal error in ISA selection for BVH4GridMBIntersector4HybridMoeller
internal error in ISA selection for BVH4GridMBIntersector8HybridMoeller
internal error in ISA selection for BVH4InstanceArrayIntersector1
internal error in ISA selection for BVH4InstanceArrayIntersector16Chunk
internal error in ISA selection for BVH4InstanceArrayIntersector4Chunk
internal error in ISA selection for BVH4InstanceArrayIntersector8Chunk
internal error in ISA selection for BVH4InstanceArrayMBIntersector1
internal error in ISA selection for BVH4InstanceArrayMBIntersector16Chunk
internal error in ISA selection for BVH4InstanceArrayMBIntersector4Chunk
internal error in ISA selection for BVH4InstanceArrayMBIntersector8Chunk
internal error in ISA selection for BVH4InstanceIntersector1
internal error in ISA selection for BVH4InstanceIntersector16Chunk
internal error in ISA selection for BVH4InstanceIntersector4Chunk
internal error in ISA selection for BVH4InstanceIntersector8Chunk
internal error in ISA selection for BVH4InstanceMBIntersector1
internal error in ISA selection for BVH4InstanceMBIntersector16Chunk
internal error in ISA selection for BVH4InstanceMBIntersector4Chunk
internal error in ISA selection for BVH4InstanceMBIntersector8Chunk
internal error in ISA selection for BVH4OBBVirtualCurveIntersector1
internal error in ISA selection for BVH4OBBVirtualCurveIntersector16Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersector16HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersector1MB
internal error in ISA selection for BVH4OBBVirtualCurveIntersector4Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersector4HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersector8Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersector8HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust1
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust16Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust16HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust1MB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust4Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust4HybridMB
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust8Hybrid
internal error in ISA selection for BVH4OBBVirtualCurveIntersectorRobust8HybridMB
internal error in ISA selection for BVH4Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector1Moeller
internal error in ISA selection for BVH4Quad4iIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH4Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector1Moeller
internal error in ISA selection for BVH4Quad4vIntersector1Pluecker
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH4Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH4SubdivPatch1Intersector1
internal error in ISA selection for BVH4SubdivPatch1Intersector16
internal error in ISA selection for BVH4SubdivPatch1Intersector4
internal error in ISA selection for BVH4SubdivPatch1Intersector8
internal error in ISA selection for BVH4SubdivPatch1MBIntersector1
internal error in ISA selection for BVH4SubdivPatch1MBIntersector16
internal error in ISA selection for BVH4SubdivPatch1MBIntersector4
internal error in ISA selection for BVH4SubdivPatch1MBIntersector8
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector1Moeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH4Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH4Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH4Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH4VirtualIntersector1
internal error in ISA selection for BVH4VirtualIntersector16Chunk
internal error in ISA selection for BVH4VirtualIntersector4Chunk
internal error in ISA selection for BVH4VirtualIntersector8Chunk
internal error in ISA selection for BVH4VirtualMBIntersector1
internal error in ISA selection for BVH4VirtualMBIntersector16Chunk
internal error in ISA selection for BVH4VirtualMBIntersector4Chunk
internal error in ISA selection for BVH4VirtualMBIntersector8Chunk
internal error in ISA selection for BVH8ColliderUserGeom
internal error in ISA selection for BVH8GridIntersector16HybridMoeller
internal error in ISA selection for BVH8GridIntersector16HybridPluecker
internal error in ISA selection for BVH8GridIntersector1Moeller
internal error in ISA selection for BVH8GridIntersector1Pluecker
internal error in ISA selection for BVH8GridIntersector4HybridMoeller
internal error in ISA selection for BVH8GridIntersector4HybridPluecker
internal error in ISA selection for BVH8GridIntersector8HybridMoeller
internal error in ISA selection for BVH8GridIntersector8HybridPluecker
internal error in ISA selection for BVH8GridMBIntersector1Moeller
internal error in ISA selection for BVH8InstanceArrayIntersector1
internal error in ISA selection for BVH8InstanceArrayIntersector16Chunk
internal error in ISA selection for BVH8InstanceArrayIntersector4Chunk
internal error in ISA selection for BVH8InstanceArrayIntersector8Chunk
internal error in ISA selection for BVH8InstanceArrayMBIntersector1
internal error in ISA selection for BVH8InstanceArrayMBIntersector16Chunk
internal error in ISA selection for BVH8InstanceArrayMBIntersector4Chunk
internal error in ISA selection for BVH8InstanceArrayMBIntersector8Chunk
internal error in ISA selection for BVH8InstanceIntersector1
internal error in ISA selection for BVH8InstanceIntersector16Chunk
internal error in ISA selection for BVH8InstanceIntersector4Chunk
internal error in ISA selection for BVH8InstanceIntersector8Chunk
internal error in ISA selection for BVH8InstanceMBIntersector1
internal error in ISA selection for BVH8InstanceMBIntersector16Chunk
internal error in ISA selection for BVH8InstanceMBIntersector4Chunk
internal error in ISA selection for BVH8InstanceMBIntersector8Chunk
internal error in ISA selection for BVH8OBBVirtualCurveIntersector1
internal error in ISA selection for BVH8OBBVirtualCurveIntersector16Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersector16HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersector1MB
internal error in ISA selection for BVH8OBBVirtualCurveIntersector4Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersector4HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersector8Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersector8HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust1
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust16Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust16HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust1MB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust4Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust4HybridMB
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust8Hybrid
internal error in ISA selection for BVH8OBBVirtualCurveIntersectorRobust8HybridMB
internal error in ISA selection for BVH8Quad4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector1Moeller
internal error in ISA selection for BVH8Quad4iIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector1Moeller
internal error in ISA selection for BVH8Quad4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector1Moeller
internal error in ISA selection for BVH8Quad4vIntersector1Pluecker
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoeller
internal error in ISA selection for BVH8Quad4vIntersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Quad4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector16HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector1Moeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector4HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4Intersector8HybridMoellerNoFilter
internal error in ISA selection for BVH8Triangle4iIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4iMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4iMBIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vIntersector1Woop
internal error in ISA selection for BVH8Triangle4vIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vIntersector8HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector16HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector1Moeller
internal error in ISA selection for BVH8Triangle4vMBIntersector1Pluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector4HybridPluecker
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridMoeller
internal error in ISA selection for BVH8Triangle4vMBIntersector8HybridPluecker
internal error in ISA selection for BVH8VirtualIntersector1
internal error in ISA selection for BVH8VirtualIntersector16Chunk
internal error in ISA selection for BVH8VirtualIntersector4Chunk
internal error in ISA selection for BVH8VirtualIntersector8Chunk
internal error in ISA selection for BVH8VirtualMBIntersector1
internal error in ISA selection for BVH8VirtualMBIntersector16Chunk
internal error in ISA selection for BVH8VirtualMBIntersector4Chunk
internal error in ISA selection for BVH8VirtualMBIntersector8Chunk
internal error in ISA selection for QBVH4Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH4Triangle4iIntersector1Pluecker
internal error in ISA selection for QBVH8Quad4iIntersector1Pluecker
internal error in ISA selection for QBVH8Triangle4Intersector1Moeller
internal error in ISA selection for QBVH8Triangle4iIntersector1Pluecker
internal_tasking_system 
internal_time_splits
intersection_filter 
intersector1  = 
intersector16 = 
intersector4  = 
intersector8  = 
invalid buffer data pointer type specified
invalid buffer slot
invalid buffer specified
invalid build quality
invalid destination pointer
invalid edge
invalid edge crease index buffer format
invalid edge crease weight buffer format
invalid face
invalid face buffer format
invalid flag buffer format
invalid geometry
invalid geometry ID
invalid geometry ID provided
invalid geometry type
invalid half edge
invalid hole buffer format
invalid index buffer format
invalid index buffer format. must be RTC_FORMAT_UINT.
invalid index buffer slot
invalid index buffer slot. must be 0
invalid index buffer slot. must be 0.
invalid level buffer format
invalid map<K, T> key
invalid matrix format
invalid normal buffer format
invalid normal buffer slot
invalid normal derivative buffer format
invalid normal derivative buffer slot
invalid string character 
invalid tangent buffer format
invalid tangent buffer slot
invalid timestep
invalid topology
invalid topology ID
invalid topology specified
invalid transform buffer format
invalid transform buffer slot
invalid vector subscript
invalid vertex attribute buffer format
invalid vertex attribute buffer slot
invalid vertex attribute specified
invalid vertex buffer format
invalid vertex buffer slot
invalid vertex crease index buffer format
invalid vertex crease weight buffer format
io:7
ioX>L
ipU|
ipl::HRTFMap::loadAmbisonicsHRIRs
ipl::HRTFMap::verifyDataHeader
iplAirAbsorptionCalculate
iplAmbisonicsBinauralEffectApply
iplAmbisonicsBinauralEffectCreate
iplAmbisonicsBinauralEffectGetTail
iplAmbisonicsBinauralEffectGetTailSize
iplAmbisonicsBinauralEffectRelease
iplAmbisonicsBinauralEffectReset
iplAmbisonicsBinauralEffectRetain
iplAmbisonicsDecodeEffectApply
iplAmbisonicsDecodeEffectCreate
iplAmbisonicsDecodeEffectGetTail
iplAmbisonicsDecodeEffectGetTailSize
iplAmbisonicsDecodeEffectRelease
iplAmbisonicsDecodeEffectReset
iplAmbisonicsDecodeEffectRetain
iplAmbisonicsEncodeEffectApply
iplAmbisonicsEncodeEffectCreate
iplAmbisonicsEncodeEffectGetTail
iplAmbisonicsEncodeEffectGetTailSize
iplAmbisonicsEncodeEffectRelease
iplAmbisonicsEncodeEffectReset
iplAmbisonicsEncodeEffectRetain
iplAmbisonicsPanningEffectApply
iplAmbisonicsPanningEffectCreate
iplAmbisonicsPanningEffectGetTail
iplAmbisonicsPanningEffectGetTailSize
iplAmbisonicsPanningEffectRelease
iplAmbisonicsPanningEffectReset
iplAmbisonicsPanningEffectRetain
iplAmbisonicsRotationEffectApply
iplAmbisonicsRotationEffectCreate
iplAmbisonicsRotationEffectGetTail
iplAmbisonicsRotationEffectGetTailSize
iplAmbisonicsRotationEffectRelease
iplAmbisonicsRotationEffectReset
iplAmbisonicsRotationEffectRetain
iplAudioBufferAllocate
iplAudioBufferConvertAmbisonics
iplAudioBufferDeinterleave
iplAudioBufferDownmix
iplAudioBufferFree
iplAudioBufferInterleave
iplAudioBufferMix
iplBinauralEffectApply
iplBinauralEffectCreate
iplBinauralEffectGetTail
iplBinauralEffectGetTailSize
iplBinauralEffectRelease
iplBinauralEffectReset
iplBinauralEffectRetain
iplCalculateRelativeDirection
iplCompressedEnergyFieldsBlendAndDecompress
iplCompressedEnergyFieldsCreate
iplCompressedEnergyFieldsCreateEmpty
iplCompressedEnergyFieldsCreateFromProbeBatch
iplCompressedEnergyFieldsGetCompressedData
iplCompressedEnergyFieldsGetDictionary
iplCompressedEnergyFieldsGetNumBands
iplCompressedEnergyFieldsGetNumBins
iplCompressedEnergyFieldsGetNumChannels
iplCompressedEnergyFieldsGetNumProbes
iplCompressedEnergyFieldsGetNumSingularValues
iplCompressedEnergyFieldsRelease
iplCompressedEnergyFieldsRetain
iplCompressedEnergyFieldsSetCompressedData
iplCompressedEnergyFieldsSetDictionary
iplContextCreate
iplContextRelease
iplContextRetain
iplContextSetProfilerContext
iplContextSetVariableBool
iplContextSetVariableFloat32
iplContextSetVariableInt32
iplContextSetVariableString
iplDirectEffectApply
iplDirectEffectCreate
iplDirectEffectGetTail
iplDirectEffectGetTailSize
iplDirectEffectRelease
iplDirectEffectReset
iplDirectEffectRetain
iplDirectivityCalculate
iplDistanceAttenuationCalculate
iplDistanceAttenuationGetCorrectionCurve
iplEmbreeDeviceCreate
iplEmbreeDeviceRelease
iplEmbreeDeviceRetain
iplEnergyFieldAdd
iplEnergyFieldCopy
iplEnergyFieldCreate
iplEnergyFieldGetBand
iplEnergyFieldGetChannel
iplEnergyFieldGetData
iplEnergyFieldGetNumBins
iplEnergyFieldGetNumChannels
iplEnergyFieldRelease
iplEnergyFieldReset
iplEnergyFieldRetain
iplEnergyFieldScale
iplEnergyFieldScaleAccum
iplEnergyFieldSwap
iplHRTFCreate
iplHRTFRelease
iplHRTFRetain
iplHybridReverbEffectApply
iplHybridReverbEffectCreate
iplHybridReverbEffectGetTail
iplHybridReverbEffectGetTailSize
iplHybridReverbEffectRelease
iplHybridReverbEffectReset
iplHybridReverbEffectRetain
iplHybridReverbEstimatorCreate
iplHybridReverbEstimatorEstimate
iplHybridReverbEstimatorRelease
iplHybridReverbEstimatorRetain
iplImpulseResponse2AddChannel
iplImpulseResponse2AddSample
iplImpulseResponse2Create
iplImpulseResponse2GetChannel
iplImpulseResponse2GetNumChannels
iplImpulseResponse2GetNumSamples
iplImpulseResponse2Release
iplImpulseResponse2Reset
iplImpulseResponse2Retain
iplImpulseResponse2SetChannel
iplImpulseResponse2SetChannelDelayed
iplImpulseResponse2SetSample
iplImpulseResponse2Swap
iplImpulseResponse2SwapSource
iplImpulseResponseAdd
iplImpulseResponseCopy
iplImpulseResponseCreate
iplImpulseResponseGetChannel
iplImpulseResponseGetData
iplImpulseResponseGetNumChannels
iplImpulseResponseGetNumSamples
iplImpulseResponseRelease
iplImpulseResponseReset
iplImpulseResponseRetain
iplImpulseResponseScale
iplImpulseResponseScaleAccum
iplImpulseResponseSwap
iplInstancedMeshAdd
iplInstancedMeshCreate
iplInstancedMeshRelease
iplInstancedMeshRemove
iplInstancedMeshRetain
iplInstancedMeshUpdateTransform
iplInterpolatableImpulseResponseBlend
iplInterpolatableImpulseResponseCreate
iplInterpolatableImpulseResponseGetChannel
iplInterpolatableImpulseResponseRelease
iplInterpolatableImpulseResponseReset
iplInterpolatableImpulseResponseRetain
iplInterpolatableImpulseResponseSetChannel
iplOcclusionSimulatorCreate
iplOcclusionSimulatorRelease
iplOcclusionSimulatorRetain
iplOcclusionSimulatorSimulate
iplOpenCLDeviceCreate
iplOpenCLDeviceCreateFromExisting
iplOpenCLDeviceListCreate
iplOpenCLDeviceListGetDeviceDesc
iplOpenCLDeviceListGetNumDevices
iplOpenCLDeviceListRelease
iplOpenCLDeviceListRetain
iplOpenCLDeviceRelease
iplOpenCLDeviceRetain
iplOverlapSaveFIRCopy
iplOverlapSaveFIRCreate
iplOverlapSaveFIRGetBlock
iplOverlapSaveFIRGetChannel
iplOverlapSaveFIRGetData
iplOverlapSaveFIRGetNumBlocks
iplOverlapSaveFIRGetNumChannels
iplOverlapSaveFIRGetNumSpectrumSamples
iplOverlapSaveFIRRelease
iplOverlapSaveFIRReset
iplOverlapSaveFIRRetain
iplOverlapSaveFIRSwap
iplPanningEffectApply
iplPanningEffectCreate
iplPanningEffectGetTail
iplPanningEffectGetTailSize
iplPanningEffectRelease
iplPanningEffectReset
iplPanningEffectRetain
iplPartitionerCreate
iplPartitionerPartition
iplPartitionerRelease
iplPartitionerRetain
iplPathBakerBake
iplPathBakerCancelBake
iplPathEffectApply
iplPathEffectCreate
iplPathEffectGetTail
iplPathEffectGetTailSize
iplPathEffectRelease
iplPathEffectReset
iplPathEffectRetain
iplPathSimulatorCreate
iplPathSimulatorRelease
iplPathSimulatorRetain
iplPathSimulatorSimulate
iplProbeArrayCreate
iplProbeArrayGenerateProbes
iplProbeArrayGetNumProbes
iplProbeArrayGetProbe
iplProbeArrayRelease
iplProbeArrayResize
iplProbeArrayRetain
iplProbeArraySetProbe
iplProbeBatchAddProbe
iplProbeBatchAddProbeArray
iplProbeBatchAddProbeArrayAndCluster
iplProbeBatchCommit
iplProbeBatchCompress
iplProbeBatchCreate
iplProbeBatchCreateCompressed
iplProbeBatchCreateNonUniform
iplProbeBatchGetDataSize
iplProbeBatchGetEnergyField
iplProbeBatchGetInfluencingProbes
iplProbeBatchGetNumProbes
iplProbeBatchGetProbe
iplProbeBatchGetProbeArray
iplProbeBatchGetReverb
iplProbeBatchLoad
iplProbeBatchLoadCompressed
iplProbeBatchLoadNonUniform
iplProbeBatchLookupBakedReflections
iplProbeBatchLookupCreate
iplProbeBatchLookupRelease
iplProbeBatchLookupRetain
iplProbeBatchRelease
iplProbeBatchRemoveData
iplProbeBatchRemoveProbe
iplProbeBatchRetain
iplProbeBatchSave
iplProbeBatchUpdateEndpoint
iplProbeBatchUpdateProbePosition
iplProbeBatchUpdateProbeRadius
iplProbeClusterMapCreate
iplProbeClusterMapGetData
iplProbeClusterMapLookup
iplProbeClusterMapRelease
iplProbeClusterMapRemapNeighborhood
iplProbeClusterMapRetain
iplProbeNeighborhoodCalculateWeights
iplProbeNeighborhoodCheckOcclusion
iplProbeNeighborhoodCreate
iplProbeNeighborhoodFindNearest
iplProbeNeighborhoodGetNumProbes
iplProbeNeighborhoodGetNumValidProbes
iplProbeNeighborhoodGetProbe
iplProbeNeighborhoodGetProbeBatch
iplProbeNeighborhoodGetProbeIndex
iplProbeNeighborhoodRelease
iplProbeNeighborhoodReset
iplProbeNeighborhoodResize
iplProbeNeighborhoodRetain
iplProbeNeighborhoodSetProbeBatch
iplProbeNeighborhoodSetProbeIndex
iplRadeonRaysDeviceCreate
iplRadeonRaysDeviceRelease
iplRadeonRaysDeviceRetain
iplReconstructorCreate
iplReconstructorReconstruct
iplReconstructorRelease
iplReconstructorRetain
iplReflectionEffectApply
iplReflectionEffectCreate
iplReflectionEffectGetTail
iplReflectionEffectGetTailSize
iplReflectionEffectRelease
iplReflectionEffectReset
iplReflectionEffectRetain
iplReflectionMixerApply
iplReflectionMixerCreate
iplReflectionMixerRelease
iplReflectionMixerReset
iplReflectionMixerRetain
iplReflectionSimulatorCreate
iplReflectionSimulatorRelease
iplReflectionSimulatorRetain
iplReflectionSimulatorSimulate
iplReflectionsBakerBake
iplReflectionsBakerCancelBake
iplReflectionsEffect2Apply
iplReflectionsEffect2Create
iplReflectionsEffect2GetFloat
iplReflectionsEffect2GetInt32
iplReflectionsEffect2Release
iplReflectionsEffect2Reset
iplReflectionsEffect2Retain
iplReflectionsEffect2SetBuffer
iplReflectionsEffect2SetFloat
iplReflectionsEffect2SetInt32
iplReflectionsPartitioner2AddTask
iplReflectionsPartitioner2Commit
iplReflectionsPartitioner2Create
iplReflectionsPartitioner2Release
iplReflectionsPartitioner2RemoveTask
iplReflectionsPartitioner2Retain
iplReflectionsPartitioner2RunTasks
iplReverbEstimatorApplyScale
iplReverbEstimatorCreate
iplReverbEstimatorEstimate
iplReverbEstimatorRelease
iplReverbEstimatorRetain
iplSceneCommit
iplSceneCreate
iplSceneLoad
iplSceneRelease
iplSceneRetain
iplSceneSave
iplSceneSaveOBJ
iplSerializedObjectCreate
iplSerializedObjectGetData
iplSerializedObjectGetSize
iplSerializedObjectRelease
iplSerializedObjectRetain
iplSimulatorAddProbeBatch
iplSimulatorCommit
iplSimulatorCreate
iplSimulatorRelease
iplSimulatorRemoveProbeBatch
iplSimulatorRetain
iplSimulatorRunDirect
iplSimulatorRunPathing
iplSimulatorRunPathingForNeighborhoods
iplSimulatorRunPathingPerSource
iplSimulatorRunPathingPerSourceForNeighborhood
iplSimulatorRunReflections
iplSimulatorSetScene
iplSimulatorSetSharedInputs
iplSourceAdd
iplSourceCreate
iplSourceGetOutputs
iplSourceGetOutputsAux
iplSourceRelease
iplSourceRemove
iplSourceRetain
iplSourceSetInputs
iplStaticMeshAdd
iplStaticMeshCreate
iplStaticMeshLoad
iplStaticMeshRelease
iplStaticMeshRemove
iplStaticMeshRetain
iplStaticMeshSave
iplTrueAudioNextDeviceCreate
iplTrueAudioNextDeviceRelease
iplTrueAudioNextDeviceRetain
iplVirtualSurroundEffectApply
iplVirtualSurroundEffectCreate
iplVirtualSurroundEffectGetTail
iplVirtualSurroundEffectGetTailSize
iplVirtualSurroundEffectRelease
iplVirtualSurroundEffectReset
iplVirtualSurroundEffectRetain
ir":r
ir4;D\?
ir:I
ir;B
ir<B
irD:Y
irUpdateQueue
is out of admissible interval [0,infinity). Assigning DPAR(8)=%e
is;2G
is=\vH
iterations automatically.
iuL<*
iw;a
iwI;
ix2+
ix;h58
iy0=*{u
iy;Iy
j :f5
j o9
j"j(j.z0%
j%;U7
j)l7
j+<Ke
j,r8
j09(_
j0;x
j0;zh
j0=n
j0V=
j0d;
j1;m
j1<hN
j1X;
j2<y
j3;D
j3;P
j3K:
j3X<
j49;
j4[=z
j5:H#
j5;W
j5O;
j6;J
j6D=
j6o;*
j7G<Z
j7w:Y
j8;T
j8D]
j8L;x-
j8U;
j8b3M:.}
j8g;
j9"g
j9%<b
j9:jId:
j9;z
j9D):
j9Hu
j9ZE
j9n.
j9tH
j9~ry
j:57
j:LM
j:Urd
j:dB 
j:l6
j:mN
j:nsr:{
j:tj)
j:vi4
j:wS
j;2<a
j;3LV
j;NX
j;R2
j;SU
j;Vgk
j;Xq
j;YSc:
j;\fB1
j;a5M
j;hr
j;jp
j;mm19h2u;z
j;nYB<D
j;o3m
j;ouc
j;wN
j;xT
j<A9
j<OwW
j<PE
j<W;a
j<\tuH
j<gO
j<hln;
j<l1*
j=UWi
j=V$A
j=h=J
j=ko
j=q:w
j=w<y
j>CK
j>Kle
j?\fKk?X
j@<IT
jA;n
jA<d
jAE;\n
jAr:
jB:kZx
jB:v
jB;H
jB<C
jB>ez
jBT<
jBa;
jC:X
jD5;Hp,
jD<3eW
jE3<4
jE9c
jEx:
jEz;b
jF;YE
jGc<
jH:<QT
jH<r6v;K
jJ0>o4
jK<8kc=%
jKz=
jLE;
jM9P
jM;CK
jNb=
jO;GA?
jO<}j
jP<2
jP]9
jQ:D-
jQ:X&9;
jQ<G
jQr9
jT7l
jTD:
jTK;5
jU)9`9
jU:u%
jV2;
jY;E
jY\n<x
jYj;=
jZS9
j[9f
j[:R9
j[\vRT
j\:yZ
j\n9R
j\t:0u
j\t<A6
j\v9g'
j]J<K
j_;yT
j`4<EV
j`M;1
jb9"i
jb<9
jbB;
jbv9N
jbz;
je;F7
jex<
jf93A5
jf=u
jg;Z
jg<h
jh;5
jhI=
jj;s
jji;
jk<|7
jl93z
jl]<S
jm%<nv
jm<Bs
jmE; 
joC:H7
joL<ha
jp:x
jq:b
jq:y
jq;U\
jr<4
jrG;&s
jsP;
jt:V+
jt;a2
juD;BK5
jut;\n
jv;r_
jv<{X
jw:0
jwG;\r
jwx:c
jx<0
jxD<,
jy:VK:;
jy;g
jy=H
jy];y
jz:UI
jz>&3
k#;FC
k#>te
k#T8:
k$l9\8
k'J97
k*<G5
k*n;P
k,=LAZ
k,e:EG1
k.2:x_O
k.5;I
k/?TW
k0:y
k0;b8
k1;qP6
k28u
k2<8
k3;D
k3<X
k3<w
k46=
k4:t
k4B>
k52<
k53<HC
k5<s<
k6>OF
k6A;\x
k6CK
k6t#c
k75=
k7Z:
k80qA;
k9*;4
k90'x
k99%
k9=J
k9?A
k9kL
k9{(b
k9{j
k:;3P0
k:B6
k:Bjg
k:Gi5
k:Pq
k:RQ
k:c4
k:cm3
k:ep
k:f7
k:kT
k;*rY
k;/Ef
k;A5\f
k;DM
k;FLO;C
k;K#H
k;Lnm;\a
k;O0
k;VH
k;\trB
k;aJ
k;al
k;bL
k;ef
k;k-J
k;rM
k;yOf
k<*b2
k<9cXN
k<F&Y
k<It6
k<Kd]
k<Pq
k<Qi
k<Qs)
k<Z9k
k<Zz6
k<\tyr
k<hM
k=Dp
k=N)X
k=Ql
k=`It
k=mmi
k=q1
k=wMO
k=zA
k>,Bd
k>Gb
k>pzf>M
kA?f&
kB;;d
kB<qe
kBz9
kC6;@
kC;N[
kD69d
kD8<L
kD=Y
kDV;
kDn;
kE{;Kx
kF;}j
kFi<
kH;2
kI:Q`
kI:o!
kI<Al
kI<T
kJ2;
kJ8VX
kJ9*X
kJr:
kKM;
kL:mw
kL<9mK
kL=y
kM9k
kM=D
kO<g\v
kP<HI <4jv
kP[<g
kQ:5
kQ:pF
kQi<
kQr;H
kR9;N#
kR;w
kRZ;
kRi;\n
kS;l
kS;x
kSl9
kT!;>DZ
kT;f
kT{9
kU4;y
kV9h
kV>Zf
kVe<-
kW;I
kWD;
kX:4F
kY;i
kY<g
kZ:*X
kZ:D
kZ;Z}H
kZ<2"N
kZT=
kZa<jq
k^r;F
ka;8
ka;Z
ka;j
kaw;Ff
kb:Y
kb:cD!
kb<X
kc19
kc8<
kc:dE
kcP;
kcQ:
kcb8
kd<K
kd>v
ke:Oc
ke@<uM
keJ;
kf:9
kf:z
kf<8B
kfH;B]z
kg=<Z
kg?1
kh;yua;d
kjG=H
kk:u
kl\t<TpC
kn;K
kn;TB
knB:
koR=
kpn;
kr;e
kr=rH
krU9\vU
ks3<
kt9ak
kt;I
ku3<
ku<i
kuG:
kv2:
kv;N
kw<m
kwv;
kyR;
kyX:\v
ky\r9E
kyq;]8
kyt9\t
kz:B
kz;V
kzS<
l!s;9p
l":gL
l$E;I
l.;Uh
l0=h{D
l0a9
l1"B
l15;RJ
l1=zl
l1K;
l27<
l3=Q
l4;0h
l4d;
l4i>
l598_r
l6N>A
l6X;W
l6w<H?
l7<dV
l8%9\tc
l8;A
l8=g
l8te-
l9&4
l97:
l9<RW;
l9<gn
l9=/d
l9I|\t
l9g'
l9ig
l9sm
l9s}3
l9u;.L
l9x9
l:.fQ
l:3E
l:Ht
l:M4
l:Ns2
l:R2
l:Xj
l:a[T
l:af
l:n3
l:nZ>:JzH:
l:sH
l:uj
l:xE
l;!h6
l;3q
l;6ZH
l;6e
l;;3D
l;FO
l;Mm
l;NU-
l;Vo
l;\fov
l;dz
l;e2
l;e8
l;fp
l<0=P
l<0n
l<2ND
l<3B
l<=hx
l<Bu!
l<Eg
l<Fe
l<H]Q
l<X94<
l<Zi
l<d0
l<h1
l<nca
l<w5
l<wC
l=1W
l=6X
l=BY
l=DB
l=LJ
l=a9
l=bk
l=by
l=cM
l=c\N
l=rf
l?O9
l@3=jX
lA5<
lA:'F
lB;u*
lBL:pj
lC|<v
lD5<P
lD;LH
lD;l
lDZ;
lE8o]Q
lF:T
lF;6
lFjQ
lG;h
lGH;
lGo<`m|
lH;4
lH;QS{9
lI2;
lJ9\t
lK=$39
lKS;
lL=L
lL=c
lLM:
lLg<3
lM8<
lM<*e
lM<U
lNs:E7
lNv:
lO5;"S
lO:V
lO:n
lO<)F
lOI<f
lP=t
lQ:#U
lQ:4
lQ:V
lR);ce
lR3;
lR;w
lRP;;
lRt:
lS7<
lSw<
lU:<Z
lV5>
lV;#f
lW?X
lWU<
lY>Z
lZ;8x
lZw<
l\f5;d'P
l\fx8
l\vP:7
l\vS9S7
l`h<b
l`s9
laC;
lb;E
lc0=
lf8<E>6
lf;L}
lg:4
lg;;T
lg;e
lg\v<DZO
lh:A
lhU;
li;4ZD
liV:V
liV;
line segments:
line4i
line_accel
line_accel_mb
line_builder
line_builder_mb
line_traverser
line_traverser_mb
list<T> too long
listTanDevicesAndCaps
listener.x
listener.y
listener.z
listenerAhead.x
listenerAhead.y
listenerAhead.z
listenerPosition.x
listenerPosition.y
listenerPosition.z
listenerUp.x
listenerUp.y
listenerUp.z
ljs9
lk9(mP:
lk;6
lk;P
lk;U%
lk;\vj
lk;`s
lkh;
ll)8
ln;7M\r;
ln=0!
lnk=
lo:Mh
loadProbeBatch
loadScene
loadStaticMesh
lp64
lp;jx
lpn=
lqn<C
lr:U
lrV8
ls-9
ls;C(
ls<:B
lt#=s
ltD:|
ltZ<
lu;H
lv;u\rR
lw;0
lx8@
lx9y
lx:b
lx:u
lz"<R
lz;2@
lzcnt
l~;n25<
m 9e
m#<FI
m$:wS
m'=YYY
m(8?TT
m(;tU
m)A8
m+;VW
m+t;c
m,DC\n
m09!
m0`=y
m1O;
m1~;3
m37;
m3;S0
m3J;`
m49<
m4L;
m4|l"
m5=R.O
m69jlQ9B
m6:\tg
m6;]g
m6=FwK<
m6y;
m7;Q
m7;ka{
m8(^S80
m87\r\n
m8;3
m8<r
m8RDu;~d
m8aK
m8k<
m9 k
m9/n
m9;g
m9=E
m9D0
m9I}
m9S9|
m9Z`C
m9]2
m9q9
m:-5s
m:1X
m:DR
m:Kg
m:L+Y
m:Tk
m:UF=
m:V9
m:cG?;X#W
m:ir:
m:k|1
m:rF
m:yF
m;/oH
m;34P
m;4Ij;qi
m;53
m;5U
m;7]r
m;9h
m;;zmx:
m;Ad
m;Ax
m;D9
m;Dx
m;F|39
m;K>R
m;Km
m;LB3
m;N)L
m;Sk
m;T~H
m;ZB
m;\yE
m;dz
m;e5
m;eu
m;n;W
m;v=5
m;zO
m<'vy
m<(7W
m<4Kn
m<?Kl
m<CU
m<Ci
m<Ecq
m<OY%
m<YS
m<x?5
m=1J
m=1L
m?rx
m?x:o
mA<j
mAy;
mB;G\tH
mB;n
mCm9>
mCsk
mD2;z
mD6;
mEA;
mEM;
mF3:
mFL;
mG9h
mG;x
mH:u
mH; B
mI;g\U
mIB9
mJC`
mL2:
mL<A
mLK:a6t:
mLY<F:
mM=w
mME<'
mN?Cl
mNf;
mO8#
mO;kW
mO<`4
mP1;
mP;ds
mPD=I
mPo9"g
mQ:F
mQ<FYr
mRc=
mT2<
mT88
mT:I
mT;s\n
mTW;
mVb;@
mW4<
mW:K
mW<o+
mWB=B
mWi9g
mWx<#
mX=9\t)C
mY9p>o
mY;P
mY`:ry
mYy<
mZ:LQ
m[;1NJ
m\<oi
m\f;0f
m\fY8
m\nE<v
map/set<T> too long
matrix appears to be degenerate. The method probably had to be stopped at the
matrix column indexes are not in increasing order.
matrix has no diagonal in CSR format.
matrix has zero diagonal.
matrix size. Proceeding with the parameter equals
max_builder_isa
max_hrtf_normalization_volume_gain_db
max_isa
max_spatial_split_replications
max_triangles_per_leaf
maximally 256 floating point values can be interpolated per vertex
mbE;
md:jgt;
md^:E
me8<
me9#[
medium
memcpy_s: dest is NULL
memcpy_s: dmax exceeds max
memcpy_s: dmax is 0
memcpy_s: overlap undefined
memcpy_s: smax exceeds dmax
memcpy_s: smax is 0
memcpy_s: src is NULL
memkind_get_version
memmove_s: dest is null
memmove_s: dmax is 0
memmove_s: smax exceeds max
memmove_s: smax is 0
memmove_s: src is null
memory for inner temporary integer array of size N.
memory monitor forced termination
meter
method may fail to converge.
mfO;q
mg<;z
mge:p
mi8L
mi9L
mi<78f
min-width feature is not enabled
mix->data
mix->data[iChannel][mix->numSamples - 1]
mix->numChannels
mix->numSamples
mixAudioBuffer
mixer
mj2;
mk<H,
mkl_avx2.2.dll
mkl_avx512.2.dll
mkl_def.2.dll
mkl_mc3.2.dll
mkl_msg.dll
mkl_somatcopy
mkl_vml_avx2.2.dll
mkl_vml_avx512.2.dll
mkl_vml_cmpt.2.dll
mkl_vml_def.2.dll
mkl_vml_mc3.2.dll
mlO;!
mm=B
mma8Q
mmf;
mn:"p
mn;t
mn<U,
mnX:G
mn];A
mo;E
model->callback
model->coefficients
model->coefficients[iArray]
model->dipolePower
model->dipoleWeight
model->dirty
model->minDistance
model->type
morton
motion blur grids:
motion blur hair:
motion blur line segments:
motion blur quads:
motion blur triangles:
movbe
movdir64b
movdiri
mp:R
mp:b:
mp<u|
mpD:
mq:1kA:
mq:U
mqq;
mr;4i`<
ms4;
ms:W6x:
msM;W
msrlist
mt2;a
mt9\G
mtB;3
mtllib %s.mtl\n
muM:
mub=
must be not bigger than (%i),
must be not less than (%i),
mv1;
mv1<
mx;6
mx<C
mxS;
myV>D
mzK;
mz\;r
m}^7S
n,u;N
n.9u
n/C;7
n00;
n0;ew
n0<)w
n0t:e
n1>B/
n1S<
n1d:x
n26>
n2=m
n3;u
n4,;E
n4;N
n4;ZT
n4=E
n5;0
n6Z=
n7:nu
n7;FS
n7<C
n85#}
n8Xk
n8iW(
n8z^*
n9#hE
n98\r
n9L>
n9d!
n9w3
n:5y
n:D>b
n:Gs
n:Py
n:VT%;Z
n:X*V
n:ah
n:mD
n:m~a
n:rx
n;014
n;1i
n;6A
n;8Z
n;;9p
n;Gh
n;MW
n;RE
n;aO
n;ai
n;bc
n;g2
n;tN
n</N9
n<7f+
n<:ep
n<QP
n<QS]
n<aV
n<au
n<jN
n<nsV
n<z\P
n=9rD=
n=Zp
n=dKI
n=dO
n=e}Q>p
n>1Z
n>8u
n>J9H<
n>WWK
n>w3
n?0ho?s
nA>Spz
nB9I
nB;L
nB;P\r
nBCE
nC:Q
nC|<i
nD8)
nD;f
nD;p
nDZ8
nE9_5
nE?O
nEp;
nF;2
nGK;
nHJ;
nI)<Q
nI7;7W
nJ;D
nJ;n
nJv;
nK07
nK;x
nL9<
nL:X
nL;sC
nL<UT
nLF;
nM<2
nM<K
nN<y
nNB:1
nO<u
nOc;
nPs=
nQ :oV!
nQw;
nRy:
nS;E
nS;GP<
nS~:2
nT;9
nU:x&
nU;Ng
nUE:
nV9T
nVl<TJG
nWB;m
nWG;
nWQ<
nX;O
nX=\e
nY:I
nY>x
nYd<h
n[:O9d
n\t;bQ
n\vb<c
n]y=q
n^r;R4
n`q<D9Q
nb:d)
nbV<[
nbu;T,
nc9i
nc9~
nc:z
nc;o
nc<z
ncBg
nd1;,A
nd8<D1
ndA;
ne;=wgU
ne;n
newmtl material_%d\n
nft;
ng92
ni/=4M"
ni9Iw
niV;d
nj:L
nj<u
njG:
nk29
nk:t
nk=e
nkq<
nn:q_
nn;4
nn=<AI
nnc;,
nnf;
no.;0
noJ;1
no_;M
not be equal to 0.0 at this stage. Either the user had to stop the method as it
not stopped when it found the solution. The solution may be wrong.
not supported node type in bvh_statistics
np:C(
npJ:4#
nq<l
nqX:
nr<UV'
ns:>Z
ns<K
nsT9
nso;
nt91b\f:
nt<N
nuH<
numBilinearFaces = 
numChannels
numComplexFaces 
numFaces = 
numInputs
numIrregularQuadFaces 
numRegularQuadFaces = 
numSamples
number of iterations is equal to IPAR(5)-IPAR(4).
number of time steps is out of range
nv9f
nv<8
nvL<D
nw:E(
nw;t@
nw<^Z
nx9<
nx:V"3
ny5;I
nz;Q
nz;v
nzl;
o ;G3
o!:5V
o";zc
o"j=9
o#r;5C
o$9X
o(;jS
o(?X5
o):8tR
o*=Ut
o,:ww
o-q=3j
o0:X
o0;B<
o0;D
o0;{Q
o0<o
o1;t
o2;ht7
o2;z:
o2<Hf
o2R<e
o2h>\r
o3:D,
o3;3
o3;W
o78I#
o7:n>L:F
o7;i
o7V;
o89b
o8;Uh
o8F=
o8I{
o99v
o9<V
o9>E
o9?PI:
o9E|
o9T;)
o9Xu%
o9YL
o9Z'
o9\nA
o9\t\s
o9m9
o9pe
o9vI!9
o9~c
o:6H
o:FyM
o:MI
o:P5
o:VV
o:Y|6
o:b7
o:bgx
o:du
o:gI
o:mG
o:n5*
o:ug
o; IQ
o;2'D
o;7 X9
o;8D
o;AF
o;BU$
o;D2
o;H1Z
o;IA
o;IB0
o;So4<
o;V}w
o;Xx
o;ZV\r
o;fF
o;mf
o;uc
o;|iC
o<0C
o<0b
o<8:P
o<BDY
o<Vi
o<Xa 
o<m7
o<uE0
o<uO
o=2F
o=Cv
o=Fd
o=J>d
o=TW
o=d5
o=di
o=pe
o=}qL
o><z9
o>J2
o>s;Z
o@e:z4
oA<I~
oB:6
oB;7
oBF9I
oC;@cB
oEb;CK
oFi;
oG=_t
oH:UN
oH;L
oHC=
oI;ef
oJ2<
oJ;I
oKD7
oKF;%
oKw7
oL<l0
oM:o8
oN1<
oN4<
oO*9
oO<pE
oOp;
oOs;
oQ1>
oQ;Bs
oQ;k
oQy;
oRl<
oU<A(
oU<l
oV<o6o;
oV<z
oVr9
oW:M
oW\9
oW\<n
oW\v<kD
oX;s
oX;z
oXg;
oX}:C
oYU>
oZ:6
oZb:
oZs=s_d
o\f7S
o\f:aY
o\f;Wtv8
o\te:xD
o\v:BQ
o`2<d
o`=Ea
o`U<R
oa<X
ob9)f
obL:
object
object_accel
object_accel:
object_accel_max_leaf_size
object_accel_mb
object_accel_mb:
object_accel_mb_max_leaf_size
object_accel_mb_min_leaf_size
object_accel_min_leaf_size
object_builder
object_builder_mb
obz:
ocE=
od ;S
od-;k
oe<(H
of iterations is equal to IPAR(5)-IPAR(4).
of the matrix is negative or zero.
ofO<
og:;d
ogX;
ogy;j
oi<t
oj<WD
oj>OP=
oj?;78
ol=N
ole;
om;Jd
oo:v
ooY:
ooc_cfg_file_name  got by Env=%s
ooc_cfg_path       got by Env=%s
ooc_keep_file      got by Env=%d
ooc_keep_file     got from config file=%d
ooc_max_core_size  got by Env=%d
ooc_max_core_size got from config file=%d
ooc_max_swap_size got by Env=%d
ooc_max_swap_size got by Env=%lli
ooc_max_swap_size got from config file=%d
ooc_path           got by Env=%s
ooc_path          got from config file=%s
oow=
operation not supported for this geometry
operation only allowed for user geometries
opy<
oq;Z
or criterion is very restrictive. CG method has been stopped.
or the parameter DPAR(1) was altered by mistake outside of
or the parameter IPAR(1)=%s was altered by mistake outside of the
or the parameter SPAR(1) was altered by mistake outside of
or the parameter dpar[0] was altered by mistake outside of
or the parameter ipar[0]=%s was altered by mistake outside of the
or the parameter spar[0] was altered by mistake outside of
or9:
or:a
or>P>M
oriented_bezier_curve
oriented_bspline_curve
oriented_catmull_rom_curve
oriented_disc
oriented_hermite_curve
oriented_linear_curve
os<"4
ot:Kh#
otJ<(
other
ou;R
ou;d%w
out of memory
out->data
out->data[iChannel][out->numSamples - 1]
out->numChannels
out->numSamples
outType
outputs
outside of the routine, or the wrong value was assigned to the parameter 'np'
outside of the routine, or the wrong value was assigned to the parameter 'nt'
outside of the routine, or the wrong value was assigned to the parameter 'nx'
outside of the routine, or the wrong value was assigned to the parameter 'ny'
outside of the routine, or the wrong value was assigned to the parameter 'nz'
owV;
owq:Bsb:)
ox;g#
oxG<
oy=If
oyW:
oz;i
ozu;
o|:zJC:
o}g9
o~k;S
o~t<z
p!u;w;K
p&U9
p'<9T
p(8E
p):IT
p+p;V
p,:7U
p.;mS
p/1<g
p/C<Dn
p0m;
p1'9
p20W
p2F:5
p2\9U
p2f<
p32;
p3;zd
p3L:B`@
p3Q=
p4:D
p4;U
p4<RS
p4f>7
p5U;
p6=,z
p6B=
p6N$i
p7=Pi
p7M}
p7M}f
p7N<Bw
p7s=
p8)=R
p84:@
p87O
p8S&
p8W+B;
p8f;B
p8l;q
p8mk
p8pO
p9Ky&
p9O;]
p9OBc;
p9W"
p9]O
p9l@
p:WB
p:ZX
p:a"z
p:aa
p:h4
p:i9B;4
p:ty
p:va
p;'55
p;)K1
p;45
p;5qm;,
p;5xY
p;6v
p;=0p
p;=l5
p;B7
p;BB
p;F4/
p;FpR:
p;LFS;
p;M7J
p;N9-
p;Q0
p;Sj\f
p;VX
p;Vh
p;ak
p;e8i;@
p;gq
p;nf4
p;pP(
p;zr
p<0B
p<1Q
p<3Y1
p<JPo
p<Lq
p<\tTY
p<gX
p<jaR
p<m8?
p=4S#
p=BAr=
p=Ey
p=ax
p=eaj;
p=gL
p=qN
p>8MdF
p>9p
p>BQ\f
p>jN
p?:iw
p?D9
p@6:U
pA:sE|
pA<8v
pA=\nf
pA>D
pA\n=T
pBXchB$
pBa<
pBq<"
pC<9{
pC<r
pC=qM
pCH:
pD:6
pFE;:
pG9;Dw
pG:B
pG:P
pG<V/
pGA:CH
pGA;/
pGY;
pH89
pI:T
pIB"
pIBHD
pJN<\
pM9{
pMF;s
pN9;
pN9<
pNo;
pO68C
pO;E
pOE=e
pOd=
pP<K
pP<m"
pQ9-
pR:5
pR:h
pUF9
pW;u
pW;y
pWW9\v
pXa;7
pY8%
pY>GTr=
pYL;
pYN<
pZ;z
pZu=
p[:I54:
p\f9>s
p\f<TyQ
p\rP\f0!p
p\tL<dd
p]:ql
p^<DGn
pa;CT&
parameter 'BCTYPE' was not in the admissible range {D,N,P} during initialization stage.
parameter 'BCtype' was not in the admissible range {D,N,P} during initialization stage.
parameter DPAR(1)=%e. The sine transform may be unsuitable for
parameter DPAR(1)=%e. The staggered cosine transform may be
parameter DPAR(1)=%e. The staggered sine transform may be
parameter SPAR(1)=%e. The SINE TRANSFORM may be unsuitable for
parameter SPAR(1)=%e. The sine transform may be unsuitable for
parameter SPAR(1)=%e. The staggered cosine transform may be
parameter SPAR(1)=%e. The staggered sine transform may be
parameter dpar[0]=%e. The sine transform may be unsuitable for
parameter dpar[0]=%e. The staggered cosine transform may be
parameter dpar[0]=%e. The staggered sine transform may be
parameter spar[0]=%e. The sine transform may be unsuitable for
parameter spar[0]=%e. The staggered cosine transform may be
parameter spar[0]=%e. The staggered sine transform may be
params
params->airAbsorption[iBand]
params->bakeBatchSize
params->bakeFlags
params->binaural
params->delay
params->direction.x
params->direction.y
params->direction.z
params->directivity
params->distanceAttenuation
params->eqCoeffs[iBand]
params->eq[iBand]
params->flags
params->height
params->hrtf
params->identifier.endpointInfluence.center.x
params->identifier.endpointInfluence.center.y
params->identifier.endpointInfluence.center.z
params->identifier.endpointInfluence.radius
params->identifier.type
params->identifier.variation
params->interpolation
params->ir
params->irSize
params->irradianceMinDistance
params->listener.ahead.x
params->listener.ahead.y
params->listener.ahead.z
params->listener.origin.x
params->listener.origin.y
params->listener.origin.z
params->listener.right.x
params->listener.right.y
params->listener.right.z
params->listener.up.x
params->listener.up.y
params->listener.up.z
params->numBounces
params->numChannels
params->numDiffuseSamples
params->numRays
params->numSamples
params->numThreads
params->occlusion
params->openCLDevice
params->order
params->orientation.ahead.x
params->orientation.ahead.y
params->orientation.ahead.z
params->orientation.origin.x
params->orientation.origin.y
params->orientation.origin.z
params->orientation.right.x
params->orientation.right.y
params->orientation.right.z
params->orientation.up.x
params->orientation.up.y
params->orientation.up.z
params->pathRange
params->probeBatch
params->radeonRaysDevice
params->radius
params->rayBatchSize
params->reverbTimes[iBand]
params->savedDuration
params->scene
params->sceneType
params->shCoeffs[iCoeff]
params->simulatedDuration
params->spacing
params->spatialBlend
params->tanDevice
params->tanSlot
params->threshold
params->transform.elements[iRow][iColumn]
params->transmissionType
params->transmission[iBand]
params->type
params->visRange
pardiso_read_ooc_file: Fseek error
pardiso_read_ooc_file: Read error
pardiso_write_ooc_file: Write error
pardiso_write_ooc_file: nfirst is EOF
pbk;
pbndkb
pc(;4
pc=i9#=
pclmul
pconfig
pd^=R
pf:6K/
pgL:vt
pg\n?pg\n
ph9/
ph9;E
ph:t4-;c
ph<'c
phn:
phonon.dll
pjX;
pk9e\V
pk;{ZR
pkD9`
pkS<k
pl7|\f
pl;V
pmO;
pmT;
pma<
pmg;xz?9}
pm|<x
pn9II0:SfR9Z
pn<d
pnD<
pno=
poh=qO
popcnt
powf
pq;B
pq;b
pq>h
pr ;U
pr;L
prefetchi
preordering failed (matrix types 11, 13 only)
presplits
previous iteration. The solution may be wrong.
probe.center.x
probe.center.y
probe.center.z
probe.radius
probeArray
probeBatch
probeIndex
problems with opening OOC temporary files
profilerContext
progress monitor forced termination
ps8^
ptwrite
pug:P
pv.9
pv;bg
pw<dqs
pye<
pz0W
p|:ZQ
p}2<\jD
q!<Ti
q!O:B
q!c;BF~
q"Y9}
q'h96_
q)9wa";
q);rM
q*D;S
q+:3M
q,;55
q-Z<L
q08\fW
q0;8
q0<4
q1Z:
q1h<
q2';m26:D2J;%
q2;9
q3:ee
q3h;r@
q45<
q4;f)
q5;*a
q5<k
q7:v
q7HP
q8"`n
q8,PF;
q8</2
q9#6
q9*N
q99R
q9:w8;;Q
q9<99
q9=J
q9>4d
q9Ub
q9c0
q9d>W9>/
q9l\t
q9xO
q:5C
q:9I\t;8V
q:D\v9
q:Ge
q:LN
q:Rj\r;Gt5:
q:TW
q:Vi
q:WV
q:fb5
q:fy
q:i<j
q:we
q;07
q;0Tz;
q;39
q;5p
q;Ga
q;KF
q;Lc
q;SA
q;UF
q;V4
q;WF
q;XB*
q;ZN
q;\rUq
q;db
q;fh{
q;h1v;
q;hS
q;j2
q;vX
q<5s2
q<6MJ
q<Gq
q<TJ"=k4
q<Xp
q<h6
q<pk=
q<uS
q<yM\n
q=0d
q=9g
q=K\rB
q=wC
q=zP{
q@a:t
qB9/^o
qB;u
qB>kjg
qBi:
qC:'0
qCm=>
qCsk
qD3<
qD:/z
qD:ru
qD;%A
qF9_
qF;M
qF;X
qFx;
qG;t
qGJ8
qGS9w?z
qGx=
qH<9
qHB:
qI>p
qIz=
qJ<W%A
qJ=r
qL@<a
qM!9
qM<A
qMH<v
qMX:Jj
qOy;
qP:eA
qQ;<b
qQ;X
qQQ:*5
qQV<
qRG;Q!
qS<g
qSP<
qT2:
qT9K
qV;'M
qV;R
qVj>
qW<K^
qX:9
qY;B
qY<c
qZ:a
q\;qs
q\fs<8
q\r<J6
q\t;e7r
q\v9ci
q_9x
q_V9F
qb3<b
qb4;
qb9O
qbvh4.quad4i
qbvh4.triangle4i
qbvh8.quad4i
qbvh8.triangle4
qbvh8.triangle4i
qcK<
qdW:
qe-<L}g
qeB<FAE
qf:W^
qf;P
qfx;
qg9f{`
qg<s%w=
qgR:
qgY=EG
qgw=(
qh6;
qhR;
qhn8
qi9i
qi;u
qj:axY9l
qj;w
qjk;x
qjl<H
qk;d}
qm:;N
qm:e
qm:z
qm;Z8
qmZ>
qn.:L
qoo;
qot:
qox;
qp2:R
qp<J
qp=9
qq1;
qr95
qr<F
qrG<
qrU;
qr}9
qty:
qu;i
qu\f7
quad4i
quad4v
quad_accel
quad_accel_mb
quad_builder
quad_builder_mb
quad_traverser
quad_traverser_mb
quads
quads:
quo;
qv:s@
qw+=k5R
qw:K3
qw=G
qx7Q
qxs?qxs
qy"<3
qyb:O2
qz=r
qz=y
q{V<2
r'<Ms
r'=dB
r'=oL
r'X9|b
r(P;A
r.9pR\n
r/09
r09m
r27=
r2:g
r2<u4
r2=Iz
r2?3
r3:Y.
r3;l
r3=/i
r3>l`
r4:Y
r4>v
r5=;1
r6Q@h
r7:9
r7<}Z
r7N;
r8)O
r81f
r8<h
r8<wB
r8Q~
r8\=rd
r97/m
r9>H
r9E4
r9IT\v<
r9R;
r9VY
r9V`
r9`Rj
r9ij
r9j:t
r9uP
r:,Ul
r:51
r:6P
r:G1
r:Gu
r:Ms
r:PP
r:X}E7 
r:Yoa
r:ZW
r:\f;L94
r:eS
r:gom:fp
r:nid
r:zr
r;%CS
r;*KJ
r;0=MIA
r;4[V
r;9O
r;9P'
r;CD
r;GHM:
r;Im9
r;OVI
r;Rl8
r;WR
r;c9
r;e6
r;fS
r;m6
r;o+2
r;pBL<
r;tc
r;tv]
r;ui_
r<)AN
r<JU
r<K\vl
r<L9E
r<P5
r<Wb
r<Xd9
r<dK
r<hZ\v
r<kd"
r<mk
r=2uz=
r=;3Kh
r=]cP
r>$Kq
r>KQA>x
r>MB_
r>PTF
r>XK
r>oy
r>s1
rAv:
rB|;k
rC<a
rC>7
rD<vv
rDe95
rE:c
rEV;
rE\n;j
rF2<J
rF2<f\v
rF;x
rFG:{
rG;i
rG=:V
rGR;
rH*8
rI5<
rJ6:;
rJ>W
rJE<(
rL;c
rLG=
rLO:
rLg<qr
rMe;u\
rMx9v
rN49
rN;M
rP9I
rRP;
rR\;eV
rRf;c
rS58
rS;}2
rS=d
rSS;
rT1<3e
rT:b\r
rVA:
rW:zV
rX6:;z
rY9<b
rY:0
rY;C
rY<}S
rY>P/1
rYL<\fXC
rZ:K
rZD;R
rZe<
r[k8B
r\n$;T4t8_
r\n0\tP
r\t9,g0
r\t;rL
r\ta<1G:
r\vw<?hG
raB3G
rae:m2R;B
raoint
raymasks 
rb=6
rc3<
rc=A
rch9
rd-<8
rd:*7W
rde:
rdpid
rdrnd
rdseed
re";V
re;0w8
re>8R
read-write problems with the OOC data file
reconstruct
reconstructImpulseResponse
reconstructor
remove
removeData
removeProbe
removeProbeBatch
reorder
reordering problem
residual stopping test and the stopping test for the maximal number of
result
result.center.x
result.center.y
result.center.z
result.radius
result.x
result.y
result.z
resulting from this problem.
retain_uncompressed_reverb
reverbTimes
reverb_min_absorptive_gain
rf(8n
rg;c
rh;l
ri<8
ri<p
rj;J
rjQ9u3
rk=}S
rl<2
rmY:
ro:Pu
ro;L
roU;i
robust
round_bezier_curve
round_bspline_curve
round_catmull_rom_curve
round_hermite_curve
round_linear_curve
routine to work by setting IPAR(7)=0 before the call to this routine.
routine to work by setting ipar[6]=0 before the call to this routine.
routine was not called. Computations have stopped. The result may be incorrect.
routine, or DFGMRES_CHECK routine was not called. The solution may be wrong.
routine, or the user had to stop FGMRES method because it had converged.
routine, or the wrong values were assigned to parameters 'ap' and 'bp'
routine, or the wrong values were assigned to parameters 'at' and 'bt'
routine, or the wrong values were assigned to parameters 'ax' and 'bx'
routine, or the wrong values were assigned to parameters 'ay' and 'by'
routine, or the wrong values were assigned to parameters 'az' and 'bz'
routine, or the wrong values were assigned to the parameters 'ap' and 'bp'
routine, or the wrong values were assigned to the parameters 'at' and 'bt'
routine, or the wrong values were assigned to the parameters 'ax' and 'bx'
routine, or the wrong values were assigned to the parameters 'ay' and 'by'
routine, or the wrong values were assigned to the parameters 'az' and 'bz'
rp9x
rp:0
rpR;
rpb<2]
rq'84
rqK=
rqP;
rt:J9
rt:Z
rt<@n
rtcIntersect and rtcOccluded not enabled
rtcIntersect16 and rtcOccluded16 not enabled
rtcIntersect4 and rtcOccluded4 not enabled
rtcIntersect8 and rtcOccluded8 not enabled
rtcIntersectN and rtcOccludedN not enabled
ru6:2:
rucs
ru|<r
rw*<y
rx<]Im
rxt:3
ry6rcI
ry=4
ryD;
rz9\t
s#L<e
s%9"Ue:
s%O:bLE
s&9]C
s';w0
s'b;sy
s(9p
s/<eI
s/L9
s09K
s0C;yd
s1<C
s2);T
s24<
s3;yK
s3U9
s4:T
s56;4
s59=p}
s5;B
s5Q9
s6<k
s6R<
s6Y>5
s78:1
s7:K
s7D=
s7K"
s8=s
s9) 5
s9-o
s9:5
s9C[\n
s9\tj
s9xl
s:0fq
s:0xS
s:<Qm
s:A\nA
s:Ah
s:CV
s:DYa9
s:Ey
s:Ja)<K
s:Jt
s:Mk-
s:U<8
s:Vs
s:bV
s:hD$
s:jp
s:qD
s:r4
s;"fm
s;7L
s;7dE;
s;9Q
s;@s3
s;APQ
s;Ou
s;Q}9
s;Tx
s;ZKh
s;eG
s;fR
s;gY
s;ky
s;q6/
s;rYO<4
s;whk;
s;zJ
s<&7f
s<,Th
s<3j#
s<>Tb
s<Bx
s<DH
s<Im
s<M5
s<Qv
s<T#a
s<bd
s<crP
s<pG
s<r6
s=EN
s=xj
s>#GU
s>1e
s>35
s>Br
s>P=6z=
s?B;9
s?s9
s@49
s@=aa0
sA\n;X
sA\v<x
sB9;
sBZR
sBt:
sE95a
sE:t
sE<0
sE<4
sER90
sF9P2
sFFt
sFS<N
sGb<
sH;B
sH[<k
sI:59
sI><P
sIe:
sJ:v6&<
sJt<9\n
sK$<A
sK:K
sL86
sL:rq|
sL;20~<d
sL;v
sL<g
sM=j
sN:7
sP=Yw
sQ=1wU
sQM:
sT:h
sT`>y1
sVD:Q
sV\t<Ax
sXF;
sXX:*q
sY6=F
sYG;
s[&8k
s\nF;R5
s\v<gt
s\v<m1
s\vD88w)
s^=Hs
s_forward_trig_transform/s_backward_trig_transform routine.
s`3;Y
sa;L
sa;ld
saT;
sah_fast_spatial
sah_presplit
saveOBJ
sc9u
scaleAccum
scan_exclusive_int4
scan_exclusive_part_int4
scene
scene not committed
scene_flags
sdM;
se9;
selected scene intersector
serializedObject
set to default value (%i).
setInputs
setProfilerContext
setScene
setSharedInputs
set_affinity
settings
settings->anyHitCallback
settings->closestHitCallback
settings->data
settings->duration
settings->embreeDevice
settings->flags
settings->fractionCUsForIRUpdate
settings->frameSize
settings->freeCallback
settings->irSize
settings->materialIndices
settings->materialIndices[iTriangle]
settings->materials
settings->materials[iMaterial].absorption[iBand]
settings->materials[iMaterial].scattering
settings->materials[iMaterial].transmission[iBand]
settings->maxDuration
settings->maxNumOcclusionSamples
settings->maxNumRays
settings->maxNumSources
settings->maxOrder
settings->maxSources
settings->numCUsToReserve
settings->numDiffuseSamples
settings->numMaterials
settings->numThreads
settings->numTriangles
settings->numVertices
settings->numVisSamples
settings->openCLDevice
settings->order
settings->radeonRaysDevice
settings->rayBatchSize
settings->reflectionType
settings->requiresTAN
settings->samplingRate
settings->sceneType
settings->simdLevel
settings->subScene
settings->tanDevice
settings->transform.elements[iRow][iColumn]
settings->triangles
settings->triangles[iTriangle].indices[iTriangleVertex]
settings->type
settings->vertices
settings->vertices[iVertex].x
settings->vertices[iVertex].y
settings->vertices[iVertex].z
sf80x
sf95
sgs<"
sh9w3I::
sh;9
sha512
shadeAndBounce
sharedInputs
sharedInputs->duration
sharedInputs->irradianceMinDistance
sharedInputs->listener.ahead.x
sharedInputs->listener.ahead.y
sharedInputs->listener.ahead.z
sharedInputs->listener.origin.x
sharedInputs->listener.origin.y
sharedInputs->listener.origin.z
sharedInputs->listener.right.x
sharedInputs->listener.right.y
sharedInputs->listener.right.z
sharedInputs->listener.up.x
sharedInputs->listener.up.y
sharedInputs->listener.up.z
sharedInputs->numBounces
sharedInputs->numRays
sharedInputs->order
should be a positive integer. Parameter was probably altered by mistake
should be a positive integer. The parameter was probably altered by mistake
should be an even number. Assign a proper value to parameter 'np'
should be an even number. Assign a proper value to parameter 'nt'
should be an even number. Assign a proper value to parameter 'nx'
should be an even number. Assign a proper value to the parameter 'np'
should be an even number. Assign a proper value to the parameter 'nt'
should be an even number. Assign a proper value to the parameter 'nx'
should be divisible by 4. Assign a proper value to parameter 'nx'
should be divisible by 4. Assign a proper value to the parameter 'nx'
should be positive. Parameter was probably altered by mistake outside of the
should be positive. The parameter was probably altered by mistake outside of the
should not be equal to 0.0. The FGMRES method may fail to converge.
shstk
si)<ZO
simd128
simd256
simd512
simulator
sio<
sje<
sji;
sk8d
sk;]m
sl1;
slS;7
sn6<
sn;B
sn<2p
sn>f
snU;
snu<
soT<
solve
source
source.ahead.x
source.ahead.y
source.ahead.z
source.origin.x
source.origin.y
source.origin.z
source.right.x
source.right.y
source.right.z
source.up.x
source.up.y
source.up.z
source.x
source.y
source.z
sourcePosition.x
sourcePosition.y
sourcePosition.z
soy<1
sp8>d
sp;3
sphere
sphereOcclusion
spherical
sq:K
sr3=
sr8_
src->data
src->data[iChannel][src->numSamples - 1]
src->numChannels
src->numSamples
src[iArray]
sse2
sse2::BVH
sse2::BVH4ColliderUserGeom
sse2::BVH4InstanceArrayIntersector1
sse2::BVH4InstanceArrayIntersector4Chunk
sse2::BVH4InstanceArrayMBIntersector1
sse2::BVH4InstanceArrayMBIntersector4Chunk
sse2::BVH4InstanceIntersector1
sse2::BVH4InstanceIntersector4Chunk
sse2::BVH4InstanceMBIntersector1
sse2::BVH4InstanceMBIntersector4Chunk
sse2::BVH4OBBVirtualCurveIntersector1
sse2::BVH4OBBVirtualCurveIntersector1MB
sse2::BVH4OBBVirtualCurveIntersector4Hybrid
sse2::BVH4OBBVirtualCurveIntersector4HybridMB
sse2::BVH4OBBVirtualCurveIntersectorRobust1
sse2::BVH4OBBVirtualCurveIntersectorRobust1MB
sse2::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
sse2::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
sse2::BVH4Quad4iIntersector1Moeller
sse2::BVH4Quad4iIntersector1Pluecker
sse2::BVH4Quad4iIntersector4HybridMoeller
sse2::BVH4Quad4iIntersector4HybridPluecker
sse2::BVH4Quad4iMBIntersector1Moeller
sse2::BVH4Quad4iMBIntersector1Pluecker
sse2::BVH4Quad4iMBIntersector4HybridMoeller
sse2::BVH4Quad4iMBIntersector4HybridPluecker
sse2::BVH4Quad4vIntersector1Moeller
sse2::BVH4Quad4vIntersector1Pluecker
sse2::BVH4Quad4vIntersector4HybridMoeller
sse2::BVH4Quad4vIntersector4HybridMoellerNoFilter
sse2::BVH4Quad4vIntersector4HybridPluecker
sse2::BVH4SubdivPatch1Intersector1
sse2::BVH4SubdivPatch1Intersector4
sse2::BVH4SubdivPatch1MBIntersector1
sse2::BVH4SubdivPatch1MBIntersector4
sse2::BVH4Triangle4Intersector1Moeller
sse2::BVH4Triangle4Intersector4HybridMoeller
sse2::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse2::BVH4Triangle4iIntersector1Moeller
sse2::BVH4Triangle4iIntersector1Pluecker
sse2::BVH4Triangle4iIntersector4HybridMoeller
sse2::BVH4Triangle4iIntersector4HybridPluecker
sse2::BVH4Triangle4iMBIntersector1Moeller
sse2::BVH4Triangle4iMBIntersector1Pluecker
sse2::BVH4Triangle4iMBIntersector4HybridMoeller
sse2::BVH4Triangle4iMBIntersector4HybridPluecker
sse2::BVH4Triangle4vIntersector1Pluecker
sse2::BVH4Triangle4vIntersector4HybridPluecker
sse2::BVH4Triangle4vMBIntersector1Moeller
sse2::BVH4Triangle4vMBIntersector1Pluecker
sse2::BVH4Triangle4vMBIntersector4HybridMoeller
sse2::BVH4Triangle4vMBIntersector4HybridPluecker
sse2::QBVH
sse2::QBVH4Quad4iIntersector1Pluecker
sse2::QBVH4Triangle4iIntersector1Pluecker
sse3
sse4
sse4.1
sse4.2
sse41
sse42
sse42::BVH4InstanceArrayIntersector1
sse42::BVH4InstanceArrayIntersector4Chunk
sse42::BVH4InstanceArrayMBIntersector1
sse42::BVH4InstanceArrayMBIntersector4Chunk
sse42::BVH4InstanceIntersector1
sse42::BVH4InstanceIntersector4Chunk
sse42::BVH4InstanceMBIntersector1
sse42::BVH4InstanceMBIntersector4Chunk
sse42::BVH4OBBVirtualCurveIntersector1
sse42::BVH4OBBVirtualCurveIntersector1MB
sse42::BVH4OBBVirtualCurveIntersector4Hybrid
sse42::BVH4OBBVirtualCurveIntersector4HybridMB
sse42::BVH4OBBVirtualCurveIntersectorRobust1
sse42::BVH4OBBVirtualCurveIntersectorRobust1MB
sse42::BVH4OBBVirtualCurveIntersectorRobust4Hybrid
sse42::BVH4OBBVirtualCurveIntersectorRobust4HybridMB
sse42::BVH4Quad4iIntersector1Moeller
sse42::BVH4Quad4iIntersector1Pluecker
sse42::BVH4Quad4iIntersector4HybridMoeller
sse42::BVH4Quad4iIntersector4HybridPluecker
sse42::BVH4Quad4iMBIntersector1Moeller
sse42::BVH4Quad4iMBIntersector1Pluecker
sse42::BVH4Quad4iMBIntersector4HybridMoeller
sse42::BVH4Quad4iMBIntersector4HybridPluecker
sse42::BVH4Quad4vIntersector1Moeller
sse42::BVH4Quad4vIntersector1Pluecker
sse42::BVH4Quad4vIntersector4HybridMoeller
sse42::BVH4Quad4vIntersector4HybridMoellerNoFilter
sse42::BVH4Quad4vIntersector4HybridPluecker
sse42::BVH4SubdivPatch1Intersector1
sse42::BVH4SubdivPatch1Intersector4
sse42::BVH4SubdivPatch1MBIntersector1
sse42::BVH4SubdivPatch1MBIntersector4
sse42::BVH4Triangle4Intersector1Moeller
sse42::BVH4Triangle4Intersector4HybridMoeller
sse42::BVH4Triangle4Intersector4HybridMoellerNoFilter
sse42::BVH4Triangle4iIntersector1Moeller
sse42::BVH4Triangle4iIntersector1Pluecker
sse42::BVH4Triangle4iIntersector4HybridMoeller
sse42::BVH4Triangle4iIntersector4HybridPluecker
sse42::BVH4Triangle4iMBIntersector1Moeller
sse42::BVH4Triangle4iMBIntersector1Pluecker
sse42::BVH4Triangle4iMBIntersector4HybridMoeller
sse42::BVH4Triangle4iMBIntersector4HybridPluecker
sse42::BVH4Triangle4vIntersector1Pluecker
sse42::BVH4Triangle4vIntersector4HybridPluecker
sse42::BVH4Triangle4vMBIntersector1Moeller
sse42::BVH4Triangle4vMBIntersector1Pluecker
sse42::BVH4Triangle4vMBIntersector4HybridMoeller
sse42::BVH4Triangle4vMBIntersector4HybridPluecker
sse42::QBVH4Quad4iIntersector1Pluecker
sse42::QBVH4Triangle4iIntersector1Pluecker
ssse3
st3;
st:PM
st;6
startTime has to be smaller or equal to the endTime
start_threads
staticMesh
stp;}
stp<
stream buffer empty
stride of normal buffers have to be identical for each time step
stride of normal derivative buffers have to be identical for each time step
stride of tangent buffers have to be identical for each time step
stride of vertex buffers have to be identical for each time step
strncat_s: dest is null
strncat_s: dest unterminated
strncat_s: dmax exceeds max
strncat_s: dmax is 0
strncat_s: not enough space for src
strncat_s: overlapping objects
strncat_s: slen exceeds max
strncat_s: src is null
strncpy_s: dest is null
strncpy_s: dmax exceeds max
strncpy_s: dmax is 0
strncpy_s: not enough space for src
strncpy_s: overlapping objects
strncpy_s: slen exceeds max
strncpy_s: slen is zero
strncpy_s: src is null
strnlen_s: dmax exceeds max
strnlen_s: dmax is 0
structure singular or input/parameter problem (matrixtype 11,13)
subdiv_accel
subdiv_accel_mb
subdivision surfaces:
subdivpatch1
subdivs
subgrid
sue<
sv:V
sw@;E
swap
sx<Ll
sxP9
sy8^
symbolic (max): %d symbolic (permanent): %d
sy|:J
sz:v
szG>
s}s<j
t!I8
t'j=2\fB
t(9Z
t(:dIf
t(;uJ
t+z:X
t-:Hg
t.3:C
t.k:H9
t0;z
t0<Yi<<
t1:T=
t2P<
t2V<
t42<
t44;
t49<
t4=t
t54<
t5h;
t6>Y~
t6P=H\f
t78l
t8r<G+
t8tP
t8v;
t9#t
t95p
t97L
t9Cr
t9Oa0:
t:3%v
t:5J\t9
t:DR{
t:Nf
t:\7F;z
t:dS
t:gk
t:o7R
t:uEZ:
t;+Lr
t;HpR
t;IX
t;J479
t;LP
t;W{O
t;h9
t;j\v8
t;m;J
t;s*s
t;wLT
t<%fH
t<3lA=M
t<8f
t<Ju
t<K&m
t<K5=
t<aj\f
t<bY
t<i5
t<mA
t<uL
t<zOk
t<zTa9b"
t=ZsQ
t=\tgn
t=cl;=L
t=hU
t>Vm
t?BP
tA,<f
tA~:S
tB;Z
tC5:h
tC;b
tE=0
tE>z
tEo<-
tF6<
tFr;
tGs>
tH;\c
tH=r
tHG<
tJ:2
tL;!lD;
tLg:C{
tM99WC
tM;_X
tM;m>
tMF<TV
tM\f;F
tN:Kp
tNa;Y
tO;pi
tO=V
tP"8
tP9\v
tQ:q
tQ<T>
tQg;l<
tR2;y
tR<6u
tS;v
tSn;
tT:V05
tT;2
tT;M
tU:B
tV<Bv
tVC<
tWC:
tWn8
t[j;V
t\f;cfQ
t\fM:9
t\t;8z
t\t\v9a
t]9\tm
ta;e,F
taj<
task stack overflow
tbI<XO
tc;w
te;X
tessellation_cache_size
tev;
tfU:
tg<*K
tgD:
th*;073:
th<V3
that provides the minimal Euclidean norm of the solution will be computed.
that should be discarded according to the threshold
the D_COMMIT_TRIG_TRANSFORM routine.
the D_COMMIT_TRIG_TRANSFORM routine. Assigning to DPAR(1) the default value
the S_COMMIT_TRIG_TRANSFORM routine.
the S_COMMIT_TRIG_TRANSFORM routine. Assigning to SPAR(1) the default value
the call to D_FORWARD_TRIG_TRANSFORM/D_BACKWARD_TRIG_TRANSFORM routine.
the call to S_FORWARD_TRIG_TRANSFORM/S_BACKWARD_TRIG_TRANSFORM routine.
the call to d_forward_trig_transform/d_backward_trig_transform routine.
the call to s_forward_trig_transform/s_backward_trig_transform routine.
the d_commit_trig_transform routine.
the d_commit_trig_transform routine. Assigning to dpar[0] the default value
the default value.
the first call to DCG routine. Otherwise, the maximal
the parameter 'BCTYPE' were out of admissible range {D,N,P} during initialization stage.
the parameter 'BCtype' is not in the admissible range {D,N,P} during the initialization stage.
the parameter 'BCtype' was outside of the admissible range {D,N,P} during the initialization stage.
the s_commit_trig_transform routine.
the s_commit_trig_transform routine. Assigning to spar[0] the default value
this data vector.
this problem.
thn:T
tiY:SV[
tiz;
tj:O
tj;5R$
tl09
tlS>
tn$;Wc
tn)=0O
tnO:
tny<l\nB
to provide memory for temporary data structures.
to use periodic boundary conditions in x axis direction.
to use periodic boundary conditions in y axis direction.
to use periodic boundary conditions in z axis direction.
to;6O"
toR;
to\v>0
tolerance multiplied by the matrix row L_2 norm)
too many geometries inside scene
total = 
total memory wanted here: %d kbyte
total memory wanted here: %lli kbyte
tp9~
tp:T~P
tp<O
tp<\nZ3
tr9~h
tr<v
transform.elements[iRow][iColumn]
traverser
traverser_mb
tri_accel
tri_accel_mb
tri_builder
tri_builder_mb
tri_traverser
tri_traverser_mb
triangle4
triangle4i
triangle4v
triangle4vmb
triangles
triangles:
ts,<aM
ts;VD
tsD<;
tsy:
tuC;
tv;J
tv>`I6=yW
tx<w]Y
ty91
ty<_V
tyj=t
tyz;
tz;0
tz=3
tzD;
t|9NM
u(;3EV;
u);Yo
u*>hr
u*l9
u,d9
u.>:wSG
u/9Q
u0:y
u0G<
u0e:
u1T;
u2-;C
u29;
u2;9
u2<z\f
u2=T
u36<
u3:fH
u3<U
u3Z=
u4:2W
u4;E
u72<~
u79 
u7;otR;U
u7K:
u7n;w7$
u8Li
u8ff
u8g~.
u8n\n
u9U@
u9zAQ
u:5C
u:8O
u:=qH
u:Jri
u:Wl5
u:o~1
u:rc
u:s(h
u:sg
u:xh
u;0I
u;2*m
u;5c
u;;UsK
u;FL
u;G/H
u;HK
u;Lx
u;M=Q
u;Q.l
u;Y<x
u;YCU
u;fVI
u;ho
u;kU
u;kua
u;sL
u;se
u;tN
u;ue
u;wN,
u;wv1
u<,oK
u<>xg
u<BC
u<Fo
u<LkP
u<hH
u<lk
u<nK
u=57
u=:yM
u=R\n0
u=VV
u=Vd
u=b9
u=vU
u>2jh;
u>Ak
u>O;N
u>P\tC
u>Vb
u?I9
uA9J
uA;=Ne`=aE
uB<_Kt
uBa|)CG
uC9%
uC:4
uC<E3
uC<Y3V
uC>F
uCe:_
uD:h
uD;?4
uD<Pm
uD?;x
uDU;
uDx;!
uE9p
uE=@t
uEL;
uEd:
uEw:
uF;\tF
uF<xX
uFV:]
uG;S
uG;T
uG>h
uH=ye
uHU<
uI/<g
uI:M
uI;8
uJ3<a
uJ:0
uJ:52
uJe:d
uK8o-
uK;xXL
uK=D
uL!9
uMY<
uN:=e
uN:w\n*9T
uN;mu
uNE;
uNi<
uO;E
uP"=Z
uP96K\v9
uP;x
uP>Y
uQ(<G
uQr;s
uR$;v
uS=v
uSj<
uT<^h
uU<`L
uV;j,
uVl:
uW4>
uW;H
uWh<Z+
uX<8
uX};G
uY<opx<c
uYM;
uZ;I
uZ;fV
uZEeu
u\f;Z
u\f<VH
u\fV;p
u\nK>O
u\t;oV
u]T=zsa=$S
u_H:dB
u`M9
u`U<n
ub;N
ube<
ucF:\T
ucH=
ucO;oO09
udA<
ue?9
uf:k
uf=j
ufZ;
uf\v:5n
ufl9
ug;i
ui:B0
ui="jf
uintr
uj;9
um0;L
um;O
um;o(k
un;DW{
un;Y
unable to open output file. Print to STDOUT
unknown buffer type
unknown builder 
unknown exception caught
unknown hair acceleration structure 
unknown motion blur hair acceleration structure 
unknown motion blur triangle acceleration structure 
unknown quad acceleration structure 
unknown quad motion blur acceleration structure 
unknown readable property
unknown subdiv accel 
unknown subdiv mblur accel 
unknown traverser 
unknown triangle acceleration structure 
unknown writable property
unsuitable for this data vector.
uoA;?
up:8
up:K
up;Ijf
upL;
updateTransform
uq93
uq`:)SK
urY<+
us=}a
use rtcJoinCommitScene to join a build operation
used = 
usemtl material_%d\n
user_threads
usergeom
usermsr
utV9
utv=\tV
uu;U0
uv0<
uwo;Pw
uwq;
uwy:
uxc>
uxk<
uzb<@
u|D8
v %f %f %f\n
v 9Fw
v"9F
v#S;Pe#
v)9%4o:
v,B9
v-=52
v-X;6
v.4:N
v.<zBA
v/94
v0,<\nTF
v0,<z
v0;fd
v0>O
v19=
v2;[8e
v2Y:#
v2Z;s\f
v2d=
v2h>/
v3!9
v46>
v59I
v5;B
v6:u
v6;K
v6<E
v6>L-
v7 N
v70>
v7;w
v7=h
v7Y:
v7g=
v8;Pg
v8\nSE
v9#s
v9+M=9
v9.c
v97X
v9:B
v9[p
v9d[z:
v9mEP
v9rG
v9u:d
v9~u
v:41s
v:4w
v:<mF2;T,
v:Hb
v:Pp
v:Ud
v:W3
v:lP :TFt82
v:o~P
v:q1
v:rg
v:rs
v:vj
v:xr
v;"i4
v;5l+:1j(;\t
v;Cj
v;GM#
v;J1@
v;Tz
v;VW
v;`48
v;`n5
v;hB
v;hf
v;|M5
v;|Qm
v<4b
v<9M
v<L3o
v<X1N
v<XX
v<Zc
v<a0k
v<ch>
v<ei
v<zf
v=8Y
v=IG
v=Qeh>-
v=T:h
v=_eo
v=ag\v
v=lsM
v>P9#>nV
v>bU
v@DIMENSION_SCALE
vAl~
vB 9
vB;.9
vB=)2
vBU:2
vBd<
vC;5
vC<RDJ<s
vC=Eu}=
vD3;
vD:O
vE%<d
vE:n 
vF =U
vF;6S8:%
vF;Q
vF<a5L
vGa:
vH>s|
vK;A\fL
vK;t
vKR<
vL77
vL;l
vM:c[
vM<$r
vM<6
vM>TY
vMF<
vM~;Av
vN;\fLu
vN<\vq
vNj:E
vO<[N
vOx;
vR2<
vR;g
vS9&C
vS<>1
vT$9f
vT9=
vT:Wb
vT;nur;W
vTv<F
vU;M
vUG<8
vVV;
vWb<)
vWf;Ob
vX;z
vX=j
vYK<
vYz;k
vY|;j
vZu;
vZz;
v\G<I
v\v<or
v\v_;VYf:UPH
v_t5!
vaes
value has appeared (small with respect to the input
vbM<
vbounds not implemented for this geometry
vc<PM?;l
ve<z
vector<bool> too long
vertex buffer can be at most 16GB large
vf:V
vf;wOu
vf=;,UG;e
vf?;A@F
vg\v;.JB;N
vh<1
vhT;m$k
vhW<
vhW="
vie8
vj&<SS
vj(:A
vjO7
vjq;
vl2=
vlinearBounds not implemented for this geometry
vlz;
vmB;
vmm:
vmt:
vn99
vn[<W
vnr;
vo9=
vo=K
voa=
void*
vp:D
vp;y
vpclmulqdq
vq;5f
vq;a
vqJ=C`
vqt<y
vr:B
vr;G"
vs;y{
vt;\vqi
vt>Dk
vtB;
vu:XXR:
vu<!g
vwt9A
vx:Pt
vxQ;
v{;9I&9
v~:oe
v~=Jr
w$CK
w%7;9Q
w&;BM
w':UlO
w)<ur
w+=P8
w,M8
w,a;Yk
w/>9B
w0<v2
w0<y6\n<
w0\t<3u'
w1;0
w1<S
w1<j
w1L;Z
w2&:sx
w29iN\t
w30<-
w39\n
w3f;
w4:C2
w7:1.
w7:N!
w7=w
w8<i?
w8M<P
w8n<
w9$f
w9;ox
w9B7
w9GS
w9K8J
w9K}
w9Rr
w9T\rM
w9Z;
w9^M\r
w:)Z9
w:6L
w:7N
w:Am
w:GY
w:Jy;
w:Lj
w:P2
w:Q3
w:p5
w:pT
w:xD
w:y5
w:}0b
w;7a
w;9c)
w;G9
w;Jt6
w;eqi
w;fb
w;fv
w;m7
w;pz
w;q2
w;rK
w;rWz;5
w;sG\n
w;tG
w<'ON
w<9l&
w<<ad
w<?ZB
w<G6
w<Q\fW
w<S4
w<Tz
w<Y3
w<om
w<th
w=Ku[
w=gU
w=h:X
w=wSN=
w>B7c=
w>jfg
w?;3M
wB;9
wB;t
wB<1
wB<2
wC:s
wC><v
wD:O
wD:m
wD;Jm
wD;f
wF7=1D
wF;B
wF=d
wF\:Pjb
wFi>
wH:9
wHG<q
wHI;
wI:n
wI<Y&
wIz<=Ug
wJo;{Q
wKl:
wL<b
wLX:
wL~8
wMH;
wN;I
wNB:B
wNU:
wNh:]
wOb:mj
wP;Bz
wP;O6
wRs;
wS;c%
wSt<R
wSt=
wSw;
wT6<`
wT:;dsp<
wT:Fv
wTV<l
wTy<
wU9y
wUF;b
wV<9
wV[;C
wW:D9
wX;K
wX<K
wY;P
wZ<Q
wZw=www w
w[z:t
w\f9.8
w\fb:A
w\t9\v/};xrb:
w^89f
w^;5aD
w_*<GaQ
w_<xe
w`W=U
wa-<Q
waJ;
wa\9
waitpkg
was altered by mistake outside of the D_COMMIT_TRIG_TRANSFORM routine.
was altered by mistake outside of the S_COMMIT_TRIG_TRANSFORM routine.
was altered by mistake outside of the d_commit_trig_transform routine.
was altered by mistake outside of the s_commit_trig_transform routine.
wasted = 
wb)<o
wb1<
wb9G
wb9X-s
wb:8
wbnoinvd
wd<EM
wda;E
we;D
we;\nS8
we;u
wgM;
wgj;p4
wh<Zc
wh?9nMW>
whK:
which is equal to %e
which is equal to %s
wi:R
wide-kl
will always lead to failure in computation of LU factors.
wj;7
wj;CU
wl989d
wlY>s#
wm;E
wms;
wmw;+
wn7:
wn=V
wn_;Ys
wog=F
wop;
wop<
wq9;
wr9= 
wr9f
wrmsrns
wrong column indexes in CSR format.
wrong integer array of row positions in its CSR
wrong row indexes in CSR format.
ws1:Mt
ws;3
ws;PXR
wt4:M
wu4:
ww;;M
wx<2
wxc;J
wy:-hs9
wyP<
wz;4y
w{9YM
w|y<Q
x 38|
x!<ob
x"5Q
x"9CL
x*9U
x+9- G8
x+9t
x+:xb
x+<efI
x-8k
x-;CT0;
x-<Ea
x.>5bF
x/?j3
x0=@T
x0E;4
x0Q;
x0a<
x1;1J
x1<h
x1b<
x1f;
x3T;
x47\v
x4=63
x4I9
x4j;
x5;T
x5<rA
x6:Qx
x6;)X
x7=i0
x82;n
x8:Sb(8h
x8>T
x8W^[
x9,u
x91=2
x9:o
x9;8
x9A7
x9PF
x9S:
x:0F
x:8N
x:;dH
x:A4
x:LW
x:P5Q:Zx{:
x:Qv
x:T2
x:WW
x:Yr
x:\rhN
x:b3
x:dW2
x:oV
x;0q
x;1v
x;9U
x;9w
x;<a 9p
x;@D7
x;CaR
x;DI
x;Gc
x;R7
x;T(v
x;UC
x;WL
x;Yn
x;ar
x;eb
x;hKR:]
x;h]X
x;q_x9!
x;uLO:
x;v8N
x;~KH
x<.BD
x<0f
x<1f
x<8N
x<D5
x<UC
x<\vdw
x<rD
x<t5
x=4Q
x=;3I
x=RA]
x=tk
x>V6'
x>V6'?C
x?;1BN
x@M;r
xA8}S
xBf<0
xC1<
xC\t>B
xD;}M
xDq=
xEV<V>;
xEg;M
xEz7
xFG;vMV
xG=V
xH:h
xH;C\r
xHY9#yn:?<
xHn;
xI;kS
xIO=q
xJ:<f
xK:IR
xK:q
xKe>
xK~8
xL<Wt
xL>3
xM;\YU
xM=PR
xN)9
xN.<S
xNd:
xO3;K
xO6:
xOu<
xP:Ed\r;
xQ4:\fF
xR;[SA:L
xRB<
xRC:
xRJ<X
xRZ;U>|
xS69:yX
xS9J
xS;I
xT(<u
xT6<
xU9:O|-
xU9`
xU:M
xU:b~
xU;qGK
xUR;
xV;a
xV;k
xVj==
xW8=
xX'>ubW<]1
xX8:
xX\r<Xx
xXc;
xY:E
xY:h
xZ2;
x[9[xE:
x\f=9Z
x\fy<2
x\g:cH
x\r:Q8
x\rr9L
x\vm<J
x_u;d
xaB<
xa\r;q
xb&<A
xb8y
xc9%
xdO;
xe;&j
xeM:
xekv
xeq<H
xf;}ws
xg:Y
xg?l<
xgd>
xi;a
xk]:45R
xls<u
xm;`p
xmw;:
xn9t
xnj=
xo%;c
xo;b
xo=v
xoY<p
xot<
xp;D
xpK;
xr<Ir{
xu5:K
xuc;
xx:j
xx;4
xxJ<&X
xy;O
xy<Aq9<
xye;
xz<D
x};je
y!k;C
y&8M)
y(J9h1
y(c9
y)W9
y-N:Pv
y/8Qv`
y0;nv
y0G=XM
y1<\rE
y1=L
y1d<0%
y2=O
y33<u
y3;C
y3H:wO
y3P;
y49:
y4<G3+
y6"<h
y69S
y6pV
y6y;
y7/=S
y7;U
y7=G
y7i;
y7x;
y86<\t
y8:g
y8;2N
y8J<
y8PF
y9&\rw9|
y9'$x
y99U
y9:h
y9;N
y9<dn
y9Oh
y9k>":0
y9v1
y9x0C;\n#
y9ze
y:@FO
y:Bm(:t
y:CFv
y:HBp
y:IW
y:RL/
y:S6 
y:ZQ
y:di
y:pQ
y:tz
y:yH/
y;-y5
y;47
y;9p
y;BC
y;ES-
y;FG
y;H8
y;P"R
y;Pb
y;Ti5
y;Vc
y;XL
y;aA
y;cev:V
y;eY
y;kw
y;zj
y<6W
y<;TDf
y<Hs
y<Px
y<S^I
y<l:lEV
y<p0
y<uT
y<|cg
y<}FR
y=4Q
y=F:LO
y=PO
y=q2
y=vf
y>I:O
y>JE
y?7C
y?Nny?
y?YN
y?aG
y?ar
yA9>
yA9TYi
yA:(Z
yB<m
yC:t
yCZR
yC\t9
yF%9
yF<m
yFF<m
yG&=w
yG:K.
yG;,<F;n%G;7
yG;p
yG<N
yGE:
yHI=
yI!<o;P
yI;9
yJd<
yLH<
yLL;
yM!=5
yM:'S`9
yM:9S
yM;o
yM<pI
yN<qyC
yNO<
yO7<G
yOO;
yOQ;.
yO\f9
yP:w
yPh<5
yQ&<C7
yQ:E
yS8UC
yS:U
yT(9
yTw:D
yTw:Nr
yU:H
yU;J\v
yUt;P
yV;g
yWi<'
yY;U
yY;rY8
yY=d
yZ;I
yZt>
yZy;
y\f=Zb
y\n;35
y\r;PK
y\rk;b
y\v<xz\v3h{\v*t
y]=iA
y^9j
y^O;T
yb5;
yb:1
ybt9
yc0<
yc3<
yc6;3
ycD:a
ycI<p
ycO:"K|
yd:t|
yd=Oi*
ydN<
ydw:
ye;oS
yf;y|
yfS<
ygV:J(6
ygw:
yh;8
yh;J6
yh;a
yiT>
yi_;s
yjv<
yj~;G
yk:t
yk>n
yl:4
ylk;
yn->l7
yni;t
yob;
you have to wait for spawned subtasks
ypE<Y
yp\n<L
ypg<
ypl<
ypm;pR>
ypy:^
yqg<
yrA;\t
yrL9JT
yrg;
ys:f
ys;G
ys<3
yu8<
yw96
yw9r
yw;tk
yw=S
yx9=
y~p=q
z ;Aq
z <tHm
z v"z$e
z&t;K
z&z;X
z'Q=U
z(:zO
z)4:89
z*X=A
z*Y9Pw
z+R<4T,
z,9F
z,;EAI
z,;eM
z.:Xm
z096?
z0;{c
z0=|Q
z0U;6x
z12;
z1t9\
z2v;Ns
z49a\f
z4:(lk;
z5=e
z5K>
z6n<i
z7:hv
z7<Gi 
z7H<ur
z7dqR
z8;'N
z8;I
z8;Q
z8;p
z8;x
z8W;r=A;ATB
z8h=
z8t;
z91z
z95# 
z95;
z9;Y
z9<G
z9>z\rf?
z9Ax
z9Bn
z9\b
z9^l
z9xb
z:3:D8a0
z:3{g:xp
z:5p
z:FHI
z:Gm
z:Rol
z:YG
z:\feY
z:gg?
z:jU
z:q2
z:vE
z:vhT;
z:zU
z;4FJ
z;4N
z;6J
z;7WH
z;<ql
z;AF
z;A\nC
z;BO
z;Bb
z;GRt;
z;NV
z;S(R
z;V2
z;\tOg<K
z;_SS
z;bhD;
z;bpj
z;bx
z;fQu
z;h0
z;hDX
z;hb
z;lyB
z;mz
z;sZ
z;tx
z<%a7
z<62P=
z<;<fvu
z<H>v
z<Vi
z<Y6
z<hf
z=8i6
z=;NSH;
z=Bx
z=T/P=tA
z=W6
z=l4
z>L-g
z?;02
zA7<EU
zA>n'
zAM;k?~
zBn>
zC9I
zC=v
zCW;
zD7>
zDk>
zE :J
zE=V
zFe9
zGD<
zGK<
zGZ;
zH<Z2
zH=:m
zHi;
zI92
zI:E
zI<P_
zJ5<W
zJ6;[O?
zJm;@
zKu=
zL<&Cs;2
zL\r;N
zO;c
zOG<
zQU;(
zQv<>8
zR:y=
zR;\rx
zRa;
zRc;>E
zS8o
zSO<
zSO<n
zSf;
zT90
zUU;
zVb5
zVg;
zWf>
zX ;7
zX6=
zX:i
zXG;|
zXH<
zY6;j^
zY<E
zY<t9
zY>2
zYk<
zZ;u
z\%<Bu9
z\t9k
z`9V
za5:B
za;W
zaT=
zb2:E,
zbl9
zbu<
zc9;
zc=<s
zcN;u
zd2<
ze:ue
ze<58
zf8;+
zf;V9
zg=Y
zgP9(
zh:8n$
zh=Q?
zh\t<6
zhs9V
zi3==
zi9uMe
zi;H
ziA<
zjM=
zk3:\t(5
zkD;=N
zkM;
zkj;
zn;W
zoH:
zoY;
zq;&j
zq<gCn
zq>eH
zqo:
zr;T
zrx;
zt;D
zt?r
zu;b
zut<[H
zxC;w
zxi=
zz1;j1
zzp;lQ
{ %i, %i } :  Memory overwrite in %s 
{ %i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %11.4f 
{ %i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %11.4f + i* %11.4f 
{ %i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %20.7lf 
{ %i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %20.7lf + i* %20.7lf 
{ %i, %i } : %s  Memory overwrite in %4s-guardzone: loc( %i) = %i 
{ %i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %11.4f 
{ %i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %11.4f + i* %11.4f 
{ %i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %20.7lf 
{ %i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %20.7lf + i* %20.7lf 
{ %i, %i } : %s  Memory overwrite in lda-m gap: loc( %i, %i) = %i 
{ %lli, %lli } :  Memory overwrite in %s 
{ %lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %11.4f 
{ %lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %11.4f + i* %11.4f 
{ %lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %20.7lf 
{ %lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %20.7lf + i* %20.7lf 
{ %lli, %lli } : %s  Memory overwrite in %4s-guardzone: loc( %lli) = %i 
{ %lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %11.4f 
{ %lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %11.4f + i* %11.4f 
{ %lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %20.7lf 
{ %lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %20.7lf + i* %20.7lf 
{ %lli, %lli } : %s  Memory overwrite in lda-m gap: loc( %lli, %lli) = %lli 
{%5i,%5i}:  On entry to 
{0;7zA
{19c
{5E8
{5F9
{7=7gS=
{8FN
{8V;g
{94B
{9E8a:
{9dOK:
{;lnq
{;t1Q
{<cQn
{<cvC=Z
{D:#)g:rEy9
{E;LS
{H:HL
{K-;EzY
{O;vG
{RCa
{U`8T
{V8l
{W2:L3
{Y;Xy
{cJ=a
{fO;Qm
{gV:z
{n9%HL
{s<yln
{sA9
{tS9
{u:M5
|1;u5
|68F
|8KY
|9HN#
|9Pw"
|9gN
|9y>L
|:ELH9dR{9N
|:Oer
|:jv2
|;1ZA
|;FH5
|;gyt
|;xBr
|<K5f
|<iXh<z
|D:Nl
|D=R5
|HY:y
|Ig8-Q
|J79
|KZ9
|OE<Z
|P9oc
|R:o1j;
|Rv73]
|Sa9r
|T;dt
|W8<q
|W95Z
|W=rT
|X2<B
|Y8S
|Y;83
|Z0=M,N
|\n1=L88
|eA=4
|h>ev
|j:P7
|n8P
|v94
|xH<jc
|y=Cy
}0;dT
}1e;y
}2R;o
}2\f:p4q
}4=rU
}7:vrt:0
}7=dUt=
}8#Po:M
}8)P4
}8;XM8
}9)dB
}9J@m
}9VO7
}9Vn"
}9Yi
}9rY
}:0LF
}:g%H9V
}:i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4i!"4
};C1G
};aSU:LD
};wRX
}<fDL
}=3Fd
}>94rP
}A;h9
}C98
}F\t;PHO;Q
}L3;Kp`
}L4;A
}N<Yj
}Q"9H
}R<g3
}Sm<HF
}T<qf
}Tk;x
}V;3{59
}V;97
}Vd;Q
}W9n
}Wq:w
}XG;O
}Y6:6
}Y:aB3;Y
}Z9P
}e3m{
}g5=b\nj
}k>F6
}kZ8
}li=YU
}om;m
}r2:bO
}sE9
}v-;bG6
}x:U8
~03z
~29e
~7nuH8
~8R48
~9Az
~9b^N
~9za^
~:0WG
~:4pU
~:90U9
~:z4S
~;0M6
~;OMK8]
~;TxT
~;r66
~<Hul
~=8MK
~AP8
~CEU
~F@92
~H;wu
~I>MG
~N:28
~N;8K
~Px:1IN
~Ss9
~Uo:DR
~c8V
~c<sH
~f8U
~gW<F
~i3<HO
~i9}5
~j=rB
~l=8b
~mE9
~s9i
~tB9
~uX;F
~un>3
~w9z
~zI<g
